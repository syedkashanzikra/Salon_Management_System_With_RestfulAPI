var zn = Object.defineProperty;
var Hn = (e, t, l) => t in e ? zn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l;
var Te = (e, t, l) => (Hn(e, typeof t != "symbol" ? t + "" : t, l), l);
import { unref as $, computed as u, ref as R, shallowRef as xa, watch as oe, getCurrentScope as oo, onScopeDispose as no, shallowReadonly as vt, watchEffect as Ht, readonly as ye, effectScope as so, isRef as La, toRef as ke, customRef as Rn, getCurrentInstance as ia, onMounted as He, nextTick as Ce, reactive as St, defineComponent as N, h as ie, Teleport as Na, toValue as Qe, onActivated as Mn, onBeforeUnmount as ro, openBlock as g, createElementBlock as P, Fragment as ce, createElementVNode as K, renderSlot as O, normalizeProps as Be, guardReactiveProps as Ve, createVNode as be, withCtx as j, mergeProps as ee, normalizeClass as H, normalizeStyle as ze, createTextVNode as ne, toDisplayString as Y, createCommentVNode as J, createApp as Dn, provide as De, createBlock as M, resolveDynamicComponent as le, inject as Oe, toHandlers as io, Transition as jn, useSlots as Fe, useAttrs as za, withModifiers as ot, renderList as he, withKeys as It, TransitionGroup as qn, withDirectives as rt, vShow as ua, isReactive as Gn, onUnmounted as Wn, vModelCheckbox as Un, vModelRadio as Xn, vModelSelect as Kn, createSlots as Ha } from "vue";
const Yn = (e) => typeof e == "boolean" || e === "" || e === "true" || e === "false", Ra = (e) => typeof e == "boolean" ? e : e === "" || e === "true";
class Ge {
  constructor(t, l = {}) {
    Te(this, "cancelable", !0);
    Te(this, "componentId", null);
    Te(this, "_defaultPrevented", !1);
    Te(this, "eventType", "");
    Te(this, "nativeEvent", null);
    Te(this, "_preventDefault");
    Te(this, "relatedTarget", null);
    Te(this, "target", null);
    if (!t)
      throw new TypeError(
        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`
      );
    Object.assign(this, Ge.Defaults, l, { eventType: t }), this._preventDefault = function() {
      this.cancelable && (this.defaultPrevented = !0);
    };
  }
  // Readable by everyone,
  // But only overwritten by inherrited constructors
  get defaultPrevented() {
    return this._defaultPrevented;
  }
  set defaultPrevented(t) {
    this._defaultPrevented = t;
  }
  // I think this is right
  // We want to be able to have it callable to everyone,
  // But only overwritten by inherrited constructors
  get preventDefault() {
    return this._preventDefault;
  }
  // This may not be correct, because it doesn't get correct type inferences in children
  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue
  set preventDefault(t) {
    this._preventDefault = t;
  }
  static get Defaults() {
    return {
      cancelable: !0,
      componentId: null,
      eventType: "",
      nativeEvent: null,
      relatedTarget: null,
      target: null
    };
  }
}
class Rt extends Ge {
  constructor(l, a = {}) {
    super(l, a);
    Te(this, "trigger", null);
    Object.assign(this, Ge.Defaults, a, { eventType: l });
  }
  static get Defaults() {
    return {
      ...super.Defaults,
      trigger: null
    };
  }
}
class uo extends Ge {
  constructor(l, a) {
    super(l, a);
    Te(this, "from");
    Te(this, "to");
    Te(this, "direction");
    Object.assign(this, Ge.Defaults, a, { eventType: l });
    const { from: o, direction: n, to: s } = a;
    this.from = o, this.to = s, this.direction = n;
  }
  static get Defaults() {
    return {
      ...super.Defaults
    };
  }
}
const ba = (e) => e !== null && typeof e == "object", co = (e) => /^[0-9]*\.?[0-9]+$/.test(String(e)), Jn = (e) => Object.prototype.toString.call(e) === "[object Object]", fo = /_/g, vo = /([a-z])([A-Z])/g, Zn = /(\s|^)(\w)/g, Qn = /(\s|^)(\w)/, Kt = /\s+/, es = /^#/, ts = /^#[A-Za-z]+[\w\-:.]*$/, as = /-u-.+/, ls = /[-/\\^$*+?.()|[\]{}]/g, os = /[\s\uFEFF\xA0]+/g, Zt = (e, t = 2) => typeof e == "string" ? e : e == null ? "" : Array.isArray(e) || Jn(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e), il = (e) => e.replace(fo, " ").replace(vo, (t, l, a) => `${l} ${a}`).replace(Qn, (t, l, a) => l + a.toUpperCase()), ul = (e) => e.replace(fo, " ").replace(vo, (t, l, a) => `${l} ${a}`).replace(Zn, (t, l, a) => l + a.toUpperCase()), ns = (e) => {
  const t = e.trim();
  return t.charAt(0).toUpperCase() + t.slice(1);
}, ss = (e) => e.replace(ls, "\\$&"), rs = (e) => ss(e).replace(os, "\\s"), ma = (e) => `\\${e}`, is = (e) => {
  const t = Zt(e), { length: l } = t, a = t.charCodeAt(0);
  return t.split("").reduce((o, n, s) => {
    const r = t.charCodeAt(s);
    return r === 0 ? `${o}ï¿½` : (
      // ... is U+007F OR
      r === 127 || // ... is in the range [\1-\1F] (U+0001 to U+001F) OR ...
      r >= 1 && r <= 31 || // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...
      s === 0 && r >= 48 && r <= 57 || // ... is the second character and is in the range [0-9] (U+0030 to U+0039)
      // and the first character is a `-` (U+002D) ...
      s === 1 && r >= 48 && r <= 57 && a === 45 ? o + ma(`${r.toString(16)} `) : (
        // ... is the first character AND ...
        s === 0 && // ... is a `-` (U+002D) AND ...
        r === 45 && // ... there is no second character ...
        l === 1 ? o + ma(n) : (
          // ... is greater than or equal to U+0080 OR ...
          r >= 128 || // ... is `-` (U+002D) OR ...
          r === 45 || // ... is `_` (U+005F) OR ...
          r === 95 || // ... is in the range [0-9] (U+0030 to U+0039) OR ...
          r >= 48 && r <= 57 || // ... is in the range [A-Z] (U+0041 to U+005A) OR ...
          r >= 65 && r <= 90 || // ... is in the range [a-z] (U+0061 to U+007A) ...
          r >= 97 && r <= 122 ? o + n : o + ma(n)
        )
      )
    );
  }, "");
}, po = typeof window < "u", mo = typeof document < "u", us = typeof Element < "u", ds = typeof navigator < "u", cs = po && mo && ds, dl = po ? window : {}, Ma = mo ? document : {};
(() => {
  let e = !1;
  if (cs)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          return e = !0, e;
        }
      };
      dl.addEventListener("test", t, t), dl.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})();
const Da = typeof window < "u", fs = typeof document < "u", vs = typeof navigator < "u", ja = Da && fs && vs, cl = Da ? window : {}, ps = (() => {
  let e = !1;
  if (ja)
    try {
      const t = {
        // This function will be called when the browser
        // attempts to access the passive property
        get passive() {
          e = !0;
        }
      };
      cl.addEventListener("test", t, t), cl.removeEventListener("test", t, t);
    } catch {
      e = !1;
    }
  return e;
})(), xe = us ? Element.prototype : void 0, ms = (xe == null ? void 0 : xe.matches) || (xe == null ? void 0 : xe.msMatchesSelector) || (xe == null ? void 0 : xe.webkitMatchesSelector), Ue = (e) => !!(e && e.nodeType === Node.ELEMENT_NODE), gs = (e) => Ue(e) ? e.getBoundingClientRect() : null, ys = (e = []) => {
  const { activeElement: t } = document;
  return t && !e.some((l) => l === t) ? t : null;
}, bs = (e) => Ue(e) && e === ys(), hs = (e, t = {}) => {
  try {
    e.focus(t);
  } catch (l) {
    console.error(l);
  }
  return bs(e);
}, Bs = (e, t) => t && Ue(e) && e.getAttribute(t) || null, Ss = (e) => {
  if (Bs(e, "display") === "none")
    return !1;
  const t = gs(e);
  return !!(t && t.height > 0 && t.width > 0);
}, Ae = (e) => ((e == null ? void 0 : e()) ?? []).length === 0, go = (e, t) => (Ue(t) ? t : Ma).querySelector(e) || null, ws = (e, t) => Array.from([(Ue(t) ? t : Ma).querySelectorAll(e)]), qa = (e, t) => t && Ue(e) ? e.getAttribute(t) : null, _s = (e) => Ma.getElementById(/^#/.test(e) ? e.slice(1) : e) || null, $s = (e, t, l) => {
  t && Ue(e) && e.setAttribute(t, l);
}, Cs = (e, t) => {
  t && Ue(e) && e.removeAttribute(t);
}, ks = (e, t) => Zt(e).toLowerCase() === Zt(t).toLowerCase(), jt = Da ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || // Fallback, but not a true polyfill
// Only needed for Opera Mini
((e) => setTimeout(e, 16)) : (e) => setTimeout(e, 0), yo = (e, t) => Ue(e) ? ms.call(e, t) : !1, Ts = (xe == null ? void 0 : xe.closest) || function(e) {
  let t = this;
  if (!t)
    return null;
  do {
    if (yo(t, e))
      return t;
    t = t.parentElement || t.parentNode;
  } while (t !== null && t.nodeType === Node.ELEMENT_NODE);
  return null;
}, fl = (e, t, l = !1) => {
  if (!Ue(t))
    return null;
  const a = Ts.call(t, e);
  return l ? a : a === t ? null : a;
}, ha = (e) => {
  const t = window.getComputedStyle(e), l = t.transitionDelay.split(",")[0] || "", a = t.transitionDuration.split(",")[0] || "", o = Number(l.slice(0, -1)) * 1e3, n = Number(a.slice(0, -1)) * 1e3;
  return o + n;
}, da = (e, t, l) => t.concat(["sm", "md", "lg", "xl", "xxl"]).reduce((a, o) => (a[e ? `${e}${o.charAt(0).toUpperCase() + o.slice(1)}` : o] = l, a), /* @__PURE__ */ Object.create(null)), bo = (e, t, l, a = l) => Object.keys(t).reduce((o, n) => (e[n] && o.push(
  [a, n.replace(l, ""), e[n]].filter((s) => s && typeof s != "boolean").join("-").toLowerCase()
), o), []), at = (e = "") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`, wt = (e) => !!(e.href || e.to), Ne = (e, t = {}, l = {}) => {
  const a = [e];
  let o;
  for (let n = 0; n < a.length && !o; n++) {
    const s = a[n];
    o = l[s];
  }
  return o && typeof o == "function" ? o(t) : o;
}, lt = (e, t = NaN) => Number.isInteger(e) ? e : t, Vs = (e, t = NaN) => {
  const l = Number.parseInt(e, 10);
  return Number.isNaN(l) ? t : l;
}, Et = (e, t = NaN) => {
  const l = Number.parseFloat(e.toString());
  return Number.isNaN(l) ? t : l;
}, As = (e, t) => Object.keys(e).filter((l) => !t.map((a) => a.toString()).includes(l)).reduce((l, a) => ({ ...l, [a]: e[a] }), {}), Mt = (e, t) => [...t].reduce((l, a) => (l[a] = e[a], l), {}), vl = (e, t) => t + (e ? ns(e) : ""), ca = (e, t) => e === !0 || e === "true" || e === "" ? "true" : e === "grammar" || e === "spelling" ? e : t === !1 ? "true" : e === !1 || e === "false" ? "false" : void 0, ho = Symbol("carousel"), Bo = Symbol("tabs"), So = Symbol("progress"), wo = Symbol("listGroup"), _o = Symbol("avatarGroup"), $o = Symbol("accordion"), Co = Symbol("checkboxGroup"), ko = Symbol("radioGroup"), Ga = Symbol("collapse"), To = Symbol("collapse"), Wa = Symbol("navbar"), Ba = (e, t) => ((e == null ? void 0 : e()) ?? []).reduce((l, a) => (typeof a.type == "symbol" ? l = l.concat(a.children) : l.push(a), l), []).filter((l) => {
  var a;
  return ((a = l.type) == null ? void 0 : a.__name) === t;
});
function qe(e) {
  return e.split("-")[1];
}
function Ua(e) {
  return e === "y" ? "height" : "width";
}
function Re(e) {
  return e.split("-")[0];
}
function Tt(e) {
  return ["top", "bottom"].includes(Re(e)) ? "x" : "y";
}
function pl(e, t, l) {
  let { reference: a, floating: o } = e;
  const n = a.x + a.width / 2 - o.width / 2, s = a.y + a.height / 2 - o.height / 2, r = Tt(t), i = Ua(r), v = a[i] / 2 - o[i] / 2, b = r === "x";
  let h;
  switch (Re(t)) {
    case "top":
      h = { x: n, y: a.y - o.height };
      break;
    case "bottom":
      h = { x: n, y: a.y + a.height };
      break;
    case "right":
      h = { x: a.x + a.width, y: s };
      break;
    case "left":
      h = { x: a.x - o.width, y: s };
      break;
    default:
      h = { x: a.x, y: a.y };
  }
  switch (qe(t)) {
    case "start":
      h[r] -= v * (l && b ? -1 : 1);
      break;
    case "end":
      h[r] += v * (l && b ? -1 : 1);
  }
  return h;
}
const Os = async (e, t, l) => {
  const { placement: a = "bottom", strategy: o = "absolute", middleware: n = [], platform: s } = l, r = n.filter(Boolean), i = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let v = await s.getElementRects({ reference: e, floating: t, strategy: o }), { x: b, y: h } = pl(v, a, i), p = a, B = {}, S = 0;
  for (let m = 0; m < r.length; m++) {
    const { name: A, fn: y } = r[m], { x: k, y: w, data: _, reset: C } = await y({ x: b, y: h, initialPlacement: a, placement: p, strategy: o, middlewareData: B, rects: v, platform: s, elements: { reference: e, floating: t } });
    b = k ?? b, h = w ?? h, B = { ...B, [A]: { ...B[A], ..._ } }, C && S <= 50 && (S++, typeof C == "object" && (C.placement && (p = C.placement), C.rects && (v = C.rects === !0 ? await s.getElementRects({ reference: e, floating: t, strategy: o }) : C.rects), { x: b, y: h } = pl(v, p, i)), m = -1);
  }
  return { x: b, y: h, placement: p, strategy: o, middlewareData: B };
};
function it(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function Xa(e) {
  return typeof e != "number" ? function(t) {
    return { top: 0, right: 0, bottom: 0, left: 0, ...t };
  }(e) : { top: e, right: e, bottom: e, left: e };
}
function _t(e) {
  return { ...e, top: e.y, left: e.x, right: e.x + e.width, bottom: e.y + e.height };
}
async function xt(e, t) {
  var l;
  t === void 0 && (t = {});
  const { x: a, y: o, platform: n, rects: s, elements: r, strategy: i } = e, { boundary: v = "clippingAncestors", rootBoundary: b = "viewport", elementContext: h = "floating", altBoundary: p = !1, padding: B = 0 } = it(t, e), S = Xa(B), m = r[p ? h === "floating" ? "reference" : "floating" : h], A = _t(await n.getClippingRect({ element: (l = await (n.isElement == null ? void 0 : n.isElement(m))) == null || l ? m : m.contextElement || await (n.getDocumentElement == null ? void 0 : n.getDocumentElement(r.floating)), boundary: v, rootBoundary: b, strategy: i })), y = h === "floating" ? { ...s.floating, x: a, y: o } : s.reference, k = await (n.getOffsetParent == null ? void 0 : n.getOffsetParent(r.floating)), w = await (n.isElement == null ? void 0 : n.isElement(k)) && await (n.getScale == null ? void 0 : n.getScale(k)) || { x: 1, y: 1 }, _ = _t(n.convertOffsetParentRelativeRectToViewportRelativeRect ? await n.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: y, offsetParent: k, strategy: i }) : y);
  return { top: (A.top - _.top + S.top) / w.y, bottom: (_.bottom - A.bottom + S.bottom) / w.y, left: (A.left - _.left + S.left) / w.x, right: (_.right - A.right + S.right) / w.x };
}
const $t = Math.min, Qt = Math.max;
function Sa(e, t, l) {
  return Qt(e, $t(t, l));
}
const Fs = (e) => ({ name: "arrow", options: e, async fn(t) {
  const { x: l, y: a, placement: o, rects: n, platform: s, elements: r } = t, { element: i, padding: v = 0 } = it(e, t) || {};
  if (i == null)
    return {};
  const b = Xa(v), h = { x: l, y: a }, p = Tt(o), B = Ua(p), S = await s.getDimensions(i), m = p === "y", A = m ? "top" : "left", y = m ? "bottom" : "right", k = m ? "clientHeight" : "clientWidth", w = n.reference[B] + n.reference[p] - h[p] - n.floating[B], _ = h[p] - n.reference[p], C = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(i));
  let T = C ? C[k] : 0;
  T && await (s.isElement == null ? void 0 : s.isElement(C)) || (T = r.floating[k] || n.floating[B]);
  const c = w / 2 - _ / 2, V = T / 2 - S[B] / 2 - 1, F = $t(b[A], V), f = $t(b[y], V), I = F, E = T - S[B] - f, z = T / 2 - S[B] / 2 + c, Z = Sa(I, z, E), te = qe(o) != null && z != Z && n.reference[B] / 2 - (z < I ? F : f) - S[B] / 2 < 0 ? z < I ? I - z : E - z : 0;
  return { [p]: h[p] - te, data: { [p]: Z, centerOffset: z - Z + te } };
} }), Vo = ["top", "right", "bottom", "left"], ml = Vo.reduce((e, t) => e.concat(t, t + "-start", t + "-end"), []), Ps = { left: "right", right: "left", bottom: "top", top: "bottom" };
function ea(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Ps[t]);
}
function Ao(e, t, l) {
  l === void 0 && (l = !1);
  const a = qe(e), o = Tt(e), n = Ua(o);
  let s = o === "x" ? a === (l ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
  return t.reference[n] > t.floating[n] && (s = ea(s)), { main: s, cross: ea(s) };
}
const Es = { start: "end", end: "start" };
function Yt(e) {
  return e.replace(/start|end/g, (t) => Es[t]);
}
const Is = function(e) {
  return e === void 0 && (e = {}), { name: "autoPlacement", options: e, async fn(t) {
    var l, a, o;
    const { rects: n, middlewareData: s, placement: r, platform: i, elements: v } = t, { crossAxis: b = !1, alignment: h, allowedPlacements: p = ml, autoAlignment: B = !0, ...S } = it(e, t), m = h !== void 0 || p === ml ? function(f, I, E) {
      return (f ? [...E.filter((z) => qe(z) === f), ...E.filter((z) => qe(z) !== f)] : E.filter((z) => Re(z) === z)).filter((z) => !f || qe(z) === f || !!I && Yt(z) !== z);
    }(h || null, B, p) : p, A = await xt(t, S), y = ((l = s.autoPlacement) == null ? void 0 : l.index) || 0, k = m[y];
    if (k == null)
      return {};
    const { main: w, cross: _ } = Ao(k, n, await (i.isRTL == null ? void 0 : i.isRTL(v.floating)));
    if (r !== k)
      return { reset: { placement: m[0] } };
    const C = [A[Re(k)], A[w], A[_]], T = [...((a = s.autoPlacement) == null ? void 0 : a.overflows) || [], { placement: k, overflows: C }], c = m[y + 1];
    if (c)
      return { data: { index: y + 1, overflows: T }, reset: { placement: c } };
    const V = T.map((f) => {
      const I = qe(f.placement);
      return [f.placement, I && b ? f.overflows.slice(0, 2).reduce((E, z) => E + z, 0) : f.overflows[0], f.overflows];
    }).sort((f, I) => f[1] - I[1]), F = ((o = V.filter((f) => f[2].slice(0, qe(f[0]) ? 2 : 3).every((I) => I <= 0))[0]) == null ? void 0 : o[0]) || V[0][0];
    return F !== r ? { data: { index: y + 1, overflows: T }, reset: { placement: F } } : {};
  } };
}, Oo = function(e) {
  return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) {
    var l;
    const { placement: a, middlewareData: o, rects: n, initialPlacement: s, platform: r, elements: i } = t, { mainAxis: v = !0, crossAxis: b = !0, fallbackPlacements: h, fallbackStrategy: p = "bestFit", fallbackAxisSideDirection: B = "none", flipAlignment: S = !0, ...m } = it(e, t), A = Re(a), y = Re(s) === s, k = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), w = h || (y || !S ? [ea(s)] : function(I) {
      const E = ea(I);
      return [Yt(I), E, Yt(E)];
    }(s));
    h || B === "none" || w.push(...function(I, E, z, Z) {
      const te = qe(I);
      let G = function(W, X, ve) {
        const ge = ["left", "right"], pe = ["right", "left"], me = ["top", "bottom"], q = ["bottom", "top"];
        switch (W) {
          case "top":
          case "bottom":
            return ve ? X ? pe : ge : X ? ge : pe;
          case "left":
          case "right":
            return X ? me : q;
          default:
            return [];
        }
      }(Re(I), z === "start", Z);
      return te && (G = G.map((W) => W + "-" + te), E && (G = G.concat(G.map(Yt)))), G;
    }(s, S, B, k));
    const _ = [s, ...w], C = await xt(t, m), T = [];
    let c = ((l = o.flip) == null ? void 0 : l.overflows) || [];
    if (v && T.push(C[A]), b) {
      const { main: I, cross: E } = Ao(a, n, k);
      T.push(C[I], C[E]);
    }
    if (c = [...c, { placement: a, overflows: T }], !T.every((I) => I <= 0)) {
      var V, F;
      const I = (((V = o.flip) == null ? void 0 : V.index) || 0) + 1, E = _[I];
      if (E)
        return { data: { index: I, overflows: c }, reset: { placement: E } };
      let z = (F = c.filter((Z) => Z.overflows[0] <= 0).sort((Z, te) => Z.overflows[1] - te.overflows[1])[0]) == null ? void 0 : F.placement;
      if (!z)
        switch (p) {
          case "bestFit": {
            var f;
            const Z = (f = c.map((te) => [te.placement, te.overflows.filter((G) => G > 0).reduce((G, W) => G + W, 0)]).sort((te, G) => te[1] - G[1])[0]) == null ? void 0 : f[0];
            Z && (z = Z);
            break;
          }
          case "initialPlacement":
            z = s;
        }
      if (a !== z)
        return { reset: { placement: z } };
    }
    return {};
  } };
};
function gl(e, t) {
  return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width };
}
function yl(e) {
  return Vo.some((t) => e[t] >= 0);
}
const xs = function(e) {
  return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) {
    const { rects: l } = t, { strategy: a = "referenceHidden", ...o } = it(e, t);
    switch (a) {
      case "referenceHidden": {
        const n = gl(await xt(t, { ...o, elementContext: "reference" }), l.reference);
        return { data: { referenceHiddenOffsets: n, referenceHidden: yl(n) } };
      }
      case "escaped": {
        const n = gl(await xt(t, { ...o, altBoundary: !0 }), l.floating);
        return { data: { escapedOffsets: n, escaped: yl(n) } };
      }
      default:
        return {};
    }
  } };
};
function bl(e) {
  const t = $t(...e.map((a) => a.left)), l = $t(...e.map((a) => a.top));
  return { x: t, y: l, width: Qt(...e.map((a) => a.right)) - t, height: Qt(...e.map((a) => a.bottom)) - l };
}
const Ls = function(e) {
  return e === void 0 && (e = {}), { name: "inline", options: e, async fn(t) {
    const { placement: l, elements: a, rects: o, platform: n, strategy: s } = t, { padding: r = 2, x: i, y: v } = it(e, t), b = Array.from(await (n.getClientRects == null ? void 0 : n.getClientRects(a.reference)) || []), h = function(m) {
      const A = m.slice().sort((w, _) => w.y - _.y), y = [];
      let k = null;
      for (let w = 0; w < A.length; w++) {
        const _ = A[w];
        !k || _.y - k.y > k.height / 2 ? y.push([_]) : y[y.length - 1].push(_), k = _;
      }
      return y.map((w) => _t(bl(w)));
    }(b), p = _t(bl(b)), B = Xa(r), S = await n.getElementRects({ reference: { getBoundingClientRect: function() {
      if (h.length === 2 && h[0].left > h[1].right && i != null && v != null)
        return h.find((m) => i > m.left - B.left && i < m.right + B.right && v > m.top - B.top && v < m.bottom + B.bottom) || p;
      if (h.length >= 2) {
        if (Tt(l) === "x") {
          const C = h[0], T = h[h.length - 1], c = Re(l) === "top", V = C.top, F = T.bottom, f = c ? C.left : T.left, I = c ? C.right : T.right;
          return { top: V, bottom: F, left: f, right: I, width: I - f, height: F - V, x: f, y: V };
        }
        const m = Re(l) === "left", A = Qt(...h.map((C) => C.right)), y = $t(...h.map((C) => C.left)), k = h.filter((C) => m ? C.left === y : C.right === A), w = k[0].top, _ = k[k.length - 1].bottom;
        return { top: w, bottom: _, left: y, right: A, width: A - y, height: _ - w, x: y, y: w };
      }
      return p;
    } }, floating: a.floating, strategy: s });
    return o.reference.x !== S.reference.x || o.reference.y !== S.reference.y || o.reference.width !== S.reference.width || o.reference.height !== S.reference.height ? { reset: { rects: S } } : {};
  } };
}, Fo = function(e) {
  return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) {
    const { x: l, y: a } = t, o = await async function(n, s) {
      const { placement: r, platform: i, elements: v } = n, b = await (i.isRTL == null ? void 0 : i.isRTL(v.floating)), h = Re(r), p = qe(r), B = Tt(r) === "x", S = ["left", "top"].includes(h) ? -1 : 1, m = b && B ? -1 : 1, A = it(s, n);
      let { mainAxis: y, crossAxis: k, alignmentAxis: w } = typeof A == "number" ? { mainAxis: A, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...A };
      return p && typeof w == "number" && (k = p === "end" ? -1 * w : w), B ? { x: k * m, y: y * S } : { x: y * S, y: k * m };
    }(t, e);
    return { x: l + o.x, y: a + o.y, data: o };
  } };
};
function Ns(e) {
  return e === "x" ? "y" : "x";
}
const Po = function(e) {
  return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) {
    const { x: l, y: a, placement: o } = t, { mainAxis: n = !0, crossAxis: s = !1, limiter: r = { fn: (A) => {
      let { x: y, y: k } = A;
      return { x: y, y: k };
    } }, ...i } = it(e, t), v = { x: l, y: a }, b = await xt(t, i), h = Tt(Re(o)), p = Ns(h);
    let B = v[h], S = v[p];
    if (n) {
      const A = h === "y" ? "bottom" : "right";
      B = Sa(B + b[h === "y" ? "top" : "left"], B, B - b[A]);
    }
    if (s) {
      const A = p === "y" ? "bottom" : "right";
      S = Sa(S + b[p === "y" ? "top" : "left"], S, S - b[A]);
    }
    const m = r.fn({ ...t, [h]: B, [p]: S });
    return { ...m, data: { x: m.x - l, y: m.y - a } };
  } };
};
function Pe(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function We(e) {
  return Pe(e).getComputedStyle(e);
}
function Eo(e) {
  return e instanceof Pe(e).Node;
}
function nt(e) {
  return Eo(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function Me(e) {
  return e instanceof HTMLElement || e instanceof Pe(e).HTMLElement;
}
function hl(e) {
  return typeof ShadowRoot < "u" && (e instanceof Pe(e).ShadowRoot || e instanceof ShadowRoot);
}
function Lt(e) {
  const { overflow: t, overflowX: l, overflowY: a, display: o } = We(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + a + l) && !["inline", "contents"].includes(o);
}
function zs(e) {
  return ["table", "td", "th"].includes(nt(e));
}
function wa(e) {
  const t = Ka(), l = We(e);
  return l.transform !== "none" || l.perspective !== "none" || !!l.containerType && l.containerType !== "normal" || !t && !!l.backdropFilter && l.backdropFilter !== "none" || !t && !!l.filter && l.filter !== "none" || ["transform", "perspective", "filter"].some((a) => (l.willChange || "").includes(a)) || ["paint", "layout", "strict", "content"].some((a) => (l.contain || "").includes(a));
}
function Ka() {
  return !(typeof CSS > "u" || !CSS.supports) && CSS.supports("-webkit-backdrop-filter", "none");
}
function fa(e) {
  return ["html", "body", "#document"].includes(nt(e));
}
const _a = Math.min, ht = Math.max, ta = Math.round, qt = Math.floor, st = (e) => ({ x: e, y: e });
function Io(e) {
  const t = We(e);
  let l = parseFloat(t.width) || 0, a = parseFloat(t.height) || 0;
  const o = Me(e), n = o ? e.offsetWidth : l, s = o ? e.offsetHeight : a, r = ta(l) !== n || ta(a) !== s;
  return r && (l = n, a = s), { width: l, height: a, $: r };
}
function Ye(e) {
  return e instanceof Element || e instanceof Pe(e).Element;
}
function Ya(e) {
  return Ye(e) ? e : e.contextElement;
}
function Bt(e) {
  const t = Ya(e);
  if (!Me(t))
    return st(1);
  const l = t.getBoundingClientRect(), { width: a, height: o, $: n } = Io(t);
  let s = (n ? ta(l.width) : l.width) / a, r = (n ? ta(l.height) : l.height) / o;
  return s && Number.isFinite(s) || (s = 1), r && Number.isFinite(r) || (r = 1), { x: s, y: r };
}
const Hs = st(0);
function xo(e) {
  const t = Pe(e);
  return Ka() && t.visualViewport ? { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } : Hs;
}
function dt(e, t, l, a) {
  t === void 0 && (t = !1), l === void 0 && (l = !1);
  const o = e.getBoundingClientRect(), n = Ya(e);
  let s = st(1);
  t && (a ? Ye(a) && (s = Bt(a)) : s = Bt(e));
  const r = function(p, B, S) {
    return B === void 0 && (B = !1), !(!S || B && S !== Pe(p)) && B;
  }(n, l, a) ? xo(n) : st(0);
  let i = (o.left + r.x) / s.x, v = (o.top + r.y) / s.y, b = o.width / s.x, h = o.height / s.y;
  if (n) {
    const p = Pe(n), B = a && Ye(a) ? Pe(a) : a;
    let S = p.frameElement;
    for (; S && a && B !== p; ) {
      const m = Bt(S), A = S.getBoundingClientRect(), y = getComputedStyle(S), k = A.left + (S.clientLeft + parseFloat(y.paddingLeft)) * m.x, w = A.top + (S.clientTop + parseFloat(y.paddingTop)) * m.y;
      i *= m.x, v *= m.y, b *= m.x, h *= m.y, i += k, v += w, S = Pe(S).frameElement;
    }
  }
  return _t({ width: b, height: h, x: i, y: v });
}
function va(e) {
  return Ye(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
}
function Je(e) {
  var t;
  return (t = (Eo(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Lo(e) {
  return dt(Je(e)).left + va(e).scrollLeft;
}
function Ct(e) {
  if (nt(e) === "html")
    return e;
  const t = e.assignedSlot || e.parentNode || hl(e) && e.host || Je(e);
  return hl(t) ? t.host : t;
}
function No(e) {
  const t = Ct(e);
  return fa(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Me(t) && Lt(t) ? t : No(t);
}
function aa(e, t) {
  var l;
  t === void 0 && (t = []);
  const a = No(e), o = a === ((l = e.ownerDocument) == null ? void 0 : l.body), n = Pe(a);
  return o ? t.concat(n, n.visualViewport || [], Lt(a) ? a : []) : t.concat(a, aa(a));
}
function Bl(e, t, l) {
  let a;
  if (t === "viewport")
    a = function(o, n) {
      const s = Pe(o), r = Je(o), i = s.visualViewport;
      let v = r.clientWidth, b = r.clientHeight, h = 0, p = 0;
      if (i) {
        v = i.width, b = i.height;
        const B = Ka();
        (!B || B && n === "fixed") && (h = i.offsetLeft, p = i.offsetTop);
      }
      return { width: v, height: b, x: h, y: p };
    }(e, l);
  else if (t === "document")
    a = function(o) {
      const n = Je(o), s = va(o), r = o.ownerDocument.body, i = ht(n.scrollWidth, n.clientWidth, r.scrollWidth, r.clientWidth), v = ht(n.scrollHeight, n.clientHeight, r.scrollHeight, r.clientHeight);
      let b = -s.scrollLeft + Lo(o);
      const h = -s.scrollTop;
      return We(r).direction === "rtl" && (b += ht(n.clientWidth, r.clientWidth) - i), { width: i, height: v, x: b, y: h };
    }(Je(e));
  else if (Ye(t))
    a = function(o, n) {
      const s = dt(o, !0, n === "fixed"), r = s.top + o.clientTop, i = s.left + o.clientLeft, v = Me(o) ? Bt(o) : st(1);
      return { width: o.clientWidth * v.x, height: o.clientHeight * v.y, x: i * v.x, y: r * v.y };
    }(t, l);
  else {
    const o = xo(e);
    a = { ...t, x: t.x - o.x, y: t.y - o.y };
  }
  return _t(a);
}
function zo(e, t) {
  const l = Ct(e);
  return !(l === t || !Ye(l) || fa(l)) && (We(l).position === "fixed" || zo(l, t));
}
function Rs(e, t, l) {
  const a = Me(t), o = Je(t), n = l === "fixed", s = dt(e, !0, n, t);
  let r = { scrollLeft: 0, scrollTop: 0 };
  const i = st(0);
  if (a || !a && !n)
    if ((nt(t) !== "body" || Lt(o)) && (r = va(t)), Me(t)) {
      const v = dt(t, !0, n, t);
      i.x = v.x + t.clientLeft, i.y = v.y + t.clientTop;
    } else
      o && (i.x = Lo(o));
  return { x: s.left + r.scrollLeft - i.x, y: s.top + r.scrollTop - i.y, width: s.width, height: s.height };
}
function Sl(e, t) {
  return Me(e) && We(e).position !== "fixed" ? t ? t(e) : e.offsetParent : null;
}
function wl(e, t) {
  const l = Pe(e);
  if (!Me(e))
    return l;
  let a = Sl(e, t);
  for (; a && zs(a) && We(a).position === "static"; )
    a = Sl(a, t);
  return a && (nt(a) === "html" || nt(a) === "body" && We(a).position === "static" && !wa(a)) ? l : a || function(o) {
    let n = Ct(o);
    for (; Me(n) && !fa(n); ) {
      if (wa(n))
        return n;
      n = Ct(n);
    }
    return null;
  }(e) || l;
}
const Ms = { convertOffsetParentRelativeRectToViewportRelativeRect: function(e) {
  let { rect: t, offsetParent: l, strategy: a } = e;
  const o = Me(l), n = Je(l);
  if (l === n)
    return t;
  let s = { scrollLeft: 0, scrollTop: 0 }, r = st(1);
  const i = st(0);
  if ((o || !o && a !== "fixed") && ((nt(l) !== "body" || Lt(n)) && (s = va(l)), Me(l))) {
    const v = dt(l);
    r = Bt(l), i.x = v.x + l.clientLeft, i.y = v.y + l.clientTop;
  }
  return { width: t.width * r.x, height: t.height * r.y, x: t.x * r.x - s.scrollLeft * r.x + i.x, y: t.y * r.y - s.scrollTop * r.y + i.y };
}, getDocumentElement: Je, getClippingRect: function(e) {
  let { element: t, boundary: l, rootBoundary: a, strategy: o } = e;
  const n = [...l === "clippingAncestors" ? function(i, v) {
    const b = v.get(i);
    if (b)
      return b;
    let h = aa(i).filter((m) => Ye(m) && nt(m) !== "body"), p = null;
    const B = We(i).position === "fixed";
    let S = B ? Ct(i) : i;
    for (; Ye(S) && !fa(S); ) {
      const m = We(S), A = wa(S);
      A || m.position !== "fixed" || (p = null), (B ? !A && !p : !A && m.position === "static" && p && ["absolute", "fixed"].includes(p.position) || Lt(S) && !A && zo(i, S)) ? h = h.filter((y) => y !== S) : p = m, S = Ct(S);
    }
    return v.set(i, h), h;
  }(t, this._c) : [].concat(l), a], s = n[0], r = n.reduce((i, v) => {
    const b = Bl(t, v, o);
    return i.top = ht(b.top, i.top), i.right = _a(b.right, i.right), i.bottom = _a(b.bottom, i.bottom), i.left = ht(b.left, i.left), i;
  }, Bl(t, s, o));
  return { width: r.right - r.left, height: r.bottom - r.top, x: r.left, y: r.top };
}, getOffsetParent: wl, getElementRects: async function(e) {
  let { reference: t, floating: l, strategy: a } = e;
  const o = this.getOffsetParent || wl, n = this.getDimensions;
  return { reference: Rs(t, await o(l), a), floating: { x: 0, y: 0, ...await n(l) } };
}, getClientRects: function(e) {
  return Array.from(e.getClientRects());
}, getDimensions: function(e) {
  return Io(e);
}, getScale: Bt, isElement: Ye, isRTL: function(e) {
  return getComputedStyle(e).direction === "rtl";
} };
function Ho(e, t, l, a) {
  a === void 0 && (a = {});
  const { ancestorScroll: o = !0, ancestorResize: n = !0, elementResize: s = typeof ResizeObserver == "function", layoutShift: r = typeof IntersectionObserver == "function", animationFrame: i = !1 } = a, v = Ya(e), b = o || n ? [...v ? aa(v) : [], ...aa(t)] : [];
  b.forEach((A) => {
    o && A.addEventListener("scroll", l, { passive: !0 }), n && A.addEventListener("resize", l);
  });
  const h = v && r ? function(A, y) {
    let k, w = null;
    const _ = Je(A);
    function C() {
      clearTimeout(k), w && w.disconnect(), w = null;
    }
    return function T(c, V) {
      c === void 0 && (c = !1), V === void 0 && (V = 1), C();
      const { left: F, top: f, width: I, height: E } = A.getBoundingClientRect();
      if (c || y(), !I || !E)
        return;
      const z = { rootMargin: -qt(f) + "px " + -qt(_.clientWidth - (F + I)) + "px " + -qt(_.clientHeight - (f + E)) + "px " + -qt(F) + "px", threshold: ht(0, _a(1, V)) || 1 };
      let Z = !0;
      function te(G) {
        const W = G[0].intersectionRatio;
        if (W !== V) {
          if (!Z)
            return T();
          W ? T(!1, W) : k = setTimeout(() => {
            T(!1, 1e-7);
          }, 100);
        }
        Z = !1;
      }
      try {
        w = new IntersectionObserver(te, { ...z, root: _.ownerDocument });
      } catch {
        w = new IntersectionObserver(te, z);
      }
      w.observe(A);
    }(!0), C;
  }(v, l) : null;
  let p, B = -1, S = null;
  s && (S = new ResizeObserver((A) => {
    let [y] = A;
    y && y.target === v && S && (S.unobserve(t), cancelAnimationFrame(B), B = requestAnimationFrame(() => {
      S && S.observe(t);
    })), l();
  }), v && !i && S.observe(v), S.observe(t));
  let m = i ? dt(e) : null;
  return i && function A() {
    const y = dt(e);
    !m || y.x === m.x && y.y === m.y && y.width === m.width && y.height === m.height || l(), m = y, p = requestAnimationFrame(A);
  }(), l(), () => {
    b.forEach((A) => {
      o && A.removeEventListener("scroll", l), n && A.removeEventListener("resize", l);
    }), h && h(), S && S.disconnect(), S = null, i && cancelAnimationFrame(p);
  };
}
const Ds = (e, t, l) => {
  const a = /* @__PURE__ */ new Map(), o = { platform: Ms, ...l }, n = { ...o.platform, _c: a };
  return Os(e, t, { ...o, platform: n });
};
function $a(e) {
  var t;
  return (t = e == null ? void 0 : e.$el) != null ? t : e;
}
function js(e) {
  return {
    name: "arrow",
    options: e,
    fn(t) {
      const l = $a($(e.element));
      return l == null ? {} : Fs({
        element: l,
        padding: e.padding
      }).fn(t);
    }
  };
}
function Ro(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _l(e, t) {
  const l = Ro(e);
  return Math.round(t * l) / l;
}
function Mo(e, t, l) {
  l === void 0 && (l = {});
  const a = l.whileElementsMounted, o = u(() => {
    var c;
    return (c = $(l.open)) != null ? c : !0;
  }), n = u(() => $(l.middleware)), s = u(() => {
    var c;
    return (c = $(l.placement)) != null ? c : "bottom";
  }), r = u(() => {
    var c;
    return (c = $(l.strategy)) != null ? c : "absolute";
  }), i = u(() => {
    var c;
    return (c = $(l.transform)) != null ? c : !0;
  }), v = u(() => $a(e.value)), b = u(() => $a(t.value)), h = R(0), p = R(0), B = R(r.value), S = R(s.value), m = xa({}), A = R(!1), y = u(() => {
    const c = {
      position: B.value,
      left: "0",
      top: "0"
    };
    if (!b.value)
      return c;
    const V = _l(b.value, h.value), F = _l(b.value, p.value);
    return i.value ? {
      ...c,
      transform: "translate(" + V + "px, " + F + "px)",
      ...Ro(b.value) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: B.value,
      left: V + "px",
      top: F + "px"
    };
  });
  let k;
  function w() {
    v.value == null || b.value == null || Ds(v.value, b.value, {
      middleware: n.value,
      placement: s.value,
      strategy: r.value
    }).then((c) => {
      h.value = c.x, p.value = c.y, B.value = c.strategy, S.value = c.placement, m.value = c.middlewareData, A.value = !0;
    });
  }
  function _() {
    typeof k == "function" && (k(), k = void 0);
  }
  function C() {
    if (_(), a === void 0) {
      w();
      return;
    }
    if (v.value != null && b.value != null) {
      k = a(v.value, b.value, w);
      return;
    }
  }
  function T() {
    o.value || (A.value = !1);
  }
  return oe([n, s, r], w, {
    flush: "sync"
  }), oe([v, b], C, {
    flush: "sync"
  }), oe(o, T, {
    flush: "sync"
  }), oo() && no(_), {
    x: vt(h),
    y: vt(p),
    strategy: vt(B),
    placement: vt(S),
    middlewareData: vt(m),
    isPositioned: vt(A),
    floatingStyles: y,
    update: w
  };
}
const qs = /* @__PURE__ */ new Set([
  "background",
  "cite",
  "href",
  "itemtype",
  "longdesc",
  "poster",
  "src",
  "xlink:href"
]), Gs = /^aria-[\w-]*$/i, Ws = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, Us = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, Xs = (e, t) => {
  const l = e.nodeName.toLowerCase();
  return t.includes(l) ? qs.has(l) ? !!(Ws.test(e.nodeValue || "") || Us.test(e.nodeValue || "")) : !0 : t.filter((a) => a instanceof RegExp).some((a) => a.test(l));
}, gt = {
  // Global attributes allowed on any supplied element below.
  "*": ["class", "dir", "id", "lang", "role", Gs],
  a: ["target", "href", "title", "rel"],
  area: [],
  b: [],
  br: [],
  col: [],
  code: [],
  div: [],
  em: [],
  hr: [],
  h1: [],
  h2: [],
  h3: [],
  h4: [],
  h5: [],
  h6: [],
  i: [],
  img: ["src", "srcset", "alt", "title", "width", "height"],
  li: [],
  ol: [],
  p: [],
  pre: [],
  s: [],
  small: [],
  span: [],
  sub: [],
  sup: [],
  strong: [],
  u: [],
  ul: []
}, yt = (e, t, l) => {
  if (!e.length)
    return e;
  if (l && typeof l == "function")
    return l(e);
  const o = new window.DOMParser().parseFromString(e, "text/html"), n = o.body.querySelectorAll("*");
  for (const s of n) {
    const r = s.nodeName.toLowerCase();
    if (!Object.keys(t).includes(r)) {
      s.remove();
      continue;
    }
    const i = s.attributes, v = [...t["*"] || [], ...t[r] || []];
    for (const b of i)
      Xs(b, v) || s.removeAttribute(b.nodeName);
  }
  return o.body.innerHTML;
};
var Ks = Object.defineProperty, Ys = Object.defineProperties, Js = Object.getOwnPropertyDescriptors, $l = Object.getOwnPropertySymbols, Zs = Object.prototype.hasOwnProperty, Qs = Object.prototype.propertyIsEnumerable, Cl = (e, t, l) => t in e ? Ks(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l, er = (e, t) => {
  for (var l in t || (t = {}))
    Zs.call(t, l) && Cl(e, l, t[l]);
  if ($l)
    for (var l of $l(t))
      Qs.call(t, l) && Cl(e, l, t[l]);
  return e;
}, tr = (e, t) => Ys(e, Js(t));
function Do(e, t) {
  var l;
  const a = xa();
  return Ht(() => {
    a.value = e();
  }, tr(er({}, t), {
    flush: (l = t == null ? void 0 : t.flush) != null ? l : "sync"
  })), ye(a);
}
function ct(e) {
  return oo() ? (no(e), !0) : !1;
}
function ar(e) {
  let t = !1, l;
  const a = so(!0);
  return (...o) => (t || (l = a.run(() => e(...o)), t = !0), l);
}
function lr(e) {
  let t = 0, l, a;
  const o = () => {
    t -= 1, a && t <= 0 && (a.stop(), l = void 0, a = void 0);
  };
  return (...n) => (t += 1, l || (a = so(!0), l = a.run(() => e(...n))), ct(o), l);
}
function ft(e) {
  return typeof e == "function" ? e() : $(e);
}
const la = typeof window < "u", or = (e) => typeof e < "u", Nt = () => {
}, Ca = /* @__PURE__ */ nr();
function nr() {
  var e;
  return la && ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.userAgent) && /* @__PURE__ */ /iP(ad|hone|od)/.test(window.navigator.userAgent);
}
function sr(e, t) {
  function l(...a) {
    return new Promise((o, n) => {
      Promise.resolve(e(() => t.apply(this, a), { fn: t, thisArg: this, args: a })).then(o).catch(n);
    });
  }
  return l;
}
const jo = (e) => e();
function rr(e = jo) {
  const t = R(!0);
  function l() {
    t.value = !1;
  }
  function a() {
    t.value = !0;
  }
  const o = (...n) => {
    t.value && e(...n);
  };
  return { isActive: ye(t), pause: l, resume: a, eventFilter: o };
}
function Ja(...e) {
  if (e.length !== 1)
    return ke(...e);
  const t = e[0];
  return typeof t == "function" ? ye(Rn(() => ({ get: t, set: Nt }))) : R(t);
}
function ir(e, t = !0) {
  ia() ? He(e) : t ? e() : Ce(e);
}
function ur(e = 0, t = {}) {
  const l = R(e), {
    max: a = 1 / 0,
    min: o = -1 / 0
  } = t, n = (b = 1) => l.value = Math.min(a, l.value + b), s = (b = 1) => l.value = Math.max(o, l.value - b), r = () => l.value, i = (b) => l.value = Math.max(o, Math.min(a, b));
  return { count: l, inc: n, dec: s, get: r, set: i, reset: (b = e) => (e = b, i(b)) };
}
function qo(e, t = 1e3, l = {}) {
  const {
    immediate: a = !0,
    immediateCallback: o = !1
  } = l;
  let n = null;
  const s = R(!1);
  function r() {
    n && (clearInterval(n), n = null);
  }
  function i() {
    s.value = !1, r();
  }
  function v() {
    const b = ft(t);
    b <= 0 || (s.value = !0, o && e(), r(), n = setInterval(e, b));
  }
  if (a && la && v(), La(t) || typeof t == "function") {
    const b = oe(t, () => {
      s.value && la && v();
    });
    ct(b);
  }
  return ct(i), {
    isActive: s,
    pause: i,
    resume: v
  };
}
function bt(e, t = {}) {
  const {
    method: l = "parseFloat",
    radix: a,
    nanToZero: o
  } = t;
  return u(() => {
    let n = ft(e);
    return typeof n == "string" && (n = Number[l](n, a)), o && Number.isNaN(n) && (n = 0), n;
  });
}
var kl = Object.getOwnPropertySymbols, dr = Object.prototype.hasOwnProperty, cr = Object.prototype.propertyIsEnumerable, fr = (e, t) => {
  var l = {};
  for (var a in e)
    dr.call(e, a) && t.indexOf(a) < 0 && (l[a] = e[a]);
  if (e != null && kl)
    for (var a of kl(e))
      t.indexOf(a) < 0 && cr.call(e, a) && (l[a] = e[a]);
  return l;
};
function vr(e, t, l = {}) {
  const a = l, {
    eventFilter: o = jo
  } = a, n = fr(a, [
    "eventFilter"
  ]);
  return oe(
    e,
    sr(
      o,
      t
    ),
    n
  );
}
var pr = Object.defineProperty, mr = Object.defineProperties, gr = Object.getOwnPropertyDescriptors, oa = Object.getOwnPropertySymbols, Go = Object.prototype.hasOwnProperty, Wo = Object.prototype.propertyIsEnumerable, Tl = (e, t, l) => t in e ? pr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l, yr = (e, t) => {
  for (var l in t || (t = {}))
    Go.call(t, l) && Tl(e, l, t[l]);
  if (oa)
    for (var l of oa(t))
      Wo.call(t, l) && Tl(e, l, t[l]);
  return e;
}, br = (e, t) => mr(e, gr(t)), hr = (e, t) => {
  var l = {};
  for (var a in e)
    Go.call(e, a) && t.indexOf(a) < 0 && (l[a] = e[a]);
  if (e != null && oa)
    for (var a of oa(e))
      t.indexOf(a) < 0 && Wo.call(e, a) && (l[a] = e[a]);
  return l;
};
function Br(e, t, l = {}) {
  const a = l, {
    eventFilter: o
  } = a, n = hr(a, [
    "eventFilter"
  ]), { eventFilter: s, pause: r, resume: i, isActive: v } = rr(o);
  return { stop: vr(
    e,
    t,
    br(yr({}, n), {
      eventFilter: s
    })
  ), pause: r, resume: i, isActive: v };
}
function Ke(e) {
  var t;
  const l = ft(e);
  return (t = l == null ? void 0 : l.$el) != null ? t : l;
}
const Ze = la ? window : void 0;
function we(...e) {
  let t, l, a, o;
  if (typeof e[0] == "string" || Array.isArray(e[0]) ? ([l, a, o] = e, t = Ze) : [t, l, a, o] = e, !t)
    return Nt;
  Array.isArray(l) || (l = [l]), Array.isArray(a) || (a = [a]);
  const n = [], s = () => {
    n.forEach((b) => b()), n.length = 0;
  }, r = (b, h, p, B) => (b.addEventListener(h, p, B), () => b.removeEventListener(h, p, B)), i = oe(
    () => [Ke(t), ft(o)],
    ([b, h]) => {
      s(), b && n.push(
        ...l.flatMap((p) => a.map((B) => r(b, p, B, h)))
      );
    },
    { immediate: !0, flush: "post" }
  ), v = () => {
    i(), s();
  };
  return ct(v), v;
}
let Vl = !1;
function Uo(e, t, l = {}) {
  const { window: a = Ze, ignore: o = [], capture: n = !0, detectIframe: s = !1 } = l;
  if (!a)
    return;
  Ca && !Vl && (Vl = !0, Array.from(a.document.body.children).forEach((p) => p.addEventListener("click", Nt)));
  let r = !0;
  const i = (p) => o.some((B) => {
    if (typeof B == "string")
      return Array.from(a.document.querySelectorAll(B)).some((S) => S === p.target || p.composedPath().includes(S));
    {
      const S = Ke(B);
      return S && (p.target === S || p.composedPath().includes(S));
    }
  }), b = [
    we(a, "click", (p) => {
      const B = Ke(e);
      if (!(!B || B === p.target || p.composedPath().includes(B))) {
        if (p.detail === 0 && (r = !i(p)), !r) {
          r = !0;
          return;
        }
        t(p);
      }
    }, { passive: !0, capture: n }),
    we(a, "pointerdown", (p) => {
      const B = Ke(e);
      B && (r = !p.composedPath().includes(B) && !i(p));
    }, { passive: !0 }),
    s && we(a, "blur", (p) => {
      setTimeout(() => {
        var B;
        const S = Ke(e);
        ((B = a.document.activeElement) == null ? void 0 : B.tagName) === "IFRAME" && !(S != null && S.contains(a.document.activeElement)) && t(p);
      }, 0);
    })
  ].filter(Boolean);
  return () => b.forEach((p) => p());
}
function Sr() {
  const e = R(!1);
  return ia() && He(() => {
    e.value = !0;
  }), e;
}
function wr(e) {
  const t = Sr();
  return u(() => (t.value, !!e()));
}
function _r(e, t = {}) {
  const { window: l = Ze } = t, a = wr(() => l && "matchMedia" in l && typeof l.matchMedia == "function");
  let o;
  const n = R(!1), s = () => {
    o && ("removeEventListener" in o ? o.removeEventListener("change", r) : o.removeListener(r));
  }, r = () => {
    a.value && (s(), o = l.matchMedia(Ja(e).value), n.value = !!(o != null && o.matches), o && ("addEventListener" in o ? o.addEventListener("change", r) : o.addListener(r)));
  };
  return Ht(r), ct(() => s()), n;
}
function $r(e) {
  return JSON.parse(JSON.stringify(e));
}
const Gt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Wt = "__vueuse_ssr_handlers__", Cr = /* @__PURE__ */ kr();
function kr() {
  return Wt in Gt || (Gt[Wt] = Gt[Wt] || {}), Gt[Wt];
}
function Za(e, t) {
  return Cr[e] || t;
}
function Tr(e) {
  return e == null ? "any" : e instanceof Set ? "set" : e instanceof Map ? "map" : e instanceof Date ? "date" : typeof e == "boolean" ? "boolean" : typeof e == "string" ? "string" : typeof e == "object" ? "object" : Number.isNaN(e) ? "any" : "number";
}
var Vr = Object.defineProperty, Al = Object.getOwnPropertySymbols, Ar = Object.prototype.hasOwnProperty, Or = Object.prototype.propertyIsEnumerable, Ol = (e, t, l) => t in e ? Vr(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l, Fl = (e, t) => {
  for (var l in t || (t = {}))
    Ar.call(t, l) && Ol(e, l, t[l]);
  if (Al)
    for (var l of Al(t))
      Or.call(t, l) && Ol(e, l, t[l]);
  return e;
};
const Fr = {
  boolean: {
    read: (e) => e === "true",
    write: (e) => String(e)
  },
  object: {
    read: (e) => JSON.parse(e),
    write: (e) => JSON.stringify(e)
  },
  number: {
    read: (e) => Number.parseFloat(e),
    write: (e) => String(e)
  },
  any: {
    read: (e) => e,
    write: (e) => String(e)
  },
  string: {
    read: (e) => e,
    write: (e) => String(e)
  },
  map: {
    read: (e) => new Map(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e.entries()))
  },
  set: {
    read: (e) => new Set(JSON.parse(e)),
    write: (e) => JSON.stringify(Array.from(e))
  },
  date: {
    read: (e) => new Date(e),
    write: (e) => e.toISOString()
  }
}, Pl = "vueuse-storage";
function Pr(e, t, l, a = {}) {
  var o;
  const {
    flush: n = "pre",
    deep: s = !0,
    listenToStorageChanges: r = !0,
    writeDefaults: i = !0,
    mergeDefaults: v = !1,
    shallow: b,
    window: h = Ze,
    eventFilter: p,
    onError: B = (V) => {
      console.error(V);
    }
  } = a, S = (b ? xa : R)(t);
  if (!l)
    try {
      l = Za("getDefaultStorage", () => {
        var V;
        return (V = Ze) == null ? void 0 : V.localStorage;
      })();
    } catch (V) {
      B(V);
    }
  if (!l)
    return S;
  const m = ft(t), A = Tr(m), y = (o = a.serializer) != null ? o : Fr[A], { pause: k, resume: w } = Br(
    S,
    () => _(S.value),
    { flush: n, deep: s, eventFilter: p }
  );
  return h && r && (we(h, "storage", c), we(h, Pl, T)), c(), S;
  function _(V) {
    try {
      if (V == null)
        l.removeItem(e);
      else {
        const F = y.write(V), f = l.getItem(e);
        f !== F && (l.setItem(e, F), h && h.dispatchEvent(new CustomEvent(Pl, {
          detail: {
            key: e,
            oldValue: f,
            newValue: F,
            storageArea: l
          }
        })));
      }
    } catch (F) {
      B(F);
    }
  }
  function C(V) {
    const F = V ? V.newValue : l.getItem(e);
    if (F == null)
      return i && m !== null && l.setItem(e, y.write(m)), m;
    if (!V && v) {
      const f = y.read(F);
      return typeof v == "function" ? v(f, m) : A === "object" && !Array.isArray(f) ? Fl(Fl({}, m), f) : f;
    } else
      return typeof F != "string" ? F : y.read(F);
  }
  function T(V) {
    c(V.detail);
  }
  function c(V) {
    if (!(V && V.storageArea !== l)) {
      if (V && V.key == null) {
        S.value = m;
        return;
      }
      if (!(V && V.key !== e)) {
        k();
        try {
          S.value = C(V);
        } catch (F) {
          B(F);
        } finally {
          V ? Ce(w) : w();
        }
      }
    }
  }
}
function Er(e) {
  return _r("(prefers-color-scheme: dark)", e);
}
var Ir = Object.defineProperty, El = Object.getOwnPropertySymbols, xr = Object.prototype.hasOwnProperty, Lr = Object.prototype.propertyIsEnumerable, Il = (e, t, l) => t in e ? Ir(e, t, { enumerable: !0, configurable: !0, writable: !0, value: l }) : e[t] = l, Nr = (e, t) => {
  for (var l in t || (t = {}))
    xr.call(t, l) && Il(e, l, t[l]);
  if (El)
    for (var l of El(t))
      Lr.call(t, l) && Il(e, l, t[l]);
  return e;
};
function zr(e = {}) {
  const {
    selector: t = "html",
    attribute: l = "class",
    initialValue: a = "auto",
    window: o = Ze,
    storage: n,
    storageKey: s = "vueuse-color-scheme",
    listenToStorageChanges: r = !0,
    storageRef: i,
    emitAuto: v,
    disableTransition: b = !0
  } = e, h = Nr({
    auto: "",
    light: "light",
    dark: "dark"
  }, e.modes || {}), p = Er({ window: o }), B = u(() => p.value ? "dark" : "light"), S = i || (s == null ? Ja(a) : Pr(s, a, n, { window: o, listenToStorageChanges: r })), m = u(
    () => S.value === "auto" ? B.value : S.value
  ), A = Za(
    "updateHTMLAttrs",
    (_, C, T) => {
      const c = typeof _ == "string" ? o == null ? void 0 : o.document.querySelector(_) : Ke(_);
      if (!c)
        return;
      let V;
      if (b) {
        V = o.document.createElement("style");
        const F = "*,*::before,*::after{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
        V.appendChild(document.createTextNode(F)), o.document.head.appendChild(V);
      }
      if (C === "class") {
        const F = T.split(/\s/g);
        Object.values(h).flatMap((f) => (f || "").split(/\s/g)).filter(Boolean).forEach((f) => {
          F.includes(f) ? c.classList.add(f) : c.classList.remove(f);
        });
      } else
        c.setAttribute(C, T);
      b && (o.getComputedStyle(V).opacity, document.head.removeChild(V));
    }
  );
  function y(_) {
    var C;
    A(t, l, (C = h[_]) != null ? C : _);
  }
  function k(_) {
    e.onChanged ? e.onChanged(_, y) : y(_);
  }
  oe(m, k, { flush: "post", immediate: !0 }), ir(() => k(m.value));
  const w = u({
    get() {
      return v ? S.value : m.value;
    },
    set(_) {
      S.value = _;
    }
  });
  try {
    return Object.assign(w, { store: S, system: B, state: m });
  } catch {
    return w;
  }
}
function Ee(e, t = {}) {
  const { initialValue: l = !1 } = t, a = R(!1), o = u(() => Ke(e));
  we(o, "focus", () => a.value = !0), we(o, "blur", () => a.value = !1);
  const n = u({
    get: () => a.value,
    set(s) {
      var r, i;
      !s && a.value ? (r = o.value) == null || r.blur() : s && !a.value && ((i = o.value) == null || i.focus());
    }
  });
  return oe(
    o,
    () => {
      n.value = l;
    },
    { immediate: !0, flush: "post" }
  ), { focused: n };
}
const Hr = {
  page: (e) => [e.pageX, e.pageY],
  client: (e) => [e.clientX, e.clientY],
  screen: (e) => [e.screenX, e.screenY],
  movement: (e) => e instanceof Touch ? null : [e.movementX, e.movementY]
};
function Rr(e = {}) {
  const {
    type: t = "page",
    touch: l = !0,
    resetOnTouchEnds: a = !1,
    initialValue: o = { x: 0, y: 0 },
    window: n = Ze,
    target: s = n,
    eventFilter: r
  } = e, i = R(o.x), v = R(o.y), b = R(null), h = typeof t == "function" ? t : Hr[t], p = (y) => {
    const k = h(y);
    k && ([i.value, v.value] = k, b.value = "mouse");
  }, B = (y) => {
    if (y.touches.length > 0) {
      const k = h(y.touches[0]);
      k && ([i.value, v.value] = k, b.value = "touch");
    }
  }, S = () => {
    i.value = o.x, v.value = o.y;
  }, m = r ? (y) => r(() => p(y), {}) : (y) => p(y), A = r ? (y) => r(() => B(y), {}) : (y) => B(y);
  return s && (we(s, "mousemove", m, { passive: !0 }), we(s, "dragover", m, { passive: !0 }), l && t !== "movement" && (we(s, "touchstart", A, { passive: !0 }), we(s, "touchmove", A, { passive: !0 }), a && we(s, "touchend", S, { passive: !0 }))), {
    x: i,
    y: v,
    sourceType: b
  };
}
function xl(e, t = {}) {
  const {
    handleOutside: l = !0,
    window: a = Ze
  } = t, { x: o, y: n, sourceType: s } = Rr(t), r = R(e ?? (a == null ? void 0 : a.document.body)), i = R(0), v = R(0), b = R(0), h = R(0), p = R(0), B = R(0), S = R(!0);
  let m = () => {
  };
  return a && (m = oe(
    [r, o, n],
    () => {
      const A = Ke(r);
      if (!A)
        return;
      const {
        left: y,
        top: k,
        width: w,
        height: _
      } = A.getBoundingClientRect();
      b.value = y + a.pageXOffset, h.value = k + a.pageYOffset, p.value = _, B.value = w;
      const C = o.value - b.value, T = n.value - h.value;
      S.value = w === 0 || _ === 0 || C < 0 || T < 0 || C > w || T > _, (l || !S.value) && (i.value = C, v.value = T);
    },
    { immediate: !0 }
  ), we(document, "mouseleave", () => {
    S.value = !0;
  })), {
    x: o,
    y: n,
    sourceType: s,
    elementX: i,
    elementY: v,
    elementPositionX: b,
    elementPositionY: h,
    elementHeight: p,
    elementWidth: B,
    isOutside: S,
    stop: m
  };
}
function Xo(e) {
  const t = window.getComputedStyle(e);
  if (t.overflowX === "scroll" || t.overflowY === "scroll" || t.overflowX === "auto" && e.clientWidth < e.scrollWidth || t.overflowY === "auto" && e.clientHeight < e.scrollHeight)
    return !0;
  {
    const l = e.parentNode;
    return !l || l.tagName === "BODY" ? !1 : Xo(l);
  }
}
function Mr(e) {
  const t = e || window.event, l = t.target;
  return Xo(l) ? !1 : t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(), !1);
}
function Dr(e, t = !1) {
  const l = R(t);
  let a = null, o;
  oe(Ja(e), (r) => {
    if (r) {
      const i = r;
      o = i.style.overflow, l.value && (i.style.overflow = "hidden");
    }
  }, {
    immediate: !0
  });
  const n = () => {
    const r = ft(e);
    !r || l.value || (Ca && (a = we(
      r,
      "touchmove",
      (i) => {
        Mr(i);
      },
      { passive: !1 }
    )), r.style.overflow = "hidden", l.value = !0);
  }, s = () => {
    const r = ft(e);
    !r || !l.value || (Ca && (a == null || a()), r.style.overflow = o, l.value = !1);
  };
  return ct(s), u({
    get() {
      return l.value;
    },
    set(r) {
      r ? n() : s();
    }
  });
}
function jr(e, t = {}) {
  const {
    threshold: l = 50,
    onSwipe: a,
    onSwipeEnd: o,
    onSwipeStart: n,
    passive: s = !0,
    window: r = Ze
  } = t, i = St({ x: 0, y: 0 }), v = St({ x: 0, y: 0 }), b = u(() => i.x - v.x), h = u(() => i.y - v.y), { max: p, abs: B } = Math, S = u(() => p(B(b.value), B(h.value)) >= l), m = R(!1), A = u(() => S.value ? B(b.value) > B(h.value) ? b.value > 0 ? "left" : "right" : h.value > 0 ? "up" : "down" : "none"), y = (F) => [F.touches[0].clientX, F.touches[0].clientY], k = (F, f) => {
    i.x = F, i.y = f;
  }, w = (F, f) => {
    v.x = F, v.y = f;
  };
  let _;
  const C = qr(r == null ? void 0 : r.document);
  s ? _ = C ? { passive: !0 } : { capture: !1 } : _ = C ? { passive: !1, capture: !0 } : { capture: !0 };
  const T = (F) => {
    m.value && (o == null || o(F, A.value)), m.value = !1;
  }, c = [
    we(e, "touchstart", (F) => {
      if (F.touches.length !== 1)
        return;
      _.capture && !_.passive && F.preventDefault();
      const [f, I] = y(F);
      k(f, I), w(f, I), n == null || n(F);
    }, _),
    we(e, "touchmove", (F) => {
      if (F.touches.length !== 1)
        return;
      const [f, I] = y(F);
      w(f, I), !m.value && S.value && (m.value = !0), m.value && (a == null || a(F));
    }, _),
    we(e, "touchend", T, _),
    we(e, "touchcancel", T, _)
  ];
  return {
    isPassiveEventSupported: C,
    isSwiping: m,
    direction: A,
    coordsStart: i,
    coordsEnd: v,
    lengthX: b,
    lengthY: h,
    stop: () => c.forEach((F) => F())
  };
}
function qr(e) {
  if (!e)
    return !1;
  let t = !1;
  const l = {
    get passive() {
      return t = !0, !1;
    }
  };
  return e.addEventListener("x", Nt, l), e.removeEventListener("x", Nt), t;
}
function Se(e, t, l, a = {}) {
  var o, n, s;
  const {
    clone: r = !1,
    passive: i = !1,
    eventName: v,
    deep: b = !1,
    defaultValue: h,
    shouldEmit: p
  } = a, B = ia(), S = l || (B == null ? void 0 : B.emit) || ((o = B == null ? void 0 : B.$emit) == null ? void 0 : o.bind(B)) || ((s = (n = B == null ? void 0 : B.proxy) == null ? void 0 : n.$emit) == null ? void 0 : s.bind(B == null ? void 0 : B.proxy));
  let m = v;
  t || (t = "modelValue"), m = m || `update:${t.toString()}`;
  const A = (w) => r ? typeof r == "function" ? r(w) : $r(w) : w, y = () => or(e[t]) ? A(e[t]) : h, k = (w) => {
    p ? p(w) && S(m, w) : S(m, w);
  };
  if (i) {
    const w = y(), _ = R(w);
    return oe(
      () => e[t],
      (C) => _.value = A(C)
    ), oe(
      _,
      (C) => {
        (C !== e[t] || b) && k(C);
      },
      { deep: b }
    ), _;
  } else
    return u({
      get() {
        return y();
      },
      set(w) {
        k(w);
      }
    });
}
const Qa = N({
  name: "ComponentOrEmpty",
  slots: Object,
  props: {
    tag: {
      type: String,
      default: "div"
    },
    to: {
      type: [String, Object],
      default: null
    },
    skip: {
      type: Boolean,
      default: !1
    }
  },
  setup(e, { slots: t, attrs: l }) {
    return () => {
      var a, o, n;
      return e.skip ? (a = t.default) == null ? void 0 : a.call(t) : e.tag === "Teleport" ? ie(Na, { to: e.to }, [(o = t.default) == null ? void 0 : o.call(t)]) : ie(e.tag, { ...l }, [(n = t.default) == null ? void 0 : n.call(t)]);
    };
  }
}), Dt = (e) => Do(() => {
  const t = Qe(e);
  return t ? `justify-content-${t}` : "";
});
function d(e) {
  return Do(() => {
    const t = Qe(e);
    return t == null ? t : Ra(t);
  });
}
const Ko = ar(() => {
  const e = St([]);
  return { items: e, reset: () => {
    e.splice(0, e.length);
  } };
}), Gr = (e = {}) => {
  const t = e.persist ?? !1, l = "data-bs-theme", a = "body";
  return zr({
    attribute: l,
    selector: a,
    storageKey: t === !0 ? `bv-color-${e.attribute ?? l}-${e.selector ?? a}` : null,
    ...e
  });
}, Wr = (e, t = R(1e3), l = {}) => {
  const a = ye(ke(e)), o = ye(ke(t)), n = R(!1), s = R(0), r = u(() => Math.ceil(a.value / o.value)), i = u(
    () => h.value || n.value ? Math.round(a.value - s.value * o.value) : 0
  ), { pause: v, resume: b, isActive: h } = qo(
    () => {
      s.value = s.value + 1;
    },
    t,
    l
  ), p = () => {
    n.value = !1, s.value = 0, b();
  }, B = () => {
    n.value = !1, s.value = r.value;
  };
  Ht(() => {
    s.value > r.value && (s.value = r.value), s.value === r.value && v();
  }), oe([o, a], () => {
    B(), p();
  });
  const S = () => {
    h.value !== !1 && (n.value = !0, v());
  }, m = () => {
    s.value !== r.value && (n.value = !1, b());
  };
  return {
    isActive: ye(h),
    isPaused: ye(n),
    restart: p,
    stop: B,
    pause: S,
    resume: m,
    value: i
  };
}, Yo = (e) => u(() => {
  const t = Qe(e);
  return {
    "form-check": t.plain === !1 && t.button === !1,
    "form-check-inline": t.inline === !0,
    "form-switch": t.switch === !0,
    [`form-control-${t.size}`]: t.size !== void 0 && t.size !== "md" && t.button === !1
  };
}), Jo = (e) => u(() => {
  const t = Qe(e);
  return {
    "form-check-input": t.plain === !1 && t.button === !1,
    "is-valid": t.state === !0,
    "is-invalid": t.state === !1,
    "btn-check": t.button === !0
  };
}), Zo = (e) => u(() => {
  const t = Qe(e);
  return {
    "form-check-label": t.plain === !1 && t.button === !1,
    btn: t.button === !0,
    [`btn-${t.buttonVariant}`]: t.button === !0 && t.buttonVariant !== void 0 && t.buttonVariant !== null,
    [`btn-${t.size}`]: t.button && t.size && t.size !== "md"
  };
}), Qo = (e) => u(() => {
  const t = Qe(e);
  return {
    "aria-invalid": ca(t.ariaInvalid, t.state),
    "aria-required": t.required === !0 ? !0 : void 0
  };
}), en = (e) => u(() => {
  const t = Qe(e);
  return {
    "was-validated": t.validated === !0,
    "btn-group": t.buttons === !0 && t.stacked === !1,
    "btn-group-vertical": t.stacked === !0 && t.buttons === !0,
    [`btn-group-${t.size}`]: t.size !== void 0
  };
}), tn = (e, t) => {
  const l = R(null);
  let a = null, o = !0;
  const n = _e(() => e.id, "input"), s = d(() => e.autofocus), r = d(() => e.disabled), i = d(() => e.lazy), v = d(() => e.lazyFormatter), b = d(() => e.number);
  d(() => e.plaintext), d(() => e.readonly), d(() => e.required);
  const h = d(() => e.state), p = d(() => e.trim), { focused: B } = Ee(l, {
    initialValue: s.value
  }), S = (c, V, F = !1) => (c = String(c), typeof e.formatter == "function" && (!v.value || F) ? (o = !1, e.formatter(c, V)) : c), m = (c) => p.value ? c.trim() : b.value ? Number.parseFloat(c) : c, A = () => {
    s.value && (B.value = !0);
  };
  He(() => {
    l.value && (l.value.value = e.modelValue);
  }), Mn(() => {
    Ce(() => {
      A();
    });
  });
  const y = u(
    () => ca(e.ariaInvalid, h.value)
  ), k = (c) => {
    const { value: V } = c.target, F = S(V, c);
    if (F === !1 || c.defaultPrevented) {
      c.preventDefault();
      return;
    }
    if (i.value)
      return;
    const f = m(F);
    e.modelValue !== f && (a = V, t("update:modelValue", f)), t("input", F);
  }, w = (c) => {
    const { value: V } = c.target, F = S(V, c);
    if (F === !1 || c.defaultPrevented) {
      c.preventDefault();
      return;
    }
    if (!i.value)
      return;
    a = V, t("update:modelValue", F);
    const f = m(F);
    e.modelValue !== f && t("change", F);
  }, _ = (c) => {
    if (t("blur", c), !i.value && !v.value)
      return;
    const { value: V } = c.target, F = S(V, c, !0);
    a = V, t("update:modelValue", F);
  }, C = () => {
    r.value || (B.value = !0);
  }, T = () => {
    var c;
    r.value || (c = l.value) == null || c.blur();
  };
  return oe(
    () => e.modelValue,
    (c) => {
      l.value && (l.value.value = a && o ? a : c, a = null, o = !0);
    }
  ), {
    input: l,
    computedId: n,
    computedAriaInvalid: y,
    onInput: k,
    onChange: w,
    onBlur: _,
    focus: C,
    blur: T
  };
}, mt = (e, t) => {
  if (!e)
    return e;
  if (t in e)
    return e[t];
  const l = t.split(".");
  return mt(e[l[0]], l.splice(1).join("."));
}, ga = (e, t = null, l, a) => {
  if (Object.prototype.toString.call(e) === "[object Object]") {
    const o = mt(e, a.valueField), n = mt(e, a.textField), s = mt(e, a.htmlField), r = mt(e, a.disabledField), i = e[a.optionsField] || null;
    return i !== null ? {
      label: String(mt(e, a.labelField) || n),
      options: el(i, l, a)
    } : {
      value: typeof o > "u" ? t || n : o,
      text: String(typeof n > "u" ? t : n),
      html: s,
      disabled: !!r
    };
  }
  return {
    value: t || e,
    text: String(e),
    disabled: !1
  };
}, el = (e, t, l) => Array.isArray(e) ? e.map((a) => ga(a, null, t, l)) : Object.prototype.toString.call(e) === "[object Object]" ? (console.warn(
  `[BootstrapVue warn]: ${t} - Setting prop "options" to an object is deprecated. Use the array format instead.`
), Object.keys(e).map((a) => {
  const o = e[a];
  switch (typeof o) {
    case "object":
      return ga(o.text, String(o.value), t, l);
    default:
      return ga(o, String(a), t, l);
  }
})) : [], _e = (e, t) => u(() => Qe(e) || at(t)), ya = "modal-open", Ur = lr(() => {
  const { count: e, inc: t, dec: l } = ur(), a = Za("updateHTMLAttrs", (o, n, s) => {
    const r = typeof o == "string" ? window == null ? void 0 : window.document.querySelector(o) : Ke(o);
    r && (n === "class" ? r.classList.toggle(ya, s === ya) : r.setAttribute(n, s));
  });
  return ct(() => {
    a("body", "class", "");
  }), oe(e, (o) => {
    a("body", "class", o > 0 ? ya : "");
  }), { inc: t, dec: l };
}), Xr = (e) => {
  const { inc: t, dec: l } = Ur();
  oe(
    e,
    (a, o) => {
      a ? t() : o && !a && l();
    },
    { immediate: !0 }
  );
}, an = (e, t) => {
  const l = ye(ke(e)), a = ye(ke(t)), o = u(() => !a.value), n = R(null);
  He(() => {
    n.value = document.body;
  });
  const s = Dr(n, l.value && o.value);
  oe([l, o], ([r, i]) => {
    s.value = r && i;
  });
}, Vt = (e) => u(() => {
  const t = Qe(e);
  return t === !0 ? "is-valid" : t === !1 ? "is-invalid" : null;
}), Kr = (e, t, l, a, o) => {
  if (e === void 0 || t === void 0 || l === void 0 || a === void 0)
    return t ?? [];
  const n = l;
  return t.sort((s, r) => {
    if (o !== void 0)
      return o(s, r, l, a);
    const i = (h) => typeof h == "object" ? JSON.stringify(h) : h;
    return i(s[n]) > i(r[n]) ? a ? -1 : 1 : i(r[n]) > i(s[n]) ? a ? 1 : -1 : 0;
  });
}, Yr = (e, t, l) => e.filter(
  (a) => Object.entries(a).filter((o) => {
    const [n, s] = o;
    return !s || n[0] === "_" || l && l.length > 0 && !l.includes(n) ? !1 : (typeof s == "object" ? JSON.stringify(Object.values(s)) : s.toString()).toLowerCase().includes(t.toLowerCase());
  }).length > 0
), Jr = (e, t, l, a) => {
  let o = e.value;
  return "isFilterableTable" in l && l.isFilterableTable.value === !0 && t.filter && (o = Yr(o, t.filter, t.filterable)), "isSortable" in l && l.isSortable.value === !0 && (o = Kr(
    t.fields,
    o,
    a == null ? void 0 : a.value,
    l.sortDescBoolean.value,
    t.sortCompare
  )), o;
}, Zr = (e, t, l, a) => {
  const o = R(), n = R(e.items ?? []), s = R([0, n.value.length]), r = u(() => {
    const h = l.value ? n.value : t.requireItemsMapping.value ? Jr(n, e, t, a) : e.items ?? [];
    if (l.value && !t.noProviderPagingBoolean.value)
      return h;
    if (e.perPage !== void 0) {
      const p = ((e.currentPage ?? 0) - 1) * e.perPage, B = p + e.perPage > h.length ? h.length : p + e.perPage;
      s.value = [p, B];
    }
    return h;
  }), i = u(() => e.perPage === void 0 ? r.value : r.value.slice(s.value[0], s.value[1]));
  return {
    internalItems: n,
    computedItems: r,
    updateInternalItems: async (h) => {
      try {
        return n.value = h, n.value;
      } catch {
        return;
      }
    },
    filteredHandler: o,
    notifyFilteredItems: () => {
      o.value && o.value(r.value);
    },
    computedDisplayItems: i
  };
}, Qr = ["id"], ei = ["innerHTML"], ti = ["innerHTML"], tl = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BPopover",
  props: {
    modelValue: { type: [String, Boolean], default: !1 },
    container: { default: void 0 },
    target: { type: [Function, String, null], default: null },
    reference: { type: [Function, String, null], default: null },
    content: { default: void 0 },
    id: { default: void 0 },
    title: { default: void 0 },
    delay: { default: () => ({ show: 100, hide: 300 }) },
    click: { type: [String, Boolean], default: !1 },
    manual: { type: [String, Boolean], default: !1 },
    variant: { default: null },
    offset: { default: null },
    customClass: { default: "" },
    placement: { default: "top" },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    noFlip: { type: [String, Boolean], default: !1 },
    noShift: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    noAutoClose: { type: [String, Boolean], default: !1 },
    hide: { type: [String, Boolean], default: !0 },
    realtime: { type: [String, Boolean], default: !1 },
    inline: { type: [String, Boolean], default: !1 },
    tooltip: { type: [String, Boolean], default: !1 },
    html: { type: [String, Boolean], default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = d(() => a.modelValue), n = R(o.value), s = R(o.value);
    Ht(() => {
      l("update:modelValue", n.value);
    }), oe(o, () => {
      o.value !== n.value && (o.value ? x() : D(new Event("update:modelValue")));
    });
    const r = _e(() => a.id, "popover"), i = d(() => a.click), v = d(() => a.manual), b = d(() => a.noShift), h = d(() => a.noFlip), p = d(() => a.noFade), B = d(() => a.noAutoClose), S = d(() => a.hide), m = d(() => a.realtime), A = d(() => a.inline), y = d(() => a.tooltip), k = d(() => a.html), w = R(!1), _ = R(null), C = R(null), T = R(null), c = R(null), V = R(null), F = (U) => {
      if (typeof U == "string" || U instanceof HTMLElement)
        return U;
      if (typeof U == "function")
        return U().$el ? U().$el : U();
      if (typeof U < "u")
        return U.$el;
    }, f = (U) => {
      if (U) {
        if (typeof U == "string") {
          const se = document.getElementById(U);
          return se || void 0;
        }
        return U;
      }
    }, I = u(
      () => a.title ? yt(a.title, gt) : ""
    ), E = u(
      () => a.content ? yt(a.content, gt) : ""
    ), z = u(() => a.placement.startsWith("auto")), Z = u(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const U = typeof a.offset == "number" ? a.offset : y.value ? 0 : 10, se = [Fo(U)];
      return h.value === !1 && !z.value && se.push(Oo()), z.value && se.push(
        Is({
          alignment: a.placement.split("-")[1] || void 0
        })
      ), b.value === !1 && se.push(Po()), S.value === !0 && se.push(xs({ padding: 10 })), A.value === !0 && se.push(Ls()), se.push(js({ element: T, padding: 10 })), se;
    }), te = u(
      () => z.value ? void 0 : a.placement
    ), { x: G, y: W, strategy: X, middlewareData: ve, placement: ge, update: pe } = Mo(C, _, {
      placement: te,
      middleware: Z,
      strategy: a.strategy,
      whileElementsMounted: (...U) => Ho(...U, { animationFrame: m.value })
    }), me = R({ position: "absolute" });
    oe(ve, () => {
      var U;
      if (S.value === !0 && ((U = ve.value.hide) != null && U.referenceHidden ? w.value = !0 : w.value = !1), ve.value.arrow) {
        const { x: se, y: Ie } = ve.value.arrow;
        me.value = {
          position: "absolute",
          top: Ie ? `${Ie}px` : "",
          left: se ? `${se}px` : ""
        };
      }
    });
    const q = u(() => {
      const U = y.value ? "tooltip" : "popover";
      return [
        U,
        `b-${U}`,
        {
          [`b-${U}-${a.variant}`]: a.variant !== null,
          show: n.value && !w.value,
          "pe-none": !n.value,
          fade: !p.value,
          "d-none": !n.value && p.value,
          [`${a.customClass}`]: a.customClass !== void 0,
          [`bs-${U}-${li(ge.value)}`]: ge.value !== void 0
        }
      ];
    }), { isOutside: Q } = xl(_), { isOutside: re } = xl(c), de = (U) => {
      const se = U ?? new Event("click");
      n.value ? D(se) : x();
    }, L = (U, se = {}) => new Rt(U, {
      cancelable: !1,
      target: _.value || null,
      relatedTarget: null,
      trigger: null,
      ...se,
      componentId: r.value
    }), x = () => {
      const U = L("show", { cancelable: !0 });
      if (l("show", U), U.defaultPrevented) {
        l("show-prevented");
        return;
      }
      s.value = !0, Ce(() => {
        var se;
        pe(), setTimeout(
          () => {
            pe(), n.value = !0, Ce(() => {
              l("shown", L("shown"));
            });
          },
          typeof a.delay == "number" ? a.delay : ((se = a.delay) == null ? void 0 : se.show) || 0
        );
      });
    }, D = (U) => {
      var et;
      const se = L("hide", { cancelable: !0 });
      if (l("hide", se), se.defaultPrevented) {
        l("hide-prevented");
        return;
      }
      const Ie = typeof a.delay == "number" ? a.delay : ((et = a.delay) == null ? void 0 : et.hide) || 100;
      setTimeout(() => {
        var tt;
        (U == null ? void 0 : U.type) === "click" || (U == null ? void 0 : U.type) === "update:modelValue" && v.value || Q.value && re.value && !((tt = _.value) != null && tt.contains(document == null ? void 0 : document.activeElement)) ? (n.value = !1, Ce(() => {
          setTimeout(
            () => {
              s.value = !1;
            },
            _.value ? ha(_.value) : 150
          ), l("hidden", L("hidden"));
        })) : setTimeout(() => {
          D(U);
        }, Ie);
      }, Ie);
    };
    t({
      hideFn: D,
      show: x,
      toggle: de
    });
    const ae = () => {
      var U;
      if (a.target) {
        const se = f(F(a.target));
        se ? c.value = se : console.warn("Target element not found", a.target);
      } else
        c.value = (U = V.value) == null ? void 0 : U.nextElementSibling;
      if (a.reference) {
        const se = f(F(a.reference));
        se ? C.value = se : console.warn("Reference element not found", a.reference);
      } else
        C.value = c.value;
      !c.value || v.value || ja && (i.value && c.value.addEventListener("click", de), !i.value && c.value.addEventListener("pointerenter", x), !i.value && c.value.addEventListener("pointerleave", D), !i.value && c.value.addEventListener("focus", x), !i.value && c.value.addEventListener("blur", D));
    }, ue = () => {
      c.value && (c.value.removeEventListener("click", de), c.value.removeEventListener("pointerenter", x), c.value.removeEventListener("pointerleave", D), c.value.removeEventListener("focus", x), c.value.removeEventListener("blur", D));
    };
    return Uo(
      _,
      () => {
        n.value && i.value && !B.value && !v.value && D(new Event("clickOutside"));
      },
      { ignore: [c] }
    ), oe([() => a.click, () => a.target, () => a.reference], () => {
      ue(), ae();
    }), He(ae), ro(ue), (U, se) => (g(), P(ce, null, [
      K("span", {
        ref_key: "placeholder",
        ref: V
      }, null, 512),
      O(U.$slots, "target", Be(Ve({ show: x, hide: D, toggle: de, showState: n.value }))),
      be(Qa, {
        tag: "Teleport",
        to: U.container,
        skip: !U.container
      }, {
        default: j(() => [
          s.value ? (g(), P("div", ee({
            key: 0,
            id: U.id
          }, U.$attrs, {
            ref_key: "element",
            ref: _,
            class: q.value,
            role: "tooltip",
            tabindex: "-1",
            style: {
              position: $(X),
              top: `${$(W)}px`,
              left: `${$(G)}px`,
              width: "max-content"
            }
          }), [
            K("div", {
              ref_key: "arrow",
              ref: T,
              class: H(`${$(y) ? "tooltip" : "popover"}-arrow`),
              style: ze(me.value),
              "data-popper-arrow": ""
            }, null, 6),
            U.title || U.$slots.title ? (g(), P(ce, { key: 0 }, [
              $(k) ? (g(), P("div", {
                key: 1,
                class: H($(y) ? "tooltip-inner" : "popover-header"),
                innerHTML: I.value
              }, null, 10, ei)) : (g(), P("div", {
                key: 0,
                class: H($(y) ? "tooltip-inner" : "popover-header")
              }, [
                O(U.$slots, "title", {}, () => [
                  ne(Y(U.title), 1)
                ])
              ], 2))
            ], 64)) : J("", !0),
            $(y) && !U.$slots.title && !U.title || !$(y) ? (g(), P(ce, { key: 1 }, [
              $(k) ? (g(), P("div", {
                key: 1,
                class: H($(y) ? "tooltip-inner" : "popover-body"),
                innerHTML: E.value
              }, null, 10, ti)) : (g(), P("div", {
                key: 0,
                class: H($(y) ? "tooltip-inner" : "popover-body")
              }, [
                O(U.$slots, "default", {}, () => [
                  ne(Y(U.content), 1)
                ])
              ], 2))
            ], 64)) : J("", !0)
          ], 16, Qr)) : J("", !0)
        ]),
        _: 3
      }, 8, ["to", "skip"])
    ], 64));
  }
}), ai = ({
  top: e,
  end: t,
  start: l,
  alignCenter: a,
  alignEnd: o
}) => {
  const n = e ? "top" : l ? "left" : t ? "right" : "bottom", s = o ? "end" : a ? null : "start";
  return `${n}${s ? `-${s}` : ""}`;
}, li = (e) => {
  const [t] = e.split("-");
  switch (t) {
    case "left":
      return "start";
    case "right":
      return "end";
    default:
      return t;
  }
}, zt = (e) => typeof e != "object" || e.active !== !1, na = (e, t) => {
  if (!zt(e))
    return {};
  const a = typeof e > "u" || typeof e == "object" && !e.title && !e.content, o = t.getAttribute("title") || t.getAttribute("data-original-title");
  return a ? o ? (t.removeAttribute("title"), t.setAttribute("data-original-title", o), {
    content: yt(o, gt)
  }) : (console.warn(
    "Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \"my title\"}'` nor `v-b-tooltip=\"'my title'\"` to define a title"
  ), {}) : typeof e == "string" ? {
    content: yt(e, gt)
  } : {
    title: e != null && e.title ? yt(e == null ? void 0 : e.title, gt) : void 0,
    content: e != null && e.content ? yt(e == null ? void 0 : e.content, gt) : void 0
  };
}, sa = (e, t) => ({
  target: () => t,
  modelValue: e.modifiers.show,
  inline: e.modifiers.inline,
  click: e.modifiers.click,
  realtime: e.modifiers.realtime,
  placement: e.modifiers.left ? "left" : e.modifiers.right ? "right" : e.modifiers.bottom ? "bottom" : e.modifiers.top ? "top" : void 0,
  html: !0,
  ...typeof e.value == "object" ? e.value : {},
  title: null,
  content: null
}), ln = (e, t) => {
  var a;
  const l = document.createElement("span");
  t.modifiers.body ? document.body.appendChild(l) : t.modifiers.child ? e.appendChild(l) : (a = e.parentNode) == null || a.insertBefore(l, e.nextSibling), e.$__app = Dn({ render: () => {
    var o;
    return ie(tl, { ...(o = e.$__state) == null ? void 0 : o.value });
  } }), e.$__app.mount(l), e.$__element = l;
}, on = (e) => {
  var l;
  const t = e.$__element;
  (l = e.$__app) == null || l.unmount(), delete e.$__app, delete e.$__state, setTimeout(() => {
    t == null || t.remove();
  }, 0), delete e.$__element;
}, Ll = (e, t) => {
  const { all: l, ...a } = e, o = {};
  l && t.forEach((s) => {
    o[s] = l;
  });
  const n = { ...o, ...a };
  return Object.entries(n).filter(([s, r]) => !!r && t.includes(s)).map(([s]) => s);
}, oi = ["id"], ni = /* @__PURE__ */ N({
  __name: "BAccordion",
  props: {
    flush: { type: [String, Boolean], default: !1 },
    free: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    modelValue: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { emit: t }) {
    const l = e, a = Se(l, "modelValue", t, { passive: !0 }), o = _e(() => l.id, "accordion"), n = d(() => l.flush), s = d(() => l.free), r = u(() => ({
      "accordion-flush": n.value
    }));
    return De($o, {
      openItem: ye(a),
      free: s,
      setOpenItem: (i) => {
        a.value = i;
      }
    }), (i, v) => (g(), P("div", {
      id: $(o),
      class: H(["accordion", r.value])
    }, [
      O(i.$slots, "default")
    ], 10, oi));
  }
}), nn = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BCollapse",
  props: {
    id: { default: void 0 },
    modelValue: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    toggle: { type: [String, Boolean], default: !1 },
    horizontal: { type: [String, Boolean], default: !1 },
    visible: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: !1 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = (C, T = {}) => new Rt(C, {
      cancelable: !1,
      target: p.value || null,
      relatedTarget: null,
      trigger: null,
      ...T,
      componentId: h.value
    }), n = Se(a, "modelValue", l, { passive: !0 }), s = d(n), r = d(() => a.toggle), i = d(() => a.horizontal), v = d(() => a.isNav), b = d(() => a.visible), h = _e(() => a.id, "collapse"), p = R(null), B = R(!1), S = R(s.value), m = u(() => ({
      show: S.value,
      "navbar-collapse": v.value,
      collapsing: B.value,
      closing: S.value && !s.value,
      "collapse-horizontal": i.value
    })), A = () => {
      n.value = !1;
    }, y = () => {
      n.value = !0;
    }, k = () => {
      n.value = !s.value;
    }, w = () => {
      S.value = !0, B.value = !0;
      const C = o("show", { cancelable: !0 });
      if (l("show", C), C.defaultPrevented) {
        l("show-prevented");
        return;
      }
      Ce(() => {
        p.value !== null && (i.value ? p.value.style.width = `${p.value.scrollWidth}px` : p.value.style.height = `${p.value.scrollHeight}px`, setTimeout(() => {
          B.value = !1, l("shown", o("shown")), p.value !== null && (p.value.style.height = "", p.value.style.width = "");
        }, ha(p.value)));
      });
    }, _ = () => {
      const C = o("hide", { cancelable: !0 });
      if (l("hide", C), C.defaultPrevented) {
        l("hide-prevented");
        return;
      }
      p.value !== null && (i.value ? p.value.style.width = `${p.value.scrollWidth}px` : p.value.style.height = `${p.value.scrollHeight}px`, p.value.offsetHeight, B.value = !0, Ce(() => {
        p.value !== null && (p.value.style.height = "", p.value.style.width = "", setTimeout(() => {
          S.value = !1, B.value = !1, l("hidden", o("hidden"));
        }, ha(p.value)));
      }));
    };
    return oe([n, S], () => {
      if (s.value === !0) {
        if (S.value)
          return;
        w();
        return;
      }
      _();
    }), He(() => {
      p.value !== null && !s.value && r.value && Ce(() => {
        n.value = !0;
      });
    }), b.value && (n.value = !0, S.value = !0), oe(b, (C) => {
      C ? y() : A();
    }), we(p, "bv-toggle", () => {
      n.value = !s.value;
    }), t({
      close: A,
      open: y,
      toggle: k,
      visible: ye(S),
      isNav: v
    }), De(Ga, {
      id: h,
      close: A,
      open: y,
      toggle: k,
      visible: ye(S),
      isNav: v
    }), (C, T) => (g(), P(ce, null, [
      O(C.$slots, "header", Be(Ve({ visible: $(s), toggle: k, open: y, close: A, id: $(h) }))),
      (g(), M(le(C.tag), ee({
        id: $(h),
        ref_key: "element",
        ref: p,
        class: ["collapse", m.value],
        "is-nav": $(v)
      }, C.$attrs), {
        default: j(() => [
          O(C.$slots, "default", Be(Ve({ visible: $(s), toggle: C.toggle, open: y, close: A })))
        ]),
        _: 3
      }, 16, ["id", "class", "is-nav"])),
      O(C.$slots, "footer", Be(Ve({ visible: $(s), toggle: k, open: y, close: A, id: $(h) })))
    ], 64));
  }
}), si = { class: "accordion-item" }, ri = ["aria-expanded", "aria-controls", "onClick"], ii = { class: "accordion-body" }, ui = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BAccordionItem",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    modelValue: { type: [String, Boolean], default: !1 },
    headerTag: { default: "h2" },
    tag: { default: void 0 },
    toggle: { type: [String, Boolean], default: void 0 },
    horizontal: { type: [String, Boolean], default: void 0 },
    visible: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "update:modelValue"],
  setup(e, { emit: t }) {
    const l = e, a = {
      show: (r) => t("show", r),
      shown: (r) => t("shown", r),
      hide: (r) => t("hide", r),
      hidden: (r) => t("hidden", r),
      "hide-prevented": () => t("hide-prevented"),
      "show-prevented": () => t("show-prevented")
    }, o = Se(l, "modelValue", t, { passive: !0 }), n = Oe($o, null), s = _e(() => l.id, "accordion_item");
    return He(() => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(s.value)), !o.value && (n == null ? void 0 : n.openItem.value) === s.value && (o.value = !0);
    }), oe(
      () => n == null ? void 0 : n.openItem.value,
      () => o.value = (n == null ? void 0 : n.openItem.value) === s.value && !(n != null && n.free.value)
    ), oe(o, () => {
      o.value && !(n != null && n.free.value) && (n == null || n.setOpenItem(s.value));
    }), (r, i) => (g(), P("div", si, [
      be(nn, ee({
        id: $(s),
        modelValue: $(o),
        "onUpdate:modelValue": i[0] || (i[0] = (v) => La(o) ? o.value = v : null),
        class: "accordion-collapse"
      }, r.$attrs, {
        "aria-labelledby": `${$(s)}-heading`,
        tag: r.tag,
        toggle: r.toggle,
        horizontal: r.horizontal,
        visible: r.visible,
        "is-nav": r.isNav
      }, io(a)), {
        header: j(({ visible: v, toggle: b }) => [
          (g(), M(le(r.headerTag), {
            id: `${$(s)}-heading`,
            class: "accordion-header"
          }, {
            default: j(() => [
              K("button", {
                class: H(["accordion-button", { collapsed: !v }]),
                type: "button",
                "aria-expanded": v ? "true" : "false",
                "aria-controls": $(s),
                onClick: b
              }, [
                O(r.$slots, "title", {}, () => [
                  ne(Y(r.title), 1)
                ])
              ], 10, ri)
            ]),
            _: 2
          }, 1032, ["id"]))
        ]),
        default: j(() => [
          K("div", ii, [
            O(r.$slots, "default")
          ])
        ]),
        _: 3
      }, 16, ["id", "modelValue", "aria-labelledby", "tag", "toggle", "horizontal", "visible", "is-nav"])
    ]));
  }
}), At = /* @__PURE__ */ N({
  __name: "BTransition",
  props: {
    appear: { type: [String, Boolean], default: !1 },
    mode: { default: void 0 },
    noFade: { type: [String, Boolean], default: !1 },
    transProps: { default: void 0 }
  },
  setup(e) {
    const t = e, l = d(() => t.appear), a = d(() => t.noFade), o = u(() => {
      const r = {
        name: "",
        enterActiveClass: "",
        enterToClass: "",
        leaveActiveClass: "",
        leaveToClass: "showing",
        enterFromClass: "showing",
        leaveFromClass: ""
      }, i = {
        ...r,
        enterActiveClass: "fade showing",
        leaveActiveClass: "fade showing"
      };
      return a.value ? r : i;
    }), n = u(() => ({ mode: t.mode, css: !0, ...o.value })), s = u(
      () => t.transProps !== void 0 ? {
        // Order matters here since the props.transProps would get overwritten if it came first
        // But the goal of props.transProps is to overwrite base properties
        ...n.value,
        ...t.transProps
      } : l.value ? {
        ...n.value,
        appear: !0,
        appearActiveClass: o.value.enterActiveClass,
        appearToClass: o.value.enterToClass
      } : n.value
    );
    return (r, i) => (g(), M(jn, Be(Ve(s.value)), {
      default: j(() => [
        O(r.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
});
const di = ["type", "disabled", "aria-label"], Ot = /* @__PURE__ */ N({
  __name: "BCloseButton",
  props: {
    ariaLabel: { default: "Close" },
    disabled: { type: [String, Boolean], default: !1 },
    white: { type: [String, Boolean], default: !1 },
    type: { default: "button" }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.disabled), o = d(() => l.white), n = u(() => ({
      "btn-close-white": o.value
    }));
    return (s, r) => (g(), P("button", {
      type: s.type,
      class: H(["btn-close", n.value]),
      disabled: $(a),
      "aria-label": s.ariaLabel,
      onClick: r[0] || (r[0] = (i) => t("click", i))
    }, null, 10, di));
  }
}), ci = {
  key: 0,
  class: "visually-hidden"
}, pa = /* @__PURE__ */ N({
  __name: "BSpinner",
  props: {
    label: { default: void 0 },
    role: { default: "status" },
    small: { type: [String, Boolean], default: !1 },
    tag: { default: "span" },
    type: { default: "border" },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = Fe(), a = d(() => t.small), o = u(() => ({
      "spinner-border": t.type === "border",
      "spinner-border-sm": t.type === "border" && a.value,
      "spinner-grow": t.type === "grow",
      "spinner-grow-sm": t.type === "grow" && a.value,
      [`text-${t.variant}`]: t.variant !== null
    })), n = u(() => !Ae(l.label));
    return (s, r) => (g(), M(le(s.tag), {
      class: H(o.value),
      role: s.label || n.value ? s.role : null,
      "aria-hidden": s.label || n.value ? null : !0
    }, {
      default: j(() => [
        s.label || n.value ? (g(), P("span", ci, [
          O(s.$slots, "label", {}, () => [
            ne(Y(s.label), 1)
          ])
        ])) : J("", !0)
      ]),
      _: 3
    }, 8, ["class", "role", "aria-hidden"]));
  }
}), fi = {
  active: { type: [Boolean, String, void 0], default: void 0 },
  activeClass: { type: String, default: "router-link-active" },
  append: { type: [Boolean, String], default: !1 },
  disabled: { type: [Boolean, String], default: !1 },
  event: { type: [String, Array], default: "click" },
  href: { type: String },
  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},
  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},
  rel: { type: String, default: null },
  replace: { type: [Boolean, String], default: !1 },
  routerComponentName: { type: String, default: "router-link" },
  routerTag: { type: String, default: "a" },
  target: { type: String, default: "_self" },
  to: { type: [String, Object], default: null },
  variant: { type: String, default: null }
}, Xe = /* @__PURE__ */ N({
  __name: "BLink",
  props: {
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    event: { default: "click" },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: null },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = za(), o = d(() => l.active), n = d(() => l.icon);
    d(() => l.append);
    const s = d(() => l.disabled);
    d(() => l.replace);
    const r = Oe(Ga, null), i = Oe(Wa, null), v = () => {
      var y;
      i !== null && ((y = r == null ? void 0 : r.close) == null || y.call(r));
    }, b = ia(), h = u(() => {
      const y = l.routerComponentName.split("-").map((w) => w.charAt(0).toUpperCase() + w.slice(1)).join("");
      return !((b == null ? void 0 : b.appContext.app.component(y)) !== void 0) || s.value || !l.to ? "a" : l.routerComponentName;
    }), p = u(() => {
      const y = "#";
      if (l.href)
        return l.href;
      if (typeof l.to == "string")
        return l.to || y;
      const k = l.to;
      if (Object.prototype.toString.call(k) === "[object Object]" && (k.path || k.query || k.hash)) {
        const w = k.path || "", _ = k.query ? `?${Object.keys(k.query).map((T) => `${T}=${k.query[T]}`).join("=")}` : "", C = !k.hash || k.hash.charAt(0) === "#" ? k.hash || "" : `#${k.hash}`;
        return `${w}${_}${C}` || y;
      }
      return y;
    }), B = u(() => ({
      [`link-${l.variant}`]: l.variant !== null,
      [`link-opacity-${l.opacity}`]: l.opacity !== void 0,
      [`link-opacity-${l.opacityHover}-hover`]: l.opacityHover !== void 0,
      [`link-underline-${l.underlineVariant}`]: l.underlineVariant !== null,
      [`link-offset-${l.underlineOffset}`]: l.underlineOffset !== void 0,
      [`link-offset-${l.underlineOffsetHover}-hover`]: l.underlineOffsetHover !== void 0,
      [`link-underline-opacity-${l.underlineOpacity}`]: l.underlineOpacity !== void 0,
      [`link-underline-opacity-${l.underlineOpacityHover}-hover`]: l.underlineOpacityHover !== void 0,
      "icon-link": n.value === !0
    })), S = u(() => ({
      class: B.value,
      to: l.to,
      href: p.value,
      target: l.target,
      rel: l.target === "_blank" && l.rel === void 0 ? "noopener" : l.rel || void 0,
      tabindex: s.value ? "-1" : typeof a.tabindex > "u" ? null : a.tabindex,
      "aria-disabled": s.value ? !0 : null
    })), m = u(() => ({
      [l.activeClass]: o.value,
      disabled: s.value
    })), A = (y) => {
      var k;
      if (s.value) {
        y.preventDefault(), y.stopImmediatePropagation();
        return;
      }
      (k = r == null ? void 0 : r.close) == null || k.call(r), t("click", y);
    };
    return (y, k) => h.value === "router-link" ? (g(), M(le(h.value), ee({ key: 0 }, S.value, { custom: "" }), {
      default: j(({ href: w, navigate: _, isActive: C }) => [
        (g(), M(le(y.routerTag), ee({
          href: w,
          class: [($(o) ?? C) && y.activeClass]
        }, y.$attrs, {
          onClick: (T) => {
            _(T), v(), A(T);
          }
        }), {
          default: j(() => [
            O(y.$slots, "default")
          ]),
          _: 2
        }, 1040, ["href", "class", "onClick"]))
      ]),
      _: 3
    }, 16)) : (g(), M(le(h.value), ee({
      key: 1,
      class: m.value
    }, S.value, { onClick: A }), {
      default: j(() => [
        O(y.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), kt = /* @__PURE__ */ N({
  __name: "BButton",
  props: {
    pill: { type: [String, Boolean], default: !1 },
    pressed: { type: [String, Boolean], default: void 0 },
    size: { default: "md" },
    squared: { type: [String, Boolean], default: !1 },
    tag: { default: "button" },
    type: { default: "button" },
    variant: { default: "secondary" },
    loading: { type: [String, Boolean], default: !1 },
    loadingMode: { default: "inline" },
    block: { type: [String, Boolean], default: !1 },
    active: { type: [String, Boolean], default: !1 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    event: { default: "click" },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    routerTag: { default: "a" },
    target: { default: "_self" },
    to: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  emits: ["click", "update:pressed"],
  setup(e, { emit: t }) {
    const l = e, a = Se(l, "pressed", t), o = d(() => l.active), n = d(() => l.block), s = d(() => l.disabled), r = d(() => l.pill), i = d(() => l.pressed), v = d(() => l.squared), b = d(() => l.loading), h = u(() => typeof i.value == "boolean"), p = u(
      () => l.tag === "button" && l.href === void 0 && l.to === void 0
    ), B = u(() => wt(l)), S = u(() => l.to !== void 0), m = u(() => l.href !== void 0 ? !1 : !p.value), A = u(() => [
      [`btn-${l.size}`],
      {
        [`btn-${l.variant}`]: l.variant !== null,
        "btn-block": n.value,
        active: o.value || i.value,
        "rounded-pill": r.value,
        "rounded-0": v.value,
        disabled: s.value
      }
    ]), y = u(() => ({
      "aria-disabled": m.value ? s.value : null,
      "aria-pressed": h.value ? i.value : null,
      autocomplete: h.value ? "off" : null,
      disabled: p.value ? s.value : null,
      href: l.href,
      rel: B.value ? l.rel : null,
      role: m.value || B.value ? "button" : null,
      target: B.value ? l.target : null,
      type: p.value ? l.type : null,
      to: p.value ? null : l.to,
      append: B.value ? l.append : null,
      activeClass: S.value ? l.activeClass : null,
      event: S.value ? l.event : null,
      replace: S.value ? l.replace : null,
      routerComponentName: S.value ? l.routerComponentName : null,
      routerTag: S.value ? l.routerTag : null
    })), k = u(
      () => S.value ? Xe : l.href ? "a" : l.tag
    ), w = (_) => {
      if (s.value) {
        _.preventDefault(), _.stopPropagation();
        return;
      }
      t("click", _), h.value && (a.value = !i.value);
    };
    return (_, C) => (g(), M(le(k.value), ee({
      class: ["btn", A.value]
    }, y.value, { onClick: w }), {
      default: j(() => [
        $(b) ? (g(), P("div", {
          key: 0,
          class: H(["btn-loading", { "mode-fill": _.loadingMode === "fill", "mode-inline": _.loadingMode === "inline" }])
        }, [
          O(_.$slots, "loading", {}, () => [
            be(pa, {
              class: "btn-spinner",
              small: _.size !== "lg"
            }, null, 8, ["small"])
          ])
        ], 2)) : J("", !0),
        K("div", {
          class: H(["btn-content", { "btn-loading-fill": $(b) && _.loadingMode === "fill" }])
        }, [
          O(_.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), vi = ["onMouseenter"], pi = /* @__PURE__ */ N({
  __name: "BAlert",
  props: {
    noHoverPause: { type: [String, Boolean], default: !1 },
    dismissLabel: { default: "Close" },
    dismissible: { type: [String, Boolean], default: !1 },
    fade: { type: [String, Boolean], default: !1 },
    closeVariant: { default: "secondary" },
    modelValue: { type: [Boolean, Number], default: !1 },
    variant: { default: "info" },
    closeContent: { default: void 0 },
    immediate: { type: [String, Boolean], default: !0 },
    interval: { default: 1e3 },
    showOnPause: { type: [String, Boolean], default: !0 }
  },
  emits: ["closed", "close-countdown", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Fe(), n = Se(a, "modelValue", l), s = d(() => a.dismissible), r = d(() => a.fade), i = d(() => a.immediate), v = d(() => a.showOnPause), b = d(() => a.noHoverPause), h = u(() => !Ae(o.close)), p = u(
      () => typeof n.value == "boolean" ? 0 : n.value
    ), B = u(() => ({
      [`alert-${a.variant}`]: a.variant !== null,
      "alert-dismissible": s.value
    })), {
      isActive: S,
      pause: m,
      restart: A,
      resume: y,
      stop: k,
      isPaused: w,
      value: _
    } = Wr(p, () => a.interval, {
      immediate: typeof n.value == "number" && i.value
    }), C = u(
      () => typeof n.value == "boolean" ? n.value : S.value || v.value && w.value
    ), T = u(() => ({
      variant: a.closeVariant,
      type: "button"
    }));
    Ht(() => l("close-countdown", _.value));
    const c = () => {
      typeof n.value == "boolean" ? n.value = !1 : (n.value = 0, k()), l("closed");
    }, V = () => {
      b.value || m();
    };
    return ro(k), t({ pause: m, resume: y, restart: A, stop: k }), (F, f) => (g(), M(At, {
      "no-fade": !$(r),
      "trans-props": { enterToClass: "show" }
    }, {
      default: j(() => [
        C.value ? (g(), P("div", {
          key: 0,
          class: H(["alert", B.value]),
          role: "alert",
          "aria-live": "polite",
          "aria-atomic": "true",
          onMouseenter: ot(V, ["stop"]),
          onMouseleave: f[0] || (f[0] = ot(
            //@ts-ignore
            (...I) => $(y) && $(y)(...I),
            ["stop"]
          ))
        }, [
          O(F.$slots, "default"),
          $(s) ? (g(), P(ce, { key: 0 }, [
            h.value || F.closeContent ? (g(), M(kt, ee({ key: 0 }, T.value, { onClick: c }), {
              default: j(() => [
                O(F.$slots, "close", {}, () => [
                  ne(Y(F.closeContent), 1)
                ])
              ]),
              _: 3
            }, 16)) : (g(), M(Ot, ee({
              key: 1,
              "aria-label": F.dismissLabel
            }, T.value, { onClick: c }), null, 16, ["aria-label"]))
          ], 64)) : J("", !0)
        ], 42, vi)) : J("", !0)
      ]),
      _: 3
    }, 8, ["no-fade"]));
  }
}), mi = {
  key: 0,
  class: "b-avatar-custom"
}, gi = {
  key: 1,
  class: "b-avatar-img"
}, yi = ["src", "alt"], ka = (e) => {
  const t = typeof e == "string" && co(e) ? Et(e, 0) : e;
  return typeof t == "number" ? `${t}px` : t || null;
}, bi = /* @__PURE__ */ N({
  __name: "BAvatar",
  props: {
    alt: { default: "avatar" },
    ariaLabel: { default: void 0 },
    badge: { type: [Boolean, String], default: !1 },
    badgeLeft: { type: [String, Boolean], default: !1 },
    badgeOffset: { default: void 0 },
    badgeTop: { type: [String, Boolean], default: !1 },
    badgeVariant: { default: "primary" },
    button: { type: [String, Boolean], default: !1 },
    buttonType: { default: "button" },
    disabled: { type: [String, Boolean], default: !1 },
    icon: { type: [String, Boolean], default: void 0 },
    rounded: { type: [Boolean, String], default: "circle" },
    size: { default: void 0 },
    square: { type: [String, Boolean], default: !1 },
    src: { default: void 0 },
    text: { default: void 0 },
    textVariant: { default: null },
    variant: { default: "secondary" },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 }
  },
  emits: ["click", "img-error"],
  setup(e, { emit: t }) {
    const l = e, a = Fe(), o = Oe(_o, null), n = ["sm", null, "lg"], s = 0.4, r = s * 0.7, i = d(() => l.badgeLeft), v = d(() => l.badgeTop), b = d(() => l.button), h = d(() => l.disabled), p = d(() => l.square), B = u(() => !Ae(a.default)), S = u(() => !Ae(a.badge)), m = u(() => !!l.badge || l.badge === "" || S.value), A = u(() => wt(l)), y = u(
      () => (o == null ? void 0 : o.size.value) ?? ka(l.size)
    ), k = u(
      () => (o == null ? void 0 : o.variant.value) ?? l.variant
    ), w = u(() => (o == null ? void 0 : o.rounded.value) ?? l.rounded), _ = u(() => ({
      type: b.value && !A.value ? l.buttonType : void 0,
      "aria-label": l.ariaLabel || null,
      disabled: h.value || null,
      // Link props
      ...A.value ? Mt(l, [
        "active",
        "activeClass",
        "append",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover"
      ]) : {}
    })), C = u(() => ({
      [`bg-${l.badgeVariant}`]: l.badgeVariant !== null
    })), T = u(() => l.badge === !0 ? "" : l.badge), c = u(() => ({
      [`text-${l.badgeVariant !== null && te(l.badgeVariant)}`]: l.badgeVariant !== null
    })), V = u(() => ({
      [`b-avatar-${l.size}`]: !!l.size && n.indexOf(ka(l.size)) !== -1,
      [`bg-${k.value}`]: k.value !== null,
      badge: !b.value && k.value !== null && B.value,
      rounded: w.value === "" || w.value === !0,
      "rounded-circle": !p.value && w.value === "circle",
      "rounded-0": p.value || w.value === "0",
      "rounded-1": !p.value && w.value === "sm",
      "rounded-3": !p.value && w.value === "lg",
      "rounded-top": !p.value && w.value === "top",
      "rounded-bottom": !p.value && w.value === "bottom",
      "rounded-start": !p.value && w.value === "left",
      "rounded-end": !p.value && w.value === "right",
      btn: b.value,
      [`btn-${k.value}`]: b.value ? k.value !== null : !1
    })), F = u(() => ({
      [`text-${l.textVariant || k.value !== null && te(k.value)}`]: l.textVariant || k.value !== null
    })), f = u(() => {
      const X = l.badgeOffset || "0px";
      return {
        fontSize: (n.indexOf(y.value || null) === -1 ? `calc(${y.value} * ${r})` : "") || "",
        top: v.value ? X : "",
        bottom: v.value ? "" : X,
        left: i.value ? X : "",
        right: i.value ? "" : X
      };
    }), I = u(() => {
      const X = n.indexOf(y.value || null) === -1 ? `calc(${y.value} * ${s})` : null;
      return X ? { fontSize: X } : {};
    }), E = u(() => {
      var ge;
      const X = ((ge = o == null ? void 0 : o.overlapScale) == null ? void 0 : ge.value) || 0, ve = y.value && X ? `calc(${y.value} * -${X})` : null;
      return ve ? { marginLeft: ve, marginRight: ve } : {};
    }), z = u(
      () => A.value ? Xe : b.value ? "button" : "span"
    ), Z = u(() => ({
      ...E.value,
      width: y.value ?? void 0,
      height: y.value ?? void 0
    })), te = (X) => X === "light" || X === "warning" ? "dark" : "light", G = (X) => {
      !h.value && (A.value || b.value) && t("click", X);
    }, W = (X) => t("img-error", X);
    return (X, ve) => (g(), M(le(z.value), ee({
      class: ["b-avatar", V.value],
      style: Z.value
    }, _.value, { onClick: G }), {
      default: j(() => [
        B.value ? (g(), P("span", mi, [
          O(X.$slots, "default")
        ])) : X.src ? (g(), P("span", gi, [
          K("img", {
            src: X.src,
            alt: X.alt,
            onError: W
          }, null, 40, yi)
        ])) : X.text ? (g(), P("span", {
          key: 2,
          class: H(["b-avatar-text", F.value]),
          style: ze(I.value)
        }, Y(X.text), 7)) : J("", !0),
        m.value ? (g(), P("span", {
          key: 3,
          class: H(["b-avatar-badge", C.value]),
          style: ze(f.value)
        }, [
          S.value ? O(X.$slots, "badge", { key: 0 }) : (g(), P("span", {
            key: 1,
            class: H(c.value)
          }, Y(T.value), 3))
        ], 6)) : J("", !0)
      ]),
      _: 3
    }, 16, ["class", "style"]));
  }
}), hi = /* @__PURE__ */ N({
  __name: "BAvatarGroup",
  props: {
    overlap: { default: 0.3 },
    rounded: { type: [Boolean, String], default: !1 },
    size: { default: void 0 },
    square: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = d(() => t.square), a = u(() => ka(t.size)), o = u(
      () => Math.min(Math.max(s(t.overlap), 0), 1) / 2
    ), n = u(() => {
      const r = a.value ? `calc(${a.value} * ${o.value})` : null;
      return r ? { paddingLeft: r, paddingRight: r } : {};
    }), s = (r) => typeof r == "string" && co(r) ? Et(r, 0) : r || 0;
    return De(_o, {
      overlapScale: o,
      size: ye(ke(t, "size")),
      square: l,
      rounded: ye(ke(t, "rounded")),
      variant: ye(ke(t, "variant"))
    }), (r, i) => (g(), M(le(r.tag), {
      class: "b-avatar-group",
      role: "group"
    }, {
      default: j(() => [
        K("div", {
          class: "b-avatar-group-inner",
          style: ze(n.value)
        }, [
          O(r.$slots, "default")
        ], 4)
      ]),
      _: 3
    }));
  }
}), Bi = /* @__PURE__ */ N({
  __name: "BBadge",
  props: {
    pill: { type: [String, Boolean], default: !1 },
    tag: { default: "span" },
    textIndicator: { type: [String, Boolean], default: !1 },
    dotIndicator: { type: [String, Boolean], default: !1 },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: "secondary" },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.pill), a = d(() => t.textIndicator), o = d(() => t.dotIndicator), n = d(() => t.active), s = d(() => t.disabled), r = u(() => wt(t)), i = u(() => r.value ? Xe : t.tag), v = u(() => ({
      [`bg-${t.variant}`]: t.variant !== null,
      active: n.value,
      disabled: s.value,
      "text-dark": t.variant !== null && ["warning", "info", "light"].includes(t.variant),
      "rounded-pill": l.value,
      "position-absolute top-0 start-100 translate-middle": a.value || o.value,
      "p-2 border border-light rounded-circle": o.value,
      "text-decoration-none": r.value
    })), b = u(
      () => r.value ? Mt(t, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    );
    return (h, p) => (g(), M(le(i.value), ee({
      class: ["badge", v.value]
    }, b.value), {
      default: j(() => [
        O(h.$slots, "default")
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), sn = /* @__PURE__ */ N({
  __name: "BBreadcrumbItem",
  props: {
    ariaCurrent: { default: "location" },
    text: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.active), o = d(() => l.disabled), n = u(() => ({
      active: a.value
    })), s = u(() => a.value ? "span" : Xe), r = u(() => a.value ? l.ariaCurrent : void 0), i = u(
      () => s.value !== "span" ? Mt(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    ), v = (b) => {
      if (o.value || a.value) {
        b.preventDefault(), b.stopImmediatePropagation();
        return;
      }
      o.value || t("click", b);
    };
    return (b, h) => (g(), P("li", {
      class: H(["breadcrumb-item", n.value])
    }, [
      (g(), M(le(s.value), ee({ "aria-current": r.value }, i.value, { onClick: v }), {
        default: j(() => [
          O(b.$slots, "default", {}, () => [
            ne(Y(b.text), 1)
          ])
        ]),
        _: 3
      }, 16, ["aria-current"]))
    ], 2));
  }
}), Si = { "aria-label": "breadcrumb" }, wi = { class: "breadcrumb" }, _i = /* @__PURE__ */ N({
  __name: "BBreadcrumb",
  props: {
    items: { default: void 0 }
  },
  setup(e) {
    const t = e, l = Ko(), a = u(() => {
      const o = t.items || (l == null ? void 0 : l.items) || [];
      let n = !1;
      return o.map((r, i) => (typeof r == "string" && (r = { text: r }, i < o.length - 1 && (r.href = "#")), r.active && (n = !0), !r.active && !n && (r.active = i + 1 === o.length), r));
    });
    return (o, n) => (g(), P("nav", Si, [
      K("ol", wi, [
        O(o.$slots, "prepend"),
        (g(!0), P(ce, null, he(a.value, (s, r) => (g(), M(sn, ee({ key: r }, s), {
          default: j(() => [
            ne(Y(s.text), 1)
          ]),
          _: 2
        }, 1040))), 128)),
        O(o.$slots, "default"),
        O(o.$slots, "append")
      ])
    ]));
  }
}), $i = /* @__PURE__ */ N({
  __name: "BButtonGroup",
  props: {
    ariaLabel: { default: "Group" },
    size: { default: "md" },
    tag: { default: "div" },
    vertical: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.vertical), a = u(() => ({
      "btn-group": !l.value,
      [`btn-group-${t.size}`]: t.size !== "md",
      "btn-group-vertical": l.value
    }));
    return (o, n) => (g(), M(le(o.tag), {
      class: H(a.value),
      role: "group",
      "aria-label": o.ariaLabel
    }, {
      default: j(() => [
        O(o.$slots, "default")
      ]),
      _: 3
    }, 8, ["class", "aria-label"]));
  }
}), Ci = ["role", "aria-label"], ki = /* @__PURE__ */ N({
  __name: "BButtonToolbar",
  props: {
    ariaLabel: { default: "Group" },
    justify: { type: [String, Boolean], default: !1 },
    role: { default: "toolbar" }
  },
  setup(e) {
    const t = e, l = d(() => t.justify), a = u(() => ({
      "justify-content-between": l.value
    }));
    return (o, n) => (g(), P("div", {
      class: H([a.value, "btn-toolbar"]),
      role: o.role,
      "aria-label": o.ariaLabel
    }, [
      O(o.$slots, "default")
    ], 10, Ci));
  }
}), Ti = '<svg width="%{w}" height="%{h}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 %{w} %{h}" preserveAspectRatio="none"><rect width="100%" height="100%" style="fill:%{f};"></rect></svg>', al = /* @__PURE__ */ N({
  __name: "BImg",
  props: {
    alt: { default: void 0 },
    blank: { type: [String, Boolean], default: !1 },
    blankColor: { default: "transparent" },
    block: { type: [String, Boolean], default: !1 },
    center: { type: [String, Boolean], default: !1 },
    fluid: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    fluidGrow: { type: [String, Boolean], default: !1 },
    height: { default: void 0 },
    start: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    rounded: { type: [Boolean, String], default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    thumbnail: { type: [String, Boolean], default: !1 },
    width: { default: void 0 }
  },
  setup(e) {
    const t = e, l = d(() => t.lazy), a = d(() => t.blank), o = d(() => t.block), n = d(() => t.center), s = d(() => t.fluid), r = d(() => t.fluidGrow), i = d(() => t.start), v = d(() => t.end), b = d(() => t.thumbnail), h = u(
      () => typeof t.srcset == "string" ? t.srcset.split(",").filter((w) => w).join(",") : Array.isArray(t.srcset) ? t.srcset.filter((w) => w).join(",") : void 0
    ), p = u(
      () => typeof t.sizes == "string" ? t.sizes.split(",").filter((w) => w).join(",") : Array.isArray(t.sizes) ? t.sizes.filter((w) => w).join(",") : void 0
    ), B = u(() => {
      const w = (T) => T === void 0 ? void 0 : typeof T == "number" ? T : Number.parseInt(T, 10) || void 0, _ = w(t.width), C = w(t.height);
      if (a.value) {
        if (_ !== void 0 && C === void 0)
          return { height: _, width: _ };
        if (_ === void 0 && C !== void 0)
          return { height: C, width: C };
        if (_ === void 0 && C === void 0)
          return { height: 1, width: 1 };
      }
      return {
        width: _,
        height: C
      };
    }), S = u(
      () => k(B.value.width, B.value.height, t.blankColor)
    ), m = u(() => ({
      src: a.value ? S.value : t.src,
      alt: t.alt,
      width: B.value.width || void 0,
      height: B.value.height || void 0,
      srcset: a.value ? void 0 : h.value,
      sizes: a.value ? void 0 : p.value,
      loading: l.value ? "lazy" : "eager"
    })), A = u(
      () => i.value ? "float-start" : v.value ? "float-end" : n.value ? "mx-auto" : void 0
    ), y = u(() => ({
      "img-thumbnail": b.value,
      "img-fluid": s.value || r.value,
      "w-100": r.value,
      rounded: t.rounded === "" || t.rounded === !0,
      [`rounded-${t.rounded}`]: typeof t.rounded == "string" && t.rounded !== "",
      [`${A.value}`]: A.value !== void 0,
      "d-block": o.value || n.value
    })), k = (w, _, C) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(
      Ti.replace("%{w}", String(w)).replace("%{h}", String(_)).replace("%{f}", C)
    )}`;
    return (w, _) => (g(), P("img", ee({ class: y.value }, m.value), null, 16));
  }
}), ra = /* @__PURE__ */ N({
  __name: "BCardImg",
  props: {
    alt: { default: void 0 },
    blank: { type: [String, Boolean], default: !1 },
    blankColor: { default: void 0 },
    bottom: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    height: { default: void 0 },
    start: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    sizes: { default: void 0 },
    src: { default: void 0 },
    srcset: { default: void 0 },
    top: { type: [String, Boolean], default: !1 },
    width: { default: void 0 }
  },
  emits: ["load"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.bottom), o = d(() => l.end), n = d(() => l.start), s = d(() => l.top), r = u(
      () => s.value ? "card-img-top" : o.value ? "card-img-right" : a.value ? "card-img-bottom" : n.value ? "card-img-left" : "card-img"
    ), i = u(() => ({
      alt: l.alt,
      height: l.height,
      src: l.src,
      lazy: l.lazy,
      width: l.width,
      blank: l.blank,
      blankColor: l.blankColor,
      sizes: l.sizes,
      srcset: l.srcset
    }));
    return (v, b) => (g(), M(al, ee({ class: r.value }, i.value, {
      onLoad: b[0] || (b[0] = (h) => t("load", h))
    }), null, 16, ["class"]));
  }
}), Vi = ["innerHTML"], rn = /* @__PURE__ */ N({
  __name: "BCardHeadFoot",
  props: {
    text: { default: void 0 },
    bgVariant: { default: null },
    borderVariant: { default: null },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: null }
  },
  setup(e) {
    const t = e, l = u(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null,
      [`bg-${t.bgVariant}`]: t.bgVariant !== null,
      [`border-${t.borderVariant}`]: t.borderVariant !== null
    }));
    return (a, o) => (g(), M(le(a.tag), {
      class: H(l.value)
    }, {
      default: j(() => [
        a.html ? (g(), P("div", {
          key: 0,
          innerHTML: a.html
        }, null, 8, Vi)) : O(a.$slots, "default", { key: 1 }, () => [
          ne(Y(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), un = /* @__PURE__ */ N({
  __name: "BCardHeader",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (l, a) => (g(), M(rn, ee({ class: "card-header" }, t), {
      default: j(() => [
        O(l.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), dn = /* @__PURE__ */ N({
  __name: "BCardTitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h4" }
  },
  setup(e) {
    return (t, l) => (g(), M(le(t.tag), { class: "card-title" }, {
      default: j(() => [
        O(t.$slots, "default", {}, () => [
          ne(Y(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), cn = /* @__PURE__ */ N({
  __name: "BCardSubtitle",
  props: {
    text: { default: void 0 },
    tag: { default: "h6" },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, l = u(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null
    }));
    return (a, o) => (g(), M(le(a.tag), {
      class: H(["card-subtitle mb-2", l.value])
    }, {
      default: j(() => [
        O(a.$slots, "default", {}, () => [
          ne(Y(a.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), fn = /* @__PURE__ */ N({
  __name: "BCardBody",
  props: {
    bodyBgVariant: { default: null },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: null },
    overlay: { type: [String, Boolean], default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h4" },
    subtitleTextVariant: { default: void 0 },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    text: { default: void 0 }
  },
  setup(e) {
    const t = e, l = Fe(), a = d(() => t.overlay), o = u(() => !Ae(l.title)), n = u(() => !Ae(l.subtitle)), s = u(() => ({
      "card-img-overlay": a.value,
      [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== null,
      [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== null
    }));
    return (r, i) => (g(), M(le(r.bodyTag), {
      class: H(["card-body", s.value])
    }, {
      default: j(() => [
        r.title || o.value ? (g(), M(dn, {
          key: 0,
          tag: r.titleTag
        }, {
          default: j(() => [
            O(r.$slots, "title", {}, () => [
              ne(Y(r.title), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag"])) : J("", !0),
        r.subtitle || n.value ? (g(), M(cn, {
          key: 1,
          tag: r.subtitleTag,
          "text-variant": r.subtitleTextVariant
        }, {
          default: j(() => [
            O(r.$slots, "subtitle", {}, () => [
              ne(Y(r.subtitle), 1)
            ])
          ]),
          _: 3
        }, 8, ["tag", "text-variant"])) : J("", !0),
        O(r.$slots, "default", {}, () => [
          ne(Y(r.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), vn = /* @__PURE__ */ N({
  __name: "BCardFooter",
  props: {
    text: { default: void 0 },
    bgVariant: { default: void 0 },
    borderVariant: { default: void 0 },
    html: { default: void 0 },
    tag: { default: "div" },
    textVariant: { default: void 0 }
  },
  setup(e) {
    const t = e;
    return (l, a) => (g(), M(rn, ee({ class: "card-footer" }, t), {
      default: j(() => [
        O(l.$slots, "default", {}, () => [
          ne(Y(l.text), 1)
        ])
      ]),
      _: 3
    }, 16));
  }
}), pn = /* @__PURE__ */ N({
  __name: "BCard",
  props: {
    align: { default: void 0 },
    bgVariant: { default: null },
    bodyBgVariant: { default: void 0 },
    bodyClass: { default: void 0 },
    bodyTag: { default: "div" },
    bodyTextVariant: { default: void 0 },
    borderVariant: { default: null },
    footer: { default: void 0 },
    footerBgVariant: { default: void 0 },
    footerBorderVariant: { default: void 0 },
    footerClass: { default: void 0 },
    footerHtml: { default: "" },
    footerTag: { default: "div" },
    footerTextVariant: { default: void 0 },
    header: { default: void 0 },
    headerBgVariant: { default: void 0 },
    headerBorderVariant: { default: void 0 },
    headerClass: { default: void 0 },
    headerHtml: { default: "" },
    headerTag: { default: "div" },
    headerTextVariant: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBottom: { type: [String, Boolean], default: !1 },
    imgEnd: { type: [String, Boolean], default: !1 },
    imgHeight: { default: void 0 },
    imgSrc: { default: void 0 },
    imgStart: { type: [String, Boolean], default: !1 },
    imgTop: { type: [String, Boolean], default: !1 },
    imgWidth: { default: void 0 },
    noBody: { type: [String, Boolean], default: !1 },
    overlay: { type: [String, Boolean], default: !1 },
    subtitle: { default: void 0 },
    subtitleTag: { default: "h6" },
    subtitleTextVariant: { default: "muted" },
    tag: { default: "div" },
    textVariant: { default: null },
    title: { default: void 0 },
    titleTag: { default: "h4" },
    bodyText: { default: "" }
  },
  setup(e) {
    const t = e, l = Fe(), a = d(() => t.imgBottom), o = d(() => t.imgEnd), n = d(() => t.imgStart), s = d(() => t.noBody), r = u(() => !Ae(l.header)), i = u(() => !Ae(l.footer)), v = u(() => ({
      [`text-${t.align}`]: t.align !== void 0,
      [`text-${t.textVariant}`]: t.textVariant !== null,
      [`bg-${t.bgVariant}`]: t.bgVariant !== null,
      [`border-${t.borderVariant}`]: t.borderVariant !== null,
      "flex-row": n.value,
      "flex-row-reverse": o.value
    })), b = u(() => ({
      bgVariant: t.headerBgVariant,
      borderVariant: t.headerBorderVariant,
      html: t.headerHtml,
      tag: t.headerTag,
      textVariant: t.headerTextVariant
    })), h = u(() => ({
      overlay: t.overlay,
      bodyBgVariant: t.bodyBgVariant,
      bodyTag: t.bodyTag,
      bodyTextVariant: t.bodyTextVariant,
      subtitle: t.subtitle,
      subtitleTag: t.subtitleTag,
      subtitleTextVariant: t.subtitleTextVariant,
      title: t.title,
      titleTag: t.titleTag
    })), p = u(() => ({
      bgVariant: t.footerBgVariant,
      borderVariant: t.footerBorderVariant,
      html: t.footerHtml,
      tag: t.footerTag,
      textVariant: t.footerTextVariant
    })), B = u(() => ({
      src: t.imgSrc,
      alt: t.imgAlt,
      height: t.imgHeight,
      width: t.imgWidth,
      bottom: t.imgBottom,
      end: t.imgEnd,
      start: t.imgStart,
      top: t.imgTop
    }));
    return (S, m) => (g(), M(le(S.tag), {
      class: H(["card", v.value])
    }, {
      default: j(() => [
        $(a) ? J("", !0) : O(S.$slots, "img", { key: 0 }, () => [
          S.imgSrc ? (g(), M(ra, Be(ee({ key: 0 }, B.value)), null, 16)) : J("", !0)
        ]),
        S.header || r.value || S.headerHtml ? (g(), M(un, ee({ key: 1 }, b.value, { class: S.headerClass }), {
          default: j(() => [
            O(S.$slots, "header", {}, () => [
              ne(Y(S.header), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : J("", !0),
        $(s) ? O(S.$slots, "default", { key: 3 }, () => [
          ne(Y(S.bodyText), 1)
        ]) : (g(), M(fn, ee({ key: 2 }, h.value, { class: S.bodyClass }), {
          default: j(() => [
            O(S.$slots, "default", {}, () => [
              ne(Y(S.bodyText), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])),
        S.footer || i.value || S.footerHtml ? (g(), M(vn, ee({ key: 4 }, p.value, { class: S.footerClass }), {
          default: j(() => [
            O(S.$slots, "footer", {}, () => [
              ne(Y(S.footer), 1)
            ])
          ]),
          _: 3
        }, 16, ["class"])) : J("", !0),
        $(a) ? O(S.$slots, "img", { key: 5 }, () => [
          S.imgSrc ? (g(), M(ra, Be(ee({ key: 0 }, B.value)), null, 16)) : J("", !0)
        ]) : J("", !0)
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Ai = /* @__PURE__ */ N({
  __name: "BCardGroup",
  props: {
    columns: { type: [String, Boolean], default: !1 },
    deck: { type: [String, Boolean], default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = d(() => t.columns), a = d(() => t.deck), o = u(
      () => a.value ? "card-deck" : l.value ? "card-columns" : "card-group"
    ), n = u(() => [o.value]);
    return (s, r) => (g(), M(le(s.tag), {
      class: H(n.value)
    }, {
      default: j(() => [
        O(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Oi = /* @__PURE__ */ N({
  __name: "BCardText",
  props: {
    text: { default: void 0 },
    tag: { default: "p" }
  },
  setup(e) {
    return (t, l) => (g(), M(le(t.tag), { class: "card-text" }, {
      default: j(() => [
        O(t.$slots, "default", {}, () => [
          ne(Y(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), Fi = ["id", "onMouseenter", "onMouseleave"], Pi = {
  key: 0,
  class: "carousel-indicators"
}, Ei = ["aria-current", "aria-label", "onClick"], Ii = /* @__PURE__ */ K("span", {
  class: "carousel-control-prev-icon",
  "aria-hidden": "true"
}, null, -1), xi = { class: "visually-hidden" }, Li = /* @__PURE__ */ K("span", {
  class: "carousel-control-next-icon",
  "aria-hidden": "true"
}, null, -1), Ni = { class: "visually-hidden" }, zi = /* @__PURE__ */ N({
  __name: "BCarousel",
  props: {
    ride: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [String, Boolean], default: !1 },
    rideReverse: { type: [String, Boolean], default: !1 },
    fade: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    background: { default: void 0 },
    modelValue: { default: 0 },
    controls: { type: [String, Boolean], default: !1 },
    indicators: { type: [String, Boolean], default: !1 },
    interval: { default: 5e3 },
    noTouch: { type: [String, Boolean], default: !1 },
    noWrap: { type: [String, Boolean], default: !1 },
    controlsPrevText: { default: "Previous" },
    controlsNextText: { default: "Next" },
    indicatorsButtonLabel: { default: "Slide" },
    keyboard: { type: [String, Boolean], default: !0 },
    touchThreshold: { default: 50 }
  },
  emits: ["slid", "slide", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Fe(), n = _e(() => a.id, "carousel"), s = Se(a, "modelValue", l, { passive: !0 }), r = d(() => a.keyboard), i = d(() => a.rideReverse), v = d(() => a.noHoverPause), b = d(() => a.fade), h = d(() => a.controls), p = d(() => a.indicators), B = d(() => a.noTouch), S = d(() => a.noWrap), m = bt(() => a.touchThreshold, {
      nanToZero: !0,
      method: "parseInt"
    }), A = R(!1), y = R(!1), k = R(!0), w = R(null), _ = R(null), C = R(s.value), T = u(
      () => Yn(a.ride) ? Ra(a.ride) : a.ride
    ), c = u(
      () => `carousel-item carousel-item-${k.value ? "prev" : "next"} carousel-item-${k.value ? "end" : "start"}`
    ), V = u(
      () => `carousel-item active carousel-item-${k.value ? "start" : "end"}`
    ), { pause: F, resume: f } = qo(
      () => {
        i.value ? G() : W();
      },
      () => a.interval,
      { immediate: T.value === "carousel" }
    ), I = u(
      () => T.value === !0 && y.value === !0 || T.value === "carousel"
    ), E = u(() => Ba(o.default, "BCarouselSlide")), z = u(() => [
      "carousel",
      "slide",
      "pointer-event",
      { "carousel-fade": b.value }
    ]), Z = (Q) => {
      var re;
      return new uo(Q, {
        componentId: n.value,
        cancelable: !1,
        target: _.value,
        direction: k.value ? "right" : "left",
        from: C.value,
        to: s.value,
        relatedTarget: ((re = w.value) == null ? void 0 : re.children[s.value]) ?? null
      });
    }, te = (Q) => {
      if (A.value !== !0) {
        if (T.value === !0 && (y.value = !0), I.value === !0 && f(), k.value = !(Q < s.value), Q >= E.value.length) {
          if (S.value)
            return;
          s.value = 0;
          return;
        }
        if (Q < 0) {
          if (S.value)
            return;
          s.value = E.value.length - 1;
          return;
        }
        C.value = s.value, s.value = Q;
      }
    }, G = () => {
      te(s.value - 1);
    }, W = () => {
      te(s.value + 1);
    }, X = (Q) => {
      r.value !== !1 && Q();
    }, ve = () => {
      v.value || F();
    }, ge = () => {
      I.value && f();
    }, { lengthX: pe } = jr(_, {
      passive: !0,
      onSwipeStart() {
        B.value !== !0 && F();
      },
      onSwipeEnd() {
        if (B.value === !0)
          return;
        const Q = () => {
          I.value !== !1 && f();
        };
        if (pe.value >= m.value) {
          W(), Q();
          return;
        }
        pe.value <= -m.value && (G(), Q());
      }
    }), me = () => {
      l("slide", Z("slide")), A.value = !0;
    }, q = () => {
      l("slid", Z("slid")), A.value = !1;
    };
    return oe(
      () => a.ride,
      () => {
        y.value = !1;
      }
    ), t({ pause: F, resume: f, prev: G, next: W }), De(ho, {
      background: ye(ke(a, "background")),
      width: ye(ke(a, "imgWidth")),
      height: ye(ke(a, "imgHeight"))
    }), (Q, re) => (g(), P("div", {
      id: $(n),
      ref_key: "element",
      ref: _,
      class: H(z.value),
      onKeydown: [
        re[0] || (re[0] = It((de) => X(G), ["left"])),
        re[1] || (re[1] = It((de) => X(W), ["right"]))
      ],
      onMouseenter: ot(ve, ["stop"]),
      onMouseleave: ot(ge, ["stop"])
    }, [
      $(p) ? (g(), P("div", Pi, [
        (g(!0), P(ce, null, he(E.value.length, (de, L) => (g(), P("button", {
          key: L,
          type: "button",
          "data-bs-target": "",
          class: H(L === $(s) ? "active" : ""),
          "aria-current": L === $(s) ? !0 : void 0,
          "aria-label": `${Q.indicatorsButtonLabel} ${L}`,
          onClick: (x) => te(L)
        }, null, 10, Ei))), 128))
      ])) : J("", !0),
      K("div", {
        ref_key: "relatedTarget",
        ref: w,
        class: "carousel-inner"
      }, [
        be(qn, {
          "enter-from-class": c.value,
          "enter-active-class": c.value,
          "enter-to-class": c.value,
          "leave-from-class": V.value,
          "leave-active-class": V.value,
          "leave-to-class": V.value,
          onBeforeLeave: me,
          onAfterLeave: q
        }, {
          default: j(() => [
            (g(!0), P(ce, null, he(E.value, (de, L) => rt((g(), M(le(de), {
              key: L,
              class: H({ active: L === $(s) && A.value === !1 })
            }, null, 8, ["class"])), [
              [ua, L === $(s)]
            ])), 128))
          ]),
          _: 1
        }, 8, ["enter-from-class", "enter-active-class", "enter-to-class", "leave-from-class", "leave-active-class", "leave-to-class"])
      ], 512),
      $(h) ? (g(), P(ce, { key: 1 }, [
        K("button", {
          class: "carousel-control-prev",
          type: "button",
          onClick: G
        }, [
          Ii,
          K("span", xi, Y(Q.controlsPrevText), 1)
        ]),
        K("button", {
          class: "carousel-control-next",
          type: "button",
          onClick: W
        }, [
          Li,
          K("span", Ni, Y(Q.controlsNextText), 1)
        ])
      ], 64)) : J("", !0)
    ], 42, Fi));
  }
}), Hi = ["innerHTML"], Ri = { key: 1 }, Mi = ["innerHTML"], Di = { key: 1 }, ji = /* @__PURE__ */ N({
  __name: "BCarouselSlide",
  props: {
    imgSrc: { default: void 0 },
    imgHeight: { default: void 0 },
    imgWidth: { default: void 0 },
    interval: { default: void 0 },
    background: { default: void 0 },
    caption: { default: void 0 },
    captionHtml: { default: void 0 },
    captionTag: { default: "h3" },
    contentTag: { default: "div" },
    contentVisibleUp: { default: void 0 },
    id: { default: void 0 },
    imgAlt: { default: void 0 },
    imgBlank: { type: [String, Boolean], default: !1 },
    imgBlankColor: { default: "transparent" },
    text: { default: void 0 },
    textHtml: { default: void 0 },
    textTag: { default: "p" }
  },
  setup(e) {
    const t = e, l = Fe(), a = Oe(ho, null), o = u(() => t.text || t.textHtml || !Ae(l.text)), n = u(() => t.caption || t.captionHtml || !Ae(l.caption)), s = u(() => o.value || n.value || !Ae(l.default)), r = u(() => ({
      background: `${t.background || (a == null ? void 0 : a.background.value) || "rgb(171, 171, 171)"} none repeat scroll 0% 0%`
    })), i = u(() => ({
      "d-none": t.contentVisibleUp !== void 0,
      [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0
    }));
    return (v, b) => (g(), P("div", {
      class: "carousel-item",
      style: ze(r.value)
    }, [
      O(v.$slots, "img", {}, () => {
        var h, p;
        return [
          be(al, {
            class: "d-block w-100",
            alt: v.imgAlt,
            src: v.imgSrc,
            width: v.imgWidth || ((h = $(a)) == null ? void 0 : h.width.value),
            height: v.imgHeight || ((p = $(a)) == null ? void 0 : p.height.value),
            blank: v.imgBlank,
            "blank-color": v.imgBlankColor
          }, null, 8, ["alt", "src", "width", "height", "blank", "blank-color"])
        ];
      }),
      s.value ? (g(), M(le(v.contentTag), {
        key: 0,
        class: H(["carousel-caption", i.value])
      }, {
        default: j(() => [
          n.value ? (g(), M(le(v.captionTag), { key: 0 }, {
            default: j(() => [
              O(v.$slots, "caption", {}, () => [
                v.captionHtml ? (g(), P("span", {
                  key: 0,
                  innerHTML: v.captionHtml
                }, null, 8, Hi)) : (g(), P("span", Ri, Y(v.caption), 1))
              ])
            ]),
            _: 3
          })) : J("", !0),
          o.value ? (g(), M(le(v.textTag), { key: 1 }, {
            default: j(() => [
              O(v.$slots, "text", {}, () => [
                v.textHtml ? (g(), P("span", {
                  key: 0,
                  innerHTML: v.textHtml
                }, null, 8, Mi)) : (g(), P("span", Di, Y(v.text), 1))
              ])
            ]),
            _: 3
          })) : J("", !0),
          O(v.$slots, "default")
        ]),
        _: 3
      }, 8, ["class"])) : J("", !0)
    ], 4));
  }
}), Nl = da("", [], { type: [Boolean, String, Number], default: !1 }), zl = da("offset", [""], { type: [String, Number], default: null }), Hl = da("order", [""], { type: [String, Number], default: null }), qi = N({
  name: "BCol",
  slots: Object,
  props: {
    col: { type: [Boolean, String], default: !1 },
    // Generic flexbox .col (xs)
    cols: { type: [String, Number], default: null },
    // .col-[1-12]|auto (xs)
    ...Nl,
    offset: { type: [String, Number], default: null },
    ...zl,
    order: { type: [String, Number], default: null },
    ...Hl,
    alignSelf: { type: String, default: null },
    tag: { type: String, default: "div" }
  },
  setup(e) {
    const t = [
      { content: Nl, propPrefix: "cols", classPrefix: "col" },
      { content: zl, propPrefix: "offset" },
      { content: Hl, propPrefix: "order" }
    ], l = d(() => e.col), a = u(
      () => t.flatMap((n) => bo(e, n.content, n.propPrefix, n.classPrefix))
    );
    return {
      computedClasses: u(() => [
        a.value,
        {
          col: l.value || !a.value.some((n) => /^col-/.test(n)) && !e.cols,
          [`col-${e.cols}`]: !!e.cols,
          [`offset-${e.offset}`]: !!e.offset,
          [`order-${e.order}`]: !!e.order,
          [`align-self-${e.alignSelf}`]: !!e.alignSelf
        }
      ])
    };
  }
}), ll = (e, t) => {
  const l = e.__vccOpts || e;
  for (const [a, o] of t)
    l[a] = o;
  return l;
};
function Gi(e, t, l, a, o, n) {
  return g(), M(le(e.tag), {
    class: H(e.computedClasses)
  }, {
    default: j(() => [
      O(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const Pt = /* @__PURE__ */ ll(qi, [["render", Gi]]), pt = {
  autoHide: !0,
  delay: 5e3,
  noCloseButton: !1,
  pos: "top-right",
  value: !0
};
class Rl {
  constructor(t) {
    Te(this, "vm");
    Te(this, "containerPositions");
    Gn(t) ? this.vm = t : this.vm = St(t), this.containerPositions = u(() => {
      const l = /* @__PURE__ */ new Set([]);
      return this.vm.toasts.map((a) => {
        a.options.pos && l.add(a.options.pos);
      }), l;
    });
  }
  toasts(t) {
    return t ? u(
      () => this.vm.toasts.filter((l) => {
        if (l.options.pos === t && l.options.value)
          return l;
      })
    ) : u(() => this.vm.toasts);
  }
  remove(...t) {
    this.vm.toasts = this.vm.toasts.filter((l) => {
      if (l.options.id && !t.includes(l.options.id))
        return l;
    });
  }
  isRoot() {
    return this.vm.root ?? !1;
  }
  show(t, l = pt) {
    const a = { id: at(), ...pt, ...l }, o = {
      options: St(a),
      content: t
    };
    return this.vm.toasts.push(o), o;
  }
  info(t, l = pt) {
    return this.show(t, { variant: "info", ...l });
  }
  danger(t, l = pt) {
    return this.show(t, { variant: "danger", ...l });
  }
  warning(t, l = pt) {
    return this.show(t, { variant: "warning", ...l });
  }
  success(t, l = pt) {
    return this.show(t, { variant: "success", ...l });
  }
  hide() {
  }
}
class Wi {
  constructor() {
    Te(this, "vms");
    Te(this, "rootInstance");
    Te(this, "useToast", gn);
    this.vms = {};
  }
  getOrCreateViewModel(t) {
    if (!t) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      const l = { root: !0, toasts: [], container: void 0, id: Symbol("toast") };
      return this.rootInstance = l.id, this.vms[l.id] = l, l;
    }
    if (t.root) {
      if (this.rootInstance)
        return this.vms[this.rootInstance];
      this.rootInstance = t.id;
    }
    return this.vms[t.id] = t, t;
  }
  getVM(t) {
    if (!t && this.rootInstance)
      return this.vms[this.rootInstance];
    if (t)
      return this.vms[t];
  }
}
const Ta = Symbol("toast"), mn = Symbol("toastFetch"), Ui = {
  container: void 0,
  toasts: [],
  root: !1
};
function Xi() {
  return Oe(mn);
}
function gn(e, t = Ta) {
  const l = Oe(Xi());
  if (!e)
    return new Rl(l.getOrCreateViewModel());
  const a = { id: Symbol("toastInstance") }, o = { ...Ui, ...a, ...e }, n = l.getOrCreateViewModel(o);
  return new Rl(n);
}
const yn = {
  install: (e, t) => {
    var a;
    const l = typeof (t == null ? void 0 : t.BToast) == "object" ? ((a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) ?? Ta : Ta;
    e.provide(mn, l), e.provide(l, new Wi());
  }
}, Ki = "toast-title", Ml = 1e3, bn = N({
  components: { BLink: Xe },
  props: {
    ...fi,
    delay: { type: Number, default: 5e3 },
    bodyClass: { type: String, default: void 0 },
    body: { type: [Object, String], default: void 0 },
    headerClass: { type: String, default: void 0 },
    headerTag: { type: String, default: "div" },
    animation: { type: [Boolean, String], default: !0 },
    id: { type: String, default: void 0 },
    // Switches role to 'status' and aria-live to 'polite'
    isStatus: { type: [Boolean, String], default: !1 },
    autoHide: { type: [Boolean, String], default: !0 },
    noCloseButton: { type: [Boolean, String], default: !1 },
    noFade: { type: [Boolean, String], default: !1 },
    noHoverPause: { type: [Boolean, String], default: !1 },
    solid: { type: [Boolean, String], default: !1 },
    // Render the toast in place, rather than in a portal-target
    static: { type: [Boolean, String], default: !1 },
    title: { type: String, default: void 0 },
    modelValue: { type: [Boolean, String], default: !1 },
    toastClass: { type: Array, default: void 0 },
    variant: { type: String, default: null }
  },
  emits: ["destroyed", "update:modelValue"],
  setup(e, { emit: t, slots: l }) {
    d(() => e.animation);
    const a = d(() => e.isStatus), o = d(() => e.autoHide), n = d(() => e.noCloseButton), s = d(() => e.noFade), r = d(() => e.noHoverPause);
    d(() => e.solid), d(() => e.static);
    const i = d(() => e.modelValue), v = R(!1), b = R(!1), h = R(!1), p = u(() => ({
      [`b-toast-${e.variant}`]: e.variant !== null,
      show: h.value || v.value
    }));
    let B, S, m;
    const A = () => {
      typeof B > "u" || (clearTimeout(B), B = void 0);
    }, y = u(
      () => (
        // Minimum supported duration is 1 second
        Math.max(lt(e.delay, 0), Ml)
      )
    ), k = () => {
      i.value && (S = m = 0, A(), b.value = !0, jt(() => {
        h.value = !1;
      }));
    }, w = () => {
      A(), t("update:modelValue", !0), S = m = 0, b.value = !1, Ce(() => {
        jt(() => {
          h.value = !0;
        });
      });
    }, _ = () => {
      if (!o.value || r.value || !B || m)
        return;
      const E = Date.now() - S;
      E > 0 && (A(), m = Math.max(y.value - E, Ml));
    }, C = () => {
      (!o.value || r.value || !m) && (m = S = 0), T();
    };
    oe(i, (E) => {
      E ? w() : k();
    });
    const T = () => {
      A(), o.value && (B = setTimeout(k, m || y.value), S = Date.now(), m = 0);
    }, c = () => {
      v.value = !0, t("update:modelValue", !0);
    }, V = () => {
      v.value = !1, T();
    }, F = () => {
      v.value = !0;
    }, f = () => {
      v.value = !1, m = S = 0, t("update:modelValue", !1);
    };
    Wn(() => {
      A(), o.value && t("destroyed", e.id);
    }), He(() => {
      Ce(() => {
        i.value && jt(() => {
          w();
        });
      });
    });
    const I = () => {
      Ce(() => {
        jt(() => {
          k();
        });
      });
    };
    return () => {
      const E = () => {
        const z = [], Z = Ne(Ki, { hide: k }, l);
        Z ? z.push(ie(Z)) : e.title && z.push(ie("strong", { class: "me-auto" }, e.title)), !n.value && z.length !== 0 && z.push(
          ie(Ot, {
            class: ["btn-close"],
            onClick: () => {
              k();
            }
          })
        );
        const te = [];
        if (z.length > 0 && te.push(
          ie(
            e.headerTag,
            {
              class: "toast-header"
            },
            { default: () => z }
          )
        ), Ne("default", { hide: k }, l) || e.body) {
          const G = ie(
            wt(e) ? "b-link" : "div",
            {
              class: ["toast-body", e.bodyClass],
              onClick: wt(e) ? { click: I } : {}
            },
            Ne("default", { hide: k }, l) || e.body
          );
          te.push(G);
        }
        return ie(
          "div",
          {
            class: ["toast", e.toastClass, p.value],
            tabindex: "0"
          },
          te
        );
      };
      return ie(
        "div",
        {
          class: ["b-toast"],
          id: e.id,
          role: b.value ? null : a.value ? "status" : "alert",
          "aria-live": b.value ? null : a.value ? "polite" : "assertive",
          "aria-atomic": b.value ? null : !0,
          onmouseenter: _,
          onmouseleave: C
        },
        [
          ie(
            At,
            {
              noFade: s.value,
              onAfterEnter: V,
              onBeforeEnter: c,
              onAfterLeave: f,
              onBeforeLeave: F
            },
            () => [h.value ? E() : ""]
          )
        ]
      );
    };
  }
}), Va = /* @__PURE__ */ N({
  __name: "BToaster",
  props: {
    position: { default: "top-right" },
    instance: { default: void 0 }
  },
  setup(e) {
    const t = e, l = {
      "top-left": "top-0 start-0",
      "top-center": "top-0 start-50 translate-middle-x",
      "top-right": "top-0 end-0",
      "middle-left": "top-50 start-0 translate-middle-y",
      "middle-center": "top-50 start-50 translate-middle",
      "middle-right": "top-50 end-0 translate-middle-y",
      "bottom-left": "bottom-0 start-0",
      "bottom-center": "bottom-0 start-50 translate-middle-x",
      "bottom-right": "bottom-0 end-0"
    }, a = u(() => l[t.position]), o = (n) => {
      var s;
      (s = t.instance) == null || s.remove(n);
    };
    return (n, s) => {
      var r;
      return g(), P("div", {
        class: H([[a.value], "b-toaster position-fixed p-3"]),
        style: { "z-index": "11" }
      }, [
        (g(!0), P(ce, null, he((r = n.instance) == null ? void 0 : r.toasts(n.position).value, (i) => (g(), M(bn, {
          id: i.options.id,
          key: i.options.id,
          modelValue: i.options.value,
          "onUpdate:modelValue": (v) => i.options.value = v,
          "auto-hide": i.options.autoHide,
          delay: i.options.delay,
          "no-close-button": i.options.noCloseButton,
          title: i.content.title,
          body: i.content.body,
          component: i.content.body,
          variant: i.options.variant,
          onDestroyed: o
        }, null, 8, ["id", "modelValue", "onUpdate:modelValue", "auto-hide", "delay", "no-close-button", "title", "body", "component", "variant"]))), 128))
      ], 2);
    };
  }
}), Yi = N({
  slots: Object,
  props: {
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    fluid: { type: [Boolean, String], default: !1 },
    toast: { type: Object, default: void 0 },
    position: { type: String, default: void 0 }
  },
  setup(e, { slots: t, expose: l }) {
    const a = R();
    let o;
    const n = u(() => ({
      container: !e.fluid,
      "container-fluid": typeof e.fluid == "boolean" && e.fluid,
      [`container-${e.fluid}`]: typeof e.fluid == "string",
      [`gx-${e.gutterX}`]: e.gutterX !== null,
      [`gy-${e.gutterY}`]: e.gutterY !== null
    }));
    return He(() => {
      e.toast;
    }), e.toast && (o = gn({ container: a, root: e.toast.root }), l({
      // ...toastInstance?.useMethods,
    })), () => {
      var r;
      const s = [];
      return o == null || o.containerPositions.value.forEach((i) => {
        s.push(ie(Va, { key: i, instance: o, position: i }));
      }), ie("div", { class: [n.value, e.position], ref: a }, [
        ...s,
        (r = t.default) == null ? void 0 : r.call(t)
      ]);
    };
  },
  methods: {}
}), Ji = { class: "visually-hidden" }, Zi = ["aria-labelledby", "role"], hn = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BDropdown",
  props: {
    ariaLabel: { default: void 0 },
    id: { default: void 0 },
    menuClass: { default: void 0 },
    size: { default: "md" },
    splitClass: { default: void 0 },
    splitVariant: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    autoClose: { type: [Boolean, String], default: !0 },
    block: { type: [String, Boolean], default: !1 },
    dark: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    isNav: { type: [String, Boolean], default: !1 },
    dropup: { type: [String, Boolean], default: !1 },
    dropend: { type: [String, Boolean], default: !1 },
    dropstart: { type: [String, Boolean], default: !1 },
    center: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    noFlip: { type: [String, Boolean], default: !1 },
    noShift: { type: [String, Boolean], default: !1 },
    offset: { default: 0 },
    role: { default: "menu" },
    split: { type: [String, Boolean], default: !1 },
    splitButtonType: { default: "button" },
    splitHref: { default: void 0 },
    splitDisabled: { type: [String, Boolean], default: void 0 },
    noCaret: { type: [String, Boolean], default: !1 },
    toggleText: { default: "Toggle dropdown" },
    variant: { default: "secondary" },
    modelValue: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    strategy: { default: "absolute" },
    floatingMiddleware: { default: void 0 },
    splitTo: { default: void 0 }
  },
  emits: ["show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "click", "toggle", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = _e(() => a.id, "dropdown"), n = Se(a, "modelValue", l, { passive: !0 }), s = d(n), r = d(() => a.block), i = d(() => a.dark), v = d(() => a.dropup), b = d(() => a.dropend), h = d(() => a.isNav), p = d(() => a.dropstart), B = d(() => a.center), S = d(() => a.end), m = d(() => a.split), A = d(() => a.noCaret), y = d(() => a.noFlip), k = d(() => a.noShift), w = d(() => a.lazy), _ = d(() => a.splitDisabled), C = u(
      () => typeof a.offset == "string" || typeof a.offset == "number" ? a.offset : NaN
    ), T = bt(C, { method: "parseInt", nanToZero: !0 }), c = R(null), V = R(null), F = R(null), f = u(() => m.value ? V.value : F.value), I = u(
      () => ai({
        top: v.value,
        start: p.value,
        end: b.value,
        alignCenter: B.value,
        alignEnd: S.value
      })
    ), E = u(() => {
      if (a.floatingMiddleware !== void 0)
        return a.floatingMiddleware;
      const L = typeof a.offset == "string" || typeof a.offset == "number" ? T.value : a.offset, x = [Fo(L)];
      return y.value === !1 && x.push(Oo()), k.value === !1 && x.push(Po()), x;
    }), { x: z, y: Z, strategy: te, update: G } = Mo(f, c, {
      placement: I,
      middleware: E,
      strategy: a.strategy,
      whileElementsMounted: Ho
    }), W = u(() => ({
      "d-grid": r.value,
      dropup: v.value,
      dropend: b.value,
      dropstart: p.value,
      "d-flex": r.value && m.value
    })), X = u(() => [
      m.value ? a.splitClass : a.toggleClass,
      {
        "nav-link": h.value,
        "dropdown-toggle": !m.value,
        "dropdown-toggle-no-caret": A.value && !m.value,
        "w-100": m.value && r.value,
        show: m.value ? void 0 : s.value
      }
    ]), ve = u(() => [
      a.menuClass,
      {
        "dropdown-menu-dark": i.value
      }
    ]), ge = u(() => ({
      "aria-label": a.ariaLabel,
      "aria-expanded": m.value ? void 0 : s.value,
      "aria-haspopup": m.value ? void 0 : "menu",
      href: m.value ? a.splitHref : void 0,
      to: m.value && a.splitTo ? a.splitTo : void 0
    })), pe = () => {
      l("toggle");
      const L = s.value, x = new Ge(L ? "hide" : "show");
      if (l(L ? "hide" : "show", x), x.defaultPrevented) {
        l(L ? "hide-prevented" : "show-prevented");
        return;
      }
      n.value = !L, l(L ? "hidden" : "shown");
    }, me = (L) => {
      m.value ? l("click", L) : pe();
    };
    Uo(
      c,
      () => {
        s.value && (a.autoClose === !0 || a.autoClose === "outside") && de();
      },
      { ignore: [V, F] }
    );
    const q = () => {
      s.value && (a.autoClose === !0 || a.autoClose === "inside") && de();
    }, Q = () => {
      n.value = !1;
    }, re = () => {
      n.value = !0;
    }, de = () => {
      n.value = !s.value;
    };
    return oe(s, G), t({
      close: Q,
      open: re,
      toggle: de
    }), De(To, {
      id: o,
      open: re,
      close: Q,
      toggle: de,
      visible: s,
      isNav: h
    }), (L, x) => (g(), P(ce, null, [
      K("div", ee({
        class: [W.value, "btn-group"]
      }, L.$attrs), [
        be(kt, ee({
          id: $(o),
          ref_key: "splitButton",
          ref: F,
          variant: L.splitVariant || L.variant,
          size: L.size,
          class: X.value,
          disabled: $(_) || L.disabled,
          type: L.splitButtonType
        }, ge.value, {
          onClick: me,
          onKeydown: x[0] || (x[0] = It((D) => n.value = !$(s), ["esc"]))
        }), {
          default: j(() => [
            O(L.$slots, "button-content", {}, () => [
              ne(Y(L.text), 1)
            ])
          ]),
          _: 3
        }, 16, ["id", "variant", "size", "class", "disabled", "type"]),
        $(m) ? (g(), M(kt, {
          key: 0,
          ref_key: "button",
          ref: V,
          variant: L.variant,
          size: L.size,
          disabled: L.disabled,
          class: H([[L.toggleClass, $(s) ? "show" : void 0], "dropdown-toggle-split dropdown-toggle"]),
          "aria-expanded": $(s),
          "aria-haspopup": "menu",
          onClick: pe
        }, {
          default: j(() => [
            K("span", Ji, [
              O(L.$slots, "toggle-text", {}, () => [
                ne(Y(L.toggleText), 1)
              ])
            ])
          ]),
          _: 3
        }, 8, ["variant", "size", "disabled", "class", "aria-expanded"])) : J("", !0)
      ], 16),
      !$(w) || $(s) ? rt((g(), P("ul", {
        key: 0,
        ref_key: "floating",
        ref: c,
        style: ze({
          position: $(te) === "absolute" ? void 0 : "fixed",
          top: `${$(Z)}px`,
          left: `${$(z)}px`,
          width: "max-content"
        }),
        class: H(["dropdown-menu show", ve.value]),
        "aria-labelledby": $(o),
        role: L.role,
        onClick: q
      }, [
        O(L.$slots, "default")
      ], 14, Zi)), [
        [ua, $(w) || $(s)]
      ]) : J("", !0)
    ], 64));
  }
}), Qi = { role: "presentation" }, eu = /* @__PURE__ */ N({
  __name: "BDropdownDivider",
  props: {
    tag: { default: "hr" }
  },
  setup(e) {
    return (t, l) => (g(), P("li", Qi, [
      (g(), M(le(t.tag), {
        class: "dropdown-divider",
        role: "separator",
        "aria-orientation": "horizontal"
      }))
    ]));
  }
}), tu = { role: "presentation" }, au = { class: "px-4 py-3" }, lu = /* @__PURE__ */ N({
  __name: "BDropdownForm",
  setup(e) {
    return (t, l) => (g(), P("li", tu, [
      K("form", au, [
        O(t.$slots, "default")
      ])
    ]));
  }
}), ou = { role: "presentation" }, nu = ["id", "aria-describedby"], su = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BDropdownGroup",
  props: {
    id: { default: void 0 },
    ariaDescribedby: { default: void 0 },
    header: { default: void 0 },
    headerClass: { default: void 0 },
    headerTag: { default: "header" },
    headerVariant: { default: null }
  },
  setup(e) {
    const t = e, l = u(
      () => t.id ? `${t.id}_group_dd_header` : void 0
    ), a = u(
      () => t.headerTag === "header" ? void 0 : "heading"
    ), o = u(() => [
      t.headerClass,
      {
        [`text-${t.headerVariant}`]: t.headerVariant !== null
      }
    ]);
    return (n, s) => (g(), P("li", ou, [
      (g(), M(le(n.headerTag), {
        id: l.value,
        class: H(["dropdown-header", o.value]),
        role: a.value
      }, {
        default: j(() => [
          O(n.$slots, "header", {}, () => [
            ne(Y(n.header), 1)
          ])
        ]),
        _: 3
      }, 8, ["id", "class", "role"])),
      K("ul", ee({
        id: n.id,
        role: "group",
        class: "list-unstyled"
      }, n.$attrs, {
        "aria-describedby": n.ariaDescribedby || l.value
      }), [
        O(n.$slots, "default")
      ], 16, nu)
    ]));
  }
}), ru = { class: "dropdown-header" }, iu = /* @__PURE__ */ N({
  __name: "BDropdownHeader",
  setup(e) {
    return (t, l) => (g(), P("li", null, [
      K("h6", ru, [
        O(t.$slots, "default")
      ])
    ]));
  }
}), uu = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BDropdownItem",
  props: {
    href: { default: void 0 },
    linkClass: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    rel: { default: void 0 },
    target: { default: "_self" },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.active), o = d(() => l.disabled), n = za(), s = u(() => [
      l.linkClass,
      {
        active: a.value,
        disabled: o.value,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), r = u(
      () => l.href ? "a" : n.to ? Xe : "button"
    ), i = u(() => ({
      disabled: o.value,
      "aria-current": a.value ? !0 : null,
      href: r.value === "a" ? l.href : null,
      rel: l.rel,
      type: r.value === "button" ? "button" : null,
      target: l.target,
      ...n.to ? { activeClass: "active", ...n } : n
    })), v = Oe(Ga, null), b = Oe(To, null), h = Oe(Wa, null), p = (B) => {
      var S, m;
      t("click", B), h !== null && ((S = v == null ? void 0 : v.close) == null || S.call(v)), (m = b == null ? void 0 : b.close) == null || m.call(b);
    };
    return (B, S) => (g(), P("li", {
      role: "presentation",
      class: H(B.$attrs.class)
    }, [
      (g(), M(le(r.value), ee({
        class: ["dropdown-item", s.value]
      }, i.value, { onClick: p }), {
        default: j(() => [
          O(B.$slots, "default")
        ]),
        _: 3
      }, 16, ["class"]))
    ], 2));
  }
}), du = ["disabled"], cu = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BDropdownItemButton",
  props: {
    buttonClass: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    activeClass: { default: "active" },
    disabled: { type: [String, Boolean], default: !1 },
    variant: { default: null }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.active), o = d(() => l.disabled), n = u(() => [
      l.buttonClass,
      {
        [l.activeClass]: a.value,
        disabled: o.value,
        [`text-${l.variant}`]: l.variant !== null
      }
    ]), s = (r) => t("click", r);
    return (r, i) => (g(), P("li", {
      role: "presentation",
      class: H(r.$attrs.class)
    }, [
      K("button", {
        role: "menu",
        type: "button",
        class: H(["dropdown-item", n.value]),
        disabled: $(o),
        onClick: s
      }, [
        O(r.$slots, "default")
      ], 10, du)
    ], 2));
  }
}), fu = { role: "presentation" }, vu = { class: "px-4 py-1 mb-0 text-muted" }, pu = /* @__PURE__ */ N({
  __name: "BDropdownText",
  props: {
    text: { default: "" }
  },
  setup(e) {
    return (t, l) => (g(), P("li", fu, [
      K("p", vu, [
        O(t.$slots, "default", {}, () => [
          ne(Y(t.text), 1)
        ])
      ])
    ]));
  }
}), mu = ["id", "novalidate", "onSubmit"], Bn = /* @__PURE__ */ N({
  __name: "BForm",
  props: {
    id: { default: void 0 },
    floating: { type: [String, Boolean], default: !1 },
    novalidate: { type: [String, Boolean], default: !1 },
    validated: { type: [String, Boolean], default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.floating), o = d(() => l.novalidate), n = d(() => l.validated), s = u(() => ({
      "form-floating": a.value,
      "was-validated": n.value
    })), r = (i) => t("submit", i);
    return (i, v) => (g(), P("form", {
      id: i.id,
      novalidate: $(o),
      class: H(s.value),
      onSubmit: ot(r, ["prevent"])
    }, [
      O(i.$slots, "default")
    ], 42, mu));
  }
}), gu = { class: "form-floating" }, yu = ["for"], bu = /* @__PURE__ */ N({
  __name: "BFormFloatingLabel",
  props: {
    labelFor: { default: void 0 },
    label: { default: void 0 },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, l) => (g(), P("div", gu, [
      O(t.$slots, "default", {}, () => [
        ne(Y(t.text), 1)
      ]),
      K("label", { for: t.labelFor }, [
        O(t.$slots, "label", {}, () => [
          ne(Y(t.label), 1)
        ])
      ], 8, yu)
    ]));
  }
}), Aa = /* @__PURE__ */ N({
  __name: "BFormInvalidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    text: { default: void 0 },
    role: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    tag: { default: "div" },
    tooltip: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.forceShow), a = d(() => t.state), o = d(() => t.tooltip), n = u(
      () => l.value === !0 || a.value === !1
    ), s = u(() => ({
      "d-block": n.value,
      "invalid-feedback": !o.value,
      "invalid-tooltip": o.value
    })), r = u(() => ({
      id: t.id,
      role: t.role,
      "aria-live": t.ariaLive,
      "aria-atomic": t.ariaLive ? !0 : void 0
    }));
    return (i, v) => (g(), M(le(i.tag), ee({ class: s.value }, r.value), {
      default: j(() => [
        O(i.$slots, "default", {}, () => [
          ne(Y(i.text), 1)
        ])
      ]),
      _: 3
    }, 16, ["class"]));
  }
}), Jt = /* @__PURE__ */ N({
  __name: "BFormRow",
  props: {
    tag: { default: "div" }
  },
  setup(e) {
    return (t, l) => (g(), M(le(t.tag), { class: "row d-flex flex-wrap" }, {
      default: j(() => [
        O(t.$slots, "default")
      ]),
      _: 3
    }));
  }
}), Oa = /* @__PURE__ */ N({
  __name: "BFormText",
  props: {
    id: { default: void 0 },
    inline: { type: [String, Boolean], default: !1 },
    tag: { default: "small" },
    text: { default: void 0 },
    textVariant: { default: "muted" }
  },
  setup(e) {
    const t = e, l = d(() => t.inline), a = u(() => ({
      [`text-${t.textVariant}`]: t.textVariant !== null,
      "form-text": !l.value
    }));
    return (o, n) => (g(), M(le(o.tag), {
      id: o.id,
      class: H(a.value)
    }, {
      default: j(() => [
        O(o.$slots, "default", {}, () => [
          ne(Y(o.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Fa = /* @__PURE__ */ N({
  __name: "BFormValidFeedback",
  props: {
    ariaLive: { default: void 0 },
    forceShow: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    role: { default: void 0 },
    text: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    tag: { default: "div" },
    tooltip: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.forceShow), a = d(() => t.state), o = d(() => t.tooltip), n = u(
      () => l.value === !0 || a.value === !0
    ), s = u(() => ({
      "d-block": n.value,
      "valid-feedback": !o.value,
      "valid-tooltip": o.value
    })), r = u(() => t.ariaLive ? !0 : void 0);
    return (i, v) => (g(), M(le(i.tag), {
      id: i.id,
      role: i.role,
      "aria-live": i.ariaLive,
      "aria-atomic": r.value,
      class: H(s.value)
    }, {
      default: j(() => [
        O(i.$slots, "default", {}, () => [
          ne(Y(i.text), 1)
        ])
      ]),
      _: 3
    }, 8, ["id", "role", "aria-live", "aria-atomic", "class"]));
  }
}), hu = ["id", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "aria-required", "value", "indeterminate"], Bu = ["for"], Sn = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BFormCheckbox",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledBy: { default: void 0 },
    form: { default: void 0 },
    indeterminate: { type: [String, Boolean], default: void 0 },
    name: { default: void 0 },
    id: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    plain: { type: [String, Boolean], default: !1 },
    button: { type: [String, Boolean], default: !1 },
    buttonGroup: { type: [String, Boolean], default: !1 },
    switch: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: null },
    inline: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: void 0 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    uncheckedValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: !1 },
    value: { type: [Array, Set, Boolean, String, Object, Number, null], default: !0 },
    modelValue: { type: [Array, Set, Boolean, String, Object, Number, null], default: void 0 }
  },
  emits: ["update:modelValue", "input", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Fe(), n = Se(a, "modelValue", l, { passive: !0 }), s = _e(() => a.id, "form-check"), r = d(() => a.indeterminate), i = d(() => a.autofocus), v = d(() => a.plain), b = d(() => a.button), h = d(() => a.buttonGroup), p = d(() => a.switch), B = d(() => a.disabled), S = d(() => a.inline), m = d(() => a.required), A = d(() => a.state), y = Oe(Co, null), k = R(null), { focused: w } = Ee(k, {
      initialValue: i.value
    }), _ = u(() => !Ae(o.default)), C = u({
      get: () => y !== null ? y.modelValue.value.map((E) => JSON.stringify(E)).includes(JSON.stringify(a.value)) : JSON.stringify(n.value) === JSON.stringify(a.value),
      set: (E) => {
        const z = E ? a.value : a.uncheckedValue;
        l("input", z), n.value = z, Ce(() => {
          l("change", z);
        });
      }
    });
    oe(n, (E) => {
      if (y !== null) {
        if (E === !1) {
          y.remove(a.value);
          return;
        }
        y.set(a.value);
      }
    });
    const T = u(
      () => !!(a.name ?? (y == null ? void 0 : y.name.value)) && (m.value || (y == null ? void 0 : y.required.value))
    ), c = u(
      () => h.value || ((y == null ? void 0 : y.buttons.value) ?? !1)
    ), V = u(() => ({
      plain: v.value || ((y == null ? void 0 : y.plain.value) ?? !1),
      button: b.value || ((y == null ? void 0 : y.buttons.value) ?? !1),
      inline: S.value || ((y == null ? void 0 : y.inline.value) ?? !1),
      switch: p.value || ((y == null ? void 0 : y.switch.value) ?? !1),
      state: A.value || (y == null ? void 0 : y.state.value),
      size: a.size !== void 0 ? a.size : (y == null ? void 0 : y.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (y == null ? void 0 : y.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), F = Yo(V), f = Jo(V), I = Zo(V);
    return t({
      focus: () => {
        w.value = !0;
      },
      blur: () => {
        w.value = !1;
      }
    }), (E, z) => (g(), M(Qa, {
      skip: c.value,
      class: H($(F))
    }, {
      default: j(() => {
        var Z, te, G;
        return [
          rt(K("input", ee({ id: $(s) }, E.$attrs, {
            ref_key: "input",
            ref: k,
            "onUpdate:modelValue": z[0] || (z[0] = (W) => C.value = W),
            class: $(f),
            type: "checkbox",
            disabled: $(B) || ((Z = $(y)) == null ? void 0 : Z.disabled.value),
            required: T.value || void 0,
            name: E.name || ((te = $(y)) == null ? void 0 : te.name.value),
            form: E.form || ((G = $(y)) == null ? void 0 : G.form.value),
            "aria-label": E.ariaLabel,
            "aria-labelledby": E.ariaLabelledBy,
            "aria-required": T.value || void 0,
            value: E.value,
            indeterminate: $(r)
          }), null, 16, hu), [
            [Un, C.value]
          ]),
          _.value || $(v) === !1 ? (g(), P("label", {
            key: 0,
            for: $(s),
            class: H($(I))
          }, [
            O(E.$slots, "default")
          ], 10, Bu)) : J("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Su = ["id"], wu = ["innerHTML"], _u = ["textContent"], $u = /* @__PURE__ */ N({
  __name: "BFormCheckboxGroup",
  props: {
    id: { default: void 0 },
    form: { default: void 0 },
    modelValue: { default: () => [] },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    name: { default: void 0 },
    options: { default: () => [] },
    plain: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    size: { default: "md" },
    stacked: { type: [String, Boolean], default: !1 },
    state: { type: [String, Boolean, null], default: null },
    switches: { type: [String, Boolean], default: !1 },
    textField: { default: "text" },
    validated: { type: [String, Boolean], default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "modelValue", l), n = _e(() => a.id, "checkbox"), s = _e(() => a.name, "checkbox"), r = d(() => a.autofocus), i = d(() => a.buttons), v = d(() => a.disabled), b = d(() => a.plain), h = d(() => a.required), p = d(() => a.stacked), B = d(() => a.state), S = d(() => a.switches), m = d(() => a.validated), A = R(null), { focused: y } = Ee(A, {
      initialValue: r.value
    });
    De(Co, {
      set: (T) => {
        const c = [...o.value];
        c.push(T), l("input", c), o.value = c, Ce(() => {
          l("change", c);
        });
      },
      remove: (T) => {
        const c = [...o.value];
        c.splice(o.value.indexOf(T), 1), l("input", c), o.value = c, Ce(() => {
          l("change", c);
        });
      },
      modelValue: u(() => o.value),
      switch: S,
      buttonVariant: ye(ke(a, "buttonVariant")),
      form: ye(ke(a, "form")),
      name: s,
      state: B,
      plain: b,
      size: ye(ke(a, "size")),
      inline: u(() => !p.value),
      required: h,
      buttons: i,
      disabled: v
    });
    const k = u(
      () => a.options.map(
        (T, c) => typeof T == "string" || typeof T == "number" ? {
          props: {
            value: T,
            disabled: v.value
          },
          text: T.toString(),
          html: void 0,
          self: Symbol(`checkboxGroupOptionItem${c}`)
        } : {
          props: {
            value: T[a.valueField],
            disabled: T[a.disabledField],
            ...T.props ? T.props : {}
          },
          text: T[a.textField],
          html: T[a.htmlField],
          self: Symbol(`checkboxGroupOptionItem${c}`)
        }
      )
    ), w = u(() => ({
      required: h.value,
      ariaInvalid: a.ariaInvalid,
      state: B.value,
      validated: m.value,
      buttons: i.value,
      stacked: p.value,
      size: a.size
    })), _ = Qo(w), C = en(w);
    return t({
      focus: () => {
        y.value = !0;
      },
      blur: () => {
        y.value = !1;
      }
    }), (T, c) => (g(), P("div", ee($(_), {
      id: $(n),
      ref_key: "element",
      ref: A,
      role: "group",
      class: [$(C), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      O(T.$slots, "first"),
      (g(!0), P(ce, null, he(k.value, (V) => (g(), M(Sn, ee({
        key: V.self
      }, V.props), {
        default: j(() => [
          V.html ? (g(), P("span", {
            key: 0,
            innerHTML: V.html
          }, null, 8, wu)) : (g(), P("span", {
            key: 1,
            textContent: Y(V.text)
          }, null, 8, _u))
        ]),
        _: 2
      }, 1040))), 128)),
      O(T.$slots, "default")
    ], 16, Su));
  }
}), Cu = ["for"], ku = ["id", "form", "name", "multiple", "disabled", "capture", "accept", "required", "aria-required", "directory", "webkitdirectory"], Tu = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BFormFile",
  props: {
    accept: { default: "" },
    autofocus: { type: [String, Boolean], default: !1 },
    capture: { type: [Boolean, String], default: !1 },
    directory: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    form: { default: void 0 },
    id: { default: void 0 },
    multiple: { type: [String, Boolean], default: !1 },
    name: { default: void 0 },
    noDrop: { type: [String, Boolean], default: !1 },
    noTraverse: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    modelValue: { default: null },
    label: { default: "" },
    labelClasses: { default: void 0 }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Fe(), n = Se(a, "modelValue", l), s = _e(() => a.id), r = d(() => a.autofocus), i = d(() => a.directory), v = d(() => a.disabled), b = d(() => a.multiple), h = d(() => a.noDrop);
    d(() => a.noTraverse);
    const p = d(() => a.required), B = d(() => a.state), S = Vt(B), m = R(null), { focused: A } = Ee(m, { initialValue: r.value }), y = u(() => !Ae(o.label)), k = u(
      () => typeof a.accept == "string" ? a.accept : a.accept.join(",")
    ), w = u(
      () => a.capture === "user" || a.capture === "environment" ? a.capture : Ra(a.capture)
    ), _ = u(() => [
      S.value,
      {
        [`form-control-${a.size}`]: a.size !== void 0
      }
    ]), C = (V) => {
      var f, I;
      const F = ((f = m.value) == null ? void 0 : f.files) === null || ((I = m.value) == null ? void 0 : I.files) === void 0 ? null : [...m.value.files];
      n.value = F === null ? null : b.value === !0 ? F : F[0], l("change", V);
    }, T = (V) => {
      h.value === !0 && V.preventDefault();
    }, c = () => {
      n.value = null;
    };
    return oe(n, (V) => {
      V === null && m.value !== null && (m.value.value = "");
    }), t({
      focus: () => {
        A.value = !0;
      },
      blur: () => {
        A.value = !1;
      },
      reset: c
    }), (V, F) => (g(), P(ce, null, [
      y.value || V.label ? (g(), P("label", {
        key: 0,
        for: $(s),
        class: H(["form-label", V.labelClasses])
      }, [
        O(V.$slots, "label", {}, () => [
          ne(Y(V.label), 1)
        ])
      ], 10, Cu)) : J("", !0),
      K("input", ee({ id: $(s) }, V.$attrs, {
        ref_key: "input",
        ref: m,
        type: "file",
        class: ["form-control", _.value],
        form: V.form,
        name: V.name,
        multiple: $(b),
        disabled: $(v),
        capture: w.value,
        accept: k.value || void 0,
        required: $(p) || void 0,
        "aria-required": $(p) || void 0,
        directory: $(i),
        webkitdirectory: $(i),
        onChange: C,
        onDrop: T
      }), null, 16, ku)
    ], 64));
  }
}), wn = ["input", "select", "textarea"], Vu = wn.map((e) => `${e}:not([disabled])`).join(), Au = [...wn, "a", "button", "label"], Ou = "label", Fu = "invalid-feedback", Pu = "valid-feedback", Eu = "description", Iu = "default", xu = N({
  components: { BCol: Pt, BFormInvalidFeedback: Aa, BFormRow: Jt, BFormText: Oa, BFormValidFeedback: Fa },
  props: {
    contentCols: { type: [Boolean, String, Number], default: void 0 },
    contentColsLg: { type: [Boolean, String, Number], default: void 0 },
    contentColsMd: { type: [Boolean, String, Number], default: void 0 },
    contentColsSm: { type: [Boolean, String, Number], default: void 0 },
    contentColsXl: { type: [Boolean, String, Number], default: void 0 },
    description: { type: [String], default: void 0 },
    disabled: { type: [Boolean, String], default: !1 },
    feedbackAriaLive: { type: String, default: "assertive" },
    id: { type: String, default: void 0 },
    invalidFeedback: { type: String, default: void 0 },
    label: { type: String, default: void 0 },
    labelAlign: { type: [Boolean, String, Number], default: void 0 },
    labelAlignLg: { type: [Boolean, String, Number], default: void 0 },
    labelAlignMd: { type: [Boolean, String, Number], default: void 0 },
    labelAlignSm: { type: [Boolean, String, Number], default: void 0 },
    labelAlignXl: { type: [Boolean, String, Number], default: void 0 },
    labelClass: { type: [Array, Object, String], default: void 0 },
    labelCols: { type: [Boolean, String, Number], default: void 0 },
    labelColsLg: { type: [Boolean, String, Number], default: void 0 },
    labelColsMd: { type: [Boolean, String, Number], default: void 0 },
    labelColsSm: { type: [Boolean, String, Number], default: void 0 },
    labelColsXl: { type: [Boolean, String, Number], default: void 0 },
    labelFor: { type: String, default: void 0 },
    labelSize: { type: String, default: void 0 },
    labelSrOnly: { type: [Boolean, String], default: !1 },
    state: { type: [Boolean, String], default: null },
    tooltip: { type: [Boolean, String], default: !1 },
    validFeedback: { type: String, default: void 0 },
    validated: { type: [Boolean, String], default: !1 },
    floating: { type: [Boolean, String], default: !1 }
  },
  setup(e, { attrs: t }) {
    const l = d(() => e.disabled), a = d(() => e.labelSrOnly), o = d(() => e.state), n = d(() => e.tooltip), s = d(() => e.validated), r = d(() => e.floating), i = null, v = ["xs", "sm", "md", "lg", "xl"], b = (C, T) => v.reduce((c, V) => {
      const F = vl(V === "xs" ? "" : V, `${T}Align`), f = C[F] || null;
      return f && (V === "xs" ? c.push(`text-${f}`) : c.push(`text-${V}-${f}`)), c;
    }, []), h = (C, T) => v.reduce((c, V) => {
      const F = vl(V === "xs" ? "" : V, `${T}Cols`);
      let f = C[F];
      return f = f === "" ? !0 : f || !1, typeof f != "boolean" && f !== "auto" && (f = Vs(f, 0), f = f > 0 ? f : !1), f && (V === "xs" ? c[typeof f == "boolean" ? "col" : "cols"] = f : c[V || (typeof f == "boolean" ? "col" : "cols")] = f), c;
    }, {}), p = R(), B = (C, T = null) => {
      if (ja && e.labelFor) {
        const c = go(`#${is(e.labelFor)}`, p);
        if (c) {
          const V = "aria-describedby", F = (C || "").split(Kt), f = (T || "").split(Kt), I = (qa(c, V) || "").split(Kt).filter((E) => !f.includes(E)).concat(F).filter((E, z, Z) => Z.indexOf(E) === z).filter((E) => E).join(" ").trim();
          I ? $s(c, V, I) : Cs(c, V);
        }
      }
    }, S = u(() => h(e, "content")), m = u(() => b(e, "label")), A = u(() => h(e, "label")), y = u(
      () => (
        // Determine if the form group will be rendered horizontal
        // based on the existence of 'content-col' or 'label-col' props
        Object.keys(S.value).length > 0 || Object.keys(A.value).length > 0
      )
    ), k = Vt(o), w = u(
      () => ca(t.ariaInvalid, o.value)
    );
    return oe(
      () => i,
      (C, T) => {
        C !== T && B(C, T);
      }
    ), He(() => {
      Ce(() => {
        B(i);
      });
    }), {
      disabledBoolean: l,
      labelSrOnlyBoolean: a,
      stateBoolean: o,
      tooltipBoolean: n,
      validatedBoolean: s,
      floatingBoolean: r,
      ariaDescribedby: i,
      computedAriaInvalid: w,
      contentColProps: S,
      isHorizontal: y,
      labelAlignClasses: m,
      labelColProps: A,
      onLegendClick: (C) => {
        if (e.labelFor)
          return;
        const { target: T } = C, c = T ? T.tagName : "";
        if (Au.indexOf(c) !== -1)
          return;
        const V = ws(Vu, p).filter(Ss);
        V.length === 1 && hs(V[0]);
      },
      stateClass: k
    };
  },
  render() {
    const e = this.$props, t = this.$slots, l = _e(), a = !e.labelFor;
    let o = null;
    const n = Ne(Ou, {}, t) || e.label, s = n ? at("_BV_label_") : null;
    if (n || this.isHorizontal) {
      const _ = a ? "legend" : "label";
      if (this.labelSrOnlyBoolean)
        n && (o = ie(
          _,
          {
            class: "visually-hidden",
            id: s,
            for: e.labelFor || null
          },
          n
        )), this.isHorizontal ? o = ie(Pt, this.labelColProps, { default: () => o }) : o = ie("div", {}, [o]);
      else {
        const C = {
          onClick: a ? this.onLegendClick : null,
          ...this.isHorizontal ? this.labelColProps : {},
          tag: this.isHorizontal ? _ : null,
          id: s,
          for: e.labelFor || null,
          tabIndex: a ? "-1" : null,
          class: [
            this.isHorizontal ? "col-form-label" : "form-label",
            {
              "bv-no-focus-ring": a,
              "col-form-label": this.isHorizontal || a,
              "pt-0": !this.isHorizontal && a,
              "d-block": !this.isHorizontal && !a,
              [`col-form-label-${e.labelSize}`]: !!e.labelSize
            },
            this.labelAlignClasses,
            e.labelClass
          ]
        };
        this.isHorizontal ? o = ie(Pt, C, { default: () => n }) : o = ie(_, C, n);
      }
    }
    let r = null;
    const i = Ne(Fu, {}, t) || this.invalidFeedback, v = i ? at("_BV_feedback_invalid_") : void 0;
    i && (r = ie(
      Aa,
      {
        ariaLive: e.feedbackAriaLive,
        id: v,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => i }
    ));
    let b = null;
    const h = Ne(Pu, {}, t) || this.validFeedback, p = h ? at("_BV_feedback_valid_") : void 0;
    h && (b = ie(
      Fa,
      {
        ariaLive: e.feedbackAriaLive,
        id: p,
        state: this.stateBoolean,
        tooltip: this.tooltipBoolean
      },
      { default: () => h }
      // validFeedbackContent
    ));
    let B = null;
    const S = Ne(Eu, {}, t) || this.description, m = S ? at("_BV_description_") : void 0;
    S && (B = ie(
      Oa,
      {
        id: m
      },
      { default: () => S }
    ));
    const A = this.ariaDescribedby = [
      m,
      this.stateBoolean === !1 ? v : null,
      this.stateBoolean === !0 ? p : null
    ].filter((_) => _).join(" ") || null, y = [
      Ne(Iu, { ariaDescribedby: A, descriptionId: m, id: l, labelId: s }, t) || "",
      r,
      b,
      B
    ];
    !this.isHorizontal && this.floatingBoolean && y.push(o);
    let k = ie(
      "div",
      {
        ref: "content",
        class: [
          {
            "form-floating": !this.isHorizontal && this.floatingBoolean
          }
        ]
      },
      y
    );
    this.isHorizontal && (k = ie(Pt, { ref: "content", ...this.contentColProps }, { default: () => y }));
    const w = {
      class: [
        this.stateClass,
        {
          "was-validated": this.validatedBoolean
        }
      ],
      id: _e(() => e.id).value,
      disabled: a ? this.disabledBoolean : null,
      role: a ? null : "group",
      "aria-invalid": this.computedAriaInvalid,
      // Only apply `aria-labelledby` if we are a horizontal fieldset
      // as the legend is no longer a direct child of fieldset
      "aria-labelledby": a && this.isHorizontal ? s : null
    };
    return this.isHorizontal && !a ? ie(Jt, w, { default: () => [o, k] }) : ie(
      a ? "fieldset" : "div",
      w,
      this.isHorizontal && a ? [ie(Jt, null, { default: () => [o, k] })] : this.isHorizontal || !this.floatingBoolean ? [o, k] : [k]
    );
  }
}), Lu = ["id", "name", "form", "type", "disabled", "placeholder", "required", "autocomplete", "readonly", "min", "max", "step", "list", "aria-required", "aria-invalid"], Nu = /* @__PURE__ */ N({
  __name: "BFormInput",
  props: {
    max: { default: void 0 },
    min: { default: void 0 },
    step: { default: void 0 },
    type: { default: "text" },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: [String, Boolean], default: !1 },
    lazyFormatter: { type: [String, Boolean], default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: [String, Boolean], default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: [String, Boolean], default: !1 },
    readonly: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    trim: { type: [String, Boolean], default: !1 }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { expose: t, emit: l }) {
    const a = e, { input: o, computedId: n, computedAriaInvalid: s, onInput: r, onChange: i, onBlur: v, focus: b, blur: h } = tn(a, l), p = d(() => a.disabled), B = d(() => a.required), S = d(() => a.readonly), m = d(() => a.plaintext), A = d(() => a.state), y = Vt(A), k = R(!1), w = u(() => {
      const _ = a.type === "range", C = a.type === "color";
      return [
        y.value,
        {
          "form-control-highlighted": k.value,
          "form-range": _,
          "form-control": C || !a.plaintext && !_,
          "form-control-color": C,
          "form-control-plaintext": a.plaintext && !_ && !C,
          [`form-control-${a.size}`]: !!a.size
        }
      ];
    });
    return t({
      focus: b,
      blur: h
    }), (_, C) => (g(), P("input", {
      id: $(n),
      ref_key: "input",
      ref: o,
      class: H(w.value),
      name: _.name || void 0,
      form: _.form || void 0,
      type: _.type,
      disabled: $(p),
      placeholder: _.placeholder,
      required: $(B) || void 0,
      autocomplete: _.autocomplete || void 0,
      readonly: $(S) || $(m),
      min: _.min,
      max: _.max,
      step: _.step,
      list: _.type !== "password" ? _.list : void 0,
      "aria-required": $(B) || void 0,
      "aria-invalid": $(s),
      onInput: C[0] || (C[0] = (T) => $(r)(T)),
      onChange: C[1] || (C[1] = (T) => $(i)(T)),
      onBlur: C[2] || (C[2] = (T) => $(v)(T))
    }, null, 42, Lu));
  }
}), zu = ["id", "checked", "disabled", "required", "name", "form", "aria-label", "aria-labelledby", "value", "aria-required"], Hu = ["for"], _n = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BFormRadio",
  props: {
    ariaLabel: { default: void 0 },
    ariaLabelledby: { default: void 0 },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    size: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    modelValue: { type: [Boolean, String, Array, Object, Number, null], default: void 0 },
    plain: { type: [String, Boolean], default: !1 },
    button: { type: [String, Boolean], default: !1 },
    buttonGroup: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: null },
    inline: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    state: { type: [String, Boolean, null], default: null },
    value: { type: [String, Boolean, Object, Number], default: !0 }
  },
  emits: ["input", "change", "update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Fe(), n = Se(a, "modelValue", l, { passive: !0 }), s = _e(() => a.id, "form-check"), r = d(() => a.autofocus), i = d(() => a.plain), v = d(() => a.button), b = d(() => a.buttonGroup), h = d(() => a.disabled), p = d(() => a.inline), B = d(() => a.required), S = d(() => a.state), m = Oe(ko, null), A = R(null), { focused: y } = Ee(A, {
      initialValue: r.value
    }), k = u(() => !Ae(o.default)), w = u({
      get: () => m !== null ? JSON.stringify(m.modelValue.value) === JSON.stringify(a.value) : JSON.stringify(n.value) === JSON.stringify(a.value),
      set: (f) => {
        const I = f || f === "" || f === 0 ? a.value : !1;
        l("input", I), n.value = I, Ce(() => {
          l("change", I);
        });
      }
    });
    oe(
      () => m == null ? void 0 : m.modelValue.value,
      (f) => {
        JSON.stringify(f) === JSON.stringify(a.value) !== !0 && (w.value = !1);
      }
    ), oe(n, (f) => {
      m === null || f === !1 || m.set(a.value);
    });
    const _ = u(
      () => !!(a.name ?? (m == null ? void 0 : m.name.value)) && (B.value || (m == null ? void 0 : m.required.value))
    ), C = u(
      () => b.value || ((m == null ? void 0 : m.buttons.value) ?? !1)
    ), T = u(() => ({
      plain: i.value || ((m == null ? void 0 : m.plain.value) ?? !1),
      button: v.value || ((m == null ? void 0 : m.buttons.value) ?? !1),
      inline: p.value || ((m == null ? void 0 : m.inline.value) ?? !1),
      state: S.value || (m == null ? void 0 : m.state.value),
      size: a.size !== void 0 ? a.size : (m == null ? void 0 : m.size.value) ?? "md",
      // This is where the true default is made
      buttonVariant: a.buttonVariant !== null ? a.buttonVariant : (m == null ? void 0 : m.buttonVariant.value) ?? "secondary"
      // This is where the true default is made
    })), c = Yo(T), V = Jo(T), F = Zo(T);
    return t({
      focus: () => {
        y.value = !0;
      },
      blur: () => {
        y.value = !1;
      }
    }), (f, I) => (g(), M(Qa, {
      skip: C.value,
      class: H($(c))
    }, {
      default: j(() => {
        var E, z, Z;
        return [
          rt(K("input", ee({ id: $(s) }, f.$attrs, {
            ref_key: "input",
            ref: A,
            "onUpdate:modelValue": I[0] || (I[0] = (te) => w.value = te),
            checked: w.value,
            class: $(V),
            type: "radio",
            disabled: $(h) || ((E = $(m)) == null ? void 0 : E.disabled.value),
            required: _.value || void 0,
            name: f.name || ((z = $(m)) == null ? void 0 : z.name.value),
            form: f.form || ((Z = $(m)) == null ? void 0 : Z.form.value),
            "aria-label": f.ariaLabel,
            "aria-labelledby": f.ariaLabelledby,
            value: f.value,
            "aria-required": _.value || void 0
          }), null, 16, zu), [
            [Xn, w.value]
          ]),
          k.value || $(i) === !1 ? (g(), P("label", {
            key: 0,
            for: $(s),
            class: H($(F))
          }, [
            O(f.$slots, "default")
          ], 10, Hu)) : J("", !0)
        ];
      }),
      _: 3
    }, 8, ["skip", "class"]));
  }
}), Ru = ["id"], Mu = ["innerHTML"], Du = ["textContent"], ju = /* @__PURE__ */ N({
  __name: "BFormRadioGroup",
  props: {
    size: { default: "md" },
    form: { default: void 0 },
    id: { default: void 0 },
    name: { default: void 0 },
    modelValue: { type: [String, Boolean, Array, Object, Number, null], default: null },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    buttonVariant: { default: "secondary" },
    buttons: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    plain: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    stacked: { type: [String, Boolean], default: !1 },
    state: { type: [String, Boolean, null], default: null },
    textField: { default: "text" },
    validated: { type: [String, Boolean], default: !1 },
    valueField: { default: "value" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "modelValue", l), n = _e(() => a.id, "radio"), s = _e(() => a.name, "checkbox"), r = d(() => a.autofocus), i = d(() => a.buttons), v = d(() => a.disabled), b = d(() => a.plain), h = d(() => a.required), p = d(() => a.stacked), B = d(() => a.state), S = d(() => a.validated), m = R(null), { focused: A } = Ee(m, {
      initialValue: r.value
    });
    De(ko, {
      set: (C) => {
        l("input", C), o.value = C, Ce(() => {
          l("change", C);
        });
      },
      modelValue: u(() => o.value),
      buttonVariant: ye(ke(a, "buttonVariant")),
      form: ye(ke(a, "form")),
      name: s,
      buttons: i,
      state: B,
      plain: b,
      size: ye(ke(a, "size")),
      inline: u(() => !p.value),
      required: h,
      disabled: v
    });
    const y = u(
      () => a.options.map(
        (C, T) => typeof C == "string" || typeof C == "number" ? {
          props: {
            value: C,
            disabled: v.value
          },
          text: C.toString(),
          html: void 0,
          self: Symbol(`radioGroupOptionItem${T}`)
        } : {
          props: {
            value: C[a.valueField],
            disabled: C[a.disabledField],
            ...C.props ? C.props : {}
          },
          text: C[a.textField],
          html: C[a.htmlField],
          self: Symbol(`radioGroupOptionItem${T}`)
        }
      )
    ), k = u(() => ({
      required: h.value,
      ariaInvalid: a.ariaInvalid,
      state: B.value,
      validated: S.value,
      buttons: i.value,
      stacked: p.value,
      size: a.size
    })), w = Qo(k), _ = en(k);
    return t({
      focus: () => {
        A.value = !0;
      },
      blur: () => {
        A.value = !1;
      }
    }), (C, T) => (g(), P("div", ee($(w), {
      id: $(n),
      ref_key: "element",
      ref: m,
      role: "radiogroup",
      class: [$(_), "bv-no-focus-ring"],
      tabindex: "-1"
    }), [
      O(C.$slots, "first"),
      (g(!0), P(ce, null, he(y.value, (c) => (g(), M(_n, ee({
        key: c.self
      }, c.props), {
        default: j(() => [
          c.html ? (g(), P("span", {
            key: 0,
            innerHTML: c.html
          }, null, 8, Mu)) : (g(), P("span", {
            key: 1,
            textContent: Y(c.text)
          }, null, 8, Du))
        ]),
        _: 2
      }, 1040))), 128)),
      O(C.$slots, "default")
    ], 16, Ru));
  }
}), qu = ["value", "disabled"], ol = /* @__PURE__ */ N({
  __name: "BFormSelectOption",
  props: {
    value: { default: void 0 },
    disabled: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.disabled);
    return (a, o) => (g(), P("option", {
      value: a.value,
      disabled: $(l)
    }, [
      O(a.$slots, "default")
    ], 8, qu));
  }
}), Gu = ["label"], $n = /* @__PURE__ */ N({
  __name: "BFormSelectOptionGroup",
  props: {
    label: { default: void 0 },
    disabledField: { default: "disabled" },
    htmlField: { default: "html" },
    options: { default: () => [] },
    textField: { default: "text" },
    valueField: { default: "value" }
  },
  setup(e) {
    const t = e, l = u(
      () => el(t.options, "BFormSelectOptionGroup", t)
    );
    return (a, o) => (g(), P("optgroup", { label: a.label }, [
      O(a.$slots, "first"),
      (g(!0), P(ce, null, he(l.value, (n, s) => (g(), M(ol, ee({
        key: s,
        value: n.value,
        disabled: n.disabled
      }, a.$attrs, {
        innerHTML: n.html || n.text
      }), null, 16, ["value", "disabled", "innerHTML"]))), 128)),
      O(a.$slots, "default")
    ], 8, Gu));
  }
}), Wu = ["id", "name", "form", "multiple", "size", "disabled", "required", "aria-required", "aria-invalid"], Uu = /* @__PURE__ */ N({
  __name: "BFormSelect",
  props: {
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    disabledField: { default: "disabled" },
    form: { default: void 0 },
    htmlField: { default: "html" },
    id: { default: void 0 },
    labelField: { default: "label" },
    multiple: { type: [String, Boolean], default: !1 },
    name: { default: void 0 },
    options: { default: () => [] },
    optionsField: { default: "options" },
    plain: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    selectSize: { default: 0 },
    size: { default: "md" },
    state: { type: [String, Boolean, null], default: null },
    textField: { default: "text" },
    valueField: { default: "value" },
    modelValue: { default: "" }
  },
  emits: ["input", "update:modelValue", "change"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "modelValue", l), n = _e(() => a.id, "input"), s = d(() => a.autofocus), r = d(() => a.disabled), i = d(() => a.multiple), v = d(() => a.plain), b = d(() => a.required), h = d(() => a.state), p = Vt(h), B = R(), { focused: S } = Ee(B, {
      initialValue: s.value
    }), m = u(() => [
      p.value,
      {
        "form-control": v.value,
        [`form-control-${a.size}`]: a.size !== "md" && v.value,
        "form-select": !v.value,
        [`form-select-${a.size}`]: a.size !== "md" && !v.value
      }
    ]), A = u(
      () => a.selectSize || v.value ? a.selectSize : void 0
    ), y = u(
      () => ca(a.ariaInvalid, h.value)
    ), k = u(() => el(a.options, "BFormSelect", a)), w = u({
      get: () => o.value,
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      set: (_) => {
        l("input", _), o.value = _, Ce(() => {
          l("change", _);
        });
      }
    });
    return t({
      focus: () => {
        S.value = !0;
      },
      blur: () => {
        S.value = !1;
      }
    }), (_, C) => rt((g(), P("select", ee({
      id: $(n),
      ref_key: "input",
      ref: B
    }, _.$attrs, {
      "onUpdate:modelValue": C[0] || (C[0] = (T) => w.value = T),
      class: m.value,
      name: _.name,
      form: _.form || void 0,
      multiple: $(i) || void 0,
      size: A.value,
      disabled: $(r),
      required: $(b) || void 0,
      "aria-required": $(b) || void 0,
      "aria-invalid": y.value
    }), [
      O(_.$slots, "first"),
      (g(!0), P(ce, null, he(k.value, (T, c) => (g(), P(ce, { key: c }, [
        Array.isArray(T.options) ? (g(), M($n, {
          key: 0,
          label: T.label,
          options: T.options
        }, null, 8, ["label", "options"])) : (g(), M(ol, {
          key: 1,
          value: T.value,
          disabled: T.disabled,
          innerHTML: T.html || T.text
        }, null, 8, ["value", "disabled", "innerHTML"]))
      ], 64))), 128)),
      O(_.$slots, "default")
    ], 16, Wu)), [
      [Kn, w.value]
    ]);
  }
}), Dl = [
  "ar",
  "az",
  "ckb",
  "fa",
  "he",
  "ks",
  "lrc",
  "mzn",
  "ps",
  "sd",
  "te",
  "ug",
  "ur",
  "yi"
].map((e) => e.toLowerCase()), Xu = (e) => {
  const t = Zt(e).toLowerCase().replace(as, "").split("-"), l = t.slice(0, 2).join("-"), [a] = t;
  return Dl.includes(l) || Dl.includes(a);
}, Ku = (e) => ps ? ba(e) ? e : { capture: !!e || !1 } : !!(ba(e) ? e.capture : e), Yu = (e, t, l, a) => {
  e && e.addEventListener && e.addEventListener(t, l, Ku(a));
}, Ju = (e, t, l, a) => {
  e && e.removeEventListener && e.removeEventListener(t, l, a);
}, jl = (e, t) => {
  (e ? Yu : Ju)(...t);
}, Ut = (e, { preventDefault: t = !0, propagation: l = !0, immediatePropagation: a = !1 } = {}) => {
  t && e.preventDefault(), l && e.stopPropagation(), a && e.stopImmediatePropagation();
}, Pa = "ArrowDown", Cn = "End", kn = "Home", Tn = "PageDown", Vn = "PageUp", Ea = "ArrowUp", ql = 1, Gl = 100, Wl = 1, Ul = 500, Xl = 100, Kl = 10, Yl = 4, Jl = [Ea, Pa, kn, Cn, Vn, Tn], Zu = N({
  props: {
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: void 0 },
    labelIncrement: { type: String, default: "Increment" },
    labelDecrement: { type: String, default: "Decrement" },
    modelValue: { type: Number, default: null },
    // V-model prop
    name: { type: String, default: "BFormSpinButton" },
    disabled: { type: [Boolean, String], default: !1 },
    placeholder: { type: String, default: void 0 },
    locale: { type: String, default: "locale" },
    form: { type: String, default: void 0 },
    inline: { type: Boolean, default: !1 },
    size: { type: String, default: void 0 },
    formatterFn: {
      type: Function,
      default: void 0
    },
    readonly: { type: Boolean, default: !1 },
    vertical: { type: Boolean, default: !1 },
    repeatDelay: {
      type: [String, Number],
      default: Ul
    },
    repeatInterval: {
      type: [String, Number],
      default: Xl
    },
    repeatStepMultiplier: {
      type: [String, Number],
      default: Yl
    },
    repeatThreshold: {
      type: [String, Number],
      default: Kl
    },
    required: { type: [Boolean, String], default: !1 },
    step: { type: [String, Number], default: Wl },
    min: { type: [String, Number], default: ql },
    max: { type: [String, Number], default: Gl },
    wrap: { type: Boolean, default: !1 },
    state: { type: [Boolean, String], default: null }
  },
  emits: ["update:modelValue", "change"],
  setup(e, { emit: t }) {
    const l = Se(e, "modelValue", t), a = R(!1), o = u(() => 1), n = () => {
      t("change", r.value);
    }, s = R(null), r = u({
      get: () => l.value === null ? s.value : l.value,
      set: (q) => {
        l.value === null ? s.value = q : l.value = q;
      }
    });
    let i, v, b = !1;
    const h = u(() => Et(e.step, Wl)), p = u(() => Et(e.min, ql)), B = u(() => {
      const q = Et(e.max, Gl), Q = h.value, re = p.value;
      return Math.floor((q - re) / Q) * Q + re;
    }), S = u(() => {
      const q = lt(e.repeatDelay, 0);
      return q > 0 ? q : Ul;
    }), m = u(() => {
      const q = lt(e.repeatInterval, 0);
      return q > 0 ? q : Xl;
    }), A = u(
      () => Math.max(lt(e.repeatThreshold, Kl), 1)
    ), y = u(
      () => Math.max(lt(e.repeatStepMultiplier, Yl), 1)
    ), k = u(() => {
      const q = h.value;
      return Math.floor(q) === q ? 0 : (q.toString().split(".")[1] || "").length;
    }), w = u(() => Math.pow(10, k.value || 0)), _ = u(() => {
      const { value: q } = r;
      return q === null ? "" : q.toFixed(k.value);
    }), C = u(() => {
      const q = [e.locale];
      return new Intl.NumberFormat(q).resolvedOptions().locale;
    }), T = u(
      () => (
        //todo
        Xu(C.value)
      )
    ), c = () => {
      const q = k.value;
      return new Intl.NumberFormat(C.value, {
        style: "decimal",
        useGrouping: !1,
        minimumIntegerDigits: 1,
        minimumFractionDigits: q,
        maximumFractionDigits: q,
        notation: "standard"
      }).format;
    }, V = u(() => e.formatterFn ?? c()), F = u(() => ({
      role: "group",
      lang: C.value,
      tabindex: e.disabled ? null : "-1",
      title: e.ariaLabel
    })), f = u(() => l.value !== null || s.value !== null), I = u(() => ({
      dir: T.value,
      spinId: o.value,
      tabindex: e.disabled ? null : "0",
      role: "spinbutton",
      "aria-live": "off",
      "aria-label": e.ariaLabel || null,
      "aria-controls": e.ariaControls || null,
      "aria-invalid": e.state === !1 || !f.value && e.required ? !0 : null,
      "aria-required": e.required ? !0 : null,
      "aria-valuemin": p.value,
      "aria-valuemax": B.value,
      "aria-valuenow": r.value !== null ? r.value : null,
      "aria-valuetext": r.value !== null ? V.value(r.value) : null
    })), E = (q) => {
      let { value: Q } = r;
      if (!e.disabled && Q !== null) {
        const re = h.value * q, de = p.value, L = B.value, x = w.value, { wrap: D } = e;
        Q = Math.round((Q - de) / re) * re + de + re, Q = Math.round(Q * x) / x, r.value = Q > L ? D ? de : L : Q < de ? D ? L : de : Q;
      }
    }, z = (q = 1) => {
      r.value === null ? r.value = p.value : E(1 * q);
    }, Z = (q = 1) => {
      r.value === null ? r.value = e.wrap ? B.value : p.value : E(-1 * q);
    }, te = (q) => {
      const { code: Q, altKey: re, ctrlKey: de, metaKey: L } = q;
      if (!(e.disabled || e.readonly || re || de || L) && Jl.includes(Q)) {
        if (Ut(q, { propagation: !1 }), b)
          return;
        pe(), [Ea, Pa].includes(Q) ? (b = !0, Q === Ea ? W(q, z) : Q === Pa && W(q, Z)) : Q === Vn ? z(y.value) : Q === Tn ? Z(y.value) : Q === kn ? r.value = p.value : Q === Cn && (r.value = B.value);
      }
    }, G = (q) => {
      const { code: Q, altKey: re, ctrlKey: de, metaKey: L } = q;
      e.disabled || e.readonly || re || de || L || Jl.includes(Q) && (Ut(q, { propagation: !1 }), pe(), b = !1, n());
    }, W = (q, Q) => {
      const { type: re } = q || {};
      if (!e.disabled && !e.readonly) {
        if (X(q) && re === "mousedown" && q.button)
          return;
        pe(), Q(1);
        const de = A.value, L = y.value, x = S.value, D = m.value;
        i = setTimeout(() => {
          let ae = 0;
          v = setInterval(() => {
            Q(ae < de ? 1 : L), ae++;
          }, D);
        }, x);
      }
    };
    function X(q) {
      return q.type === "mouseup" || q.type === "mousedown";
    }
    const ve = (q) => {
      X(q) && q.type === "mouseup" && q.button || (Ut(q, { propagation: !1 }), pe(), ge(!1), n());
    }, ge = (q) => {
      try {
        jl(q, [document.body, "mouseup", ve, !1]), jl(q, [document.body, "touchend", ve, !1]);
      } catch {
        return 0;
      }
    }, pe = () => {
      clearTimeout(i), clearInterval(v), i = void 0, v = void 0;
    }, me = (q, Q, re, de, L, x, D) => {
      const ae = ie(re, {
        props: { scale: a.value ? 1.5 : 1.25 },
        attrs: { "aria-hidden": !0 }
      }), ue = { hasFocus: a.value }, U = (se) => {
        !e.disabled && !e.readonly && (Ut(se, { propagation: !1 }), ge(!0), W(se, q));
      };
      return ie(
        "button",
        {
          class: [{ "py-0": !e.vertical }, "btn", "btn-sm", "border-0", "rounded-0"],
          tabindex: "-1",
          type: "button",
          disabled: e.disabled || e.readonly || x,
          "aria-disabled": e.disabled || e.readonly || x ? !0 : null,
          "aria-controls": o.value,
          "aria-label": Q || null,
          "aria-keyshortcuts": L || null,
          onmousedown: U,
          ontouchstart: U
          // 'ref': keyRef,
        },
        [Ne(D, ue) || ae]
      );
    };
    return () => {
      const q = me(
        z,
        e.labelIncrement,
        ie(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-plus",
            viewBox: "0 0 16 16"
          },
          ie("path", {
            d: "M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z"
          })
        ),
        "inc",
        "ArrowUp",
        !1,
        "increment"
      ), Q = me(
        Z,
        e.labelDecrement,
        ie(
          "svg",
          {
            xmlns: "http://www.w3.org/2000/svg",
            width: "16",
            height: "16",
            fill: "currentColor",
            class: "bi bi-dash",
            viewBox: "0 0 16 16"
          },
          ie("path", { d: "M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z" })
        ),
        "dec",
        "ArrowDown",
        !1,
        "decrement"
      ), re = [];
      e.name && !e.disabled && re.push(
        ie("input", {
          type: "hidden",
          name: e.name,
          form: e.form || null,
          // TODO: Should this be set to '' if value is out of range?
          value: _.value,
          key: "hidden"
        })
      );
      const de = ie(
        // We use 'output' element to make this accept a `<label for="id">` (Except IE)
        "output",
        {
          class: [
            { "d-flex": e.vertical },
            { "align-self-center": !e.vertical },
            { "align-items-center": e.vertical },
            { "border-top": e.vertical },
            { "border-bottom": e.vertical },
            { "border-start": !e.vertical },
            { "border-end": !e.vertical },
            "flex-grow-1"
          ],
          ...I.value,
          key: "output"
          // ref: 'spinner',
        },
        [
          ie(
            "bdi",
            // eslint-disable-next-line @typescript-eslint/ban-ts-comment
            //@ts-ignore How can we narrow this type down
            f.value ? V.value(r.value) : e.placeholder || ""
          )
        ]
      );
      return ie(
        "div",
        {
          class: [
            "b-form-spinbutton form-control",
            { disabled: e.disabled },
            { readonly: e.readonly },
            { focus: a },
            { "d-inline-flex": e.inline || e.vertical },
            { "d-flex": !e.inline && !e.vertical },
            { "align-items-stretch": !e.vertical },
            { "flex-column": e.vertical },
            e.size ? `form-control-${e.size}` : null
            // this.stateClass //TODO
          ],
          ...F.value,
          onkeydown: te,
          onkeyup: G
          // We use capture phase (`!` prefix) since focus and blur do not bubble
          // 'focus': onFocusBlur, //TODO
          // 'blur': onFocusBlur, //TODO
        },
        e.vertical ? [q, re, de, Q] : [Q, re, de, q]
      );
    };
  }
}), Qu = ["id"], An = /* @__PURE__ */ N({
  __name: "BFormTag",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    disabled: { type: [String, Boolean], default: !1 },
    noRemove: { type: [String, Boolean], default: !1 },
    pill: { type: [String, Boolean], default: !1 },
    removeLabel: { default: "Remove tag" },
    tag: { default: "span" },
    variant: { default: "secondary" }
  },
  emits: ["remove"],
  setup(e, { emit: t }) {
    const l = e, a = Fe(), o = _e(() => l.id), n = d(() => l.disabled), s = d(() => l.noRemove), r = d(() => l.pill), i = u(
      () => {
        var h;
        return ((((h = a.default) == null ? void 0 : h.call(a)[0].children) ?? "").toString() || l.title) ?? "";
      }
    ), v = u(() => `${o.value}taglabel__`), b = u(() => ({
      [`bg-${l.variant}`]: l.variant !== null,
      "text-dark": l.variant !== null && ["warning", "info", "light"].includes(l.variant),
      "rounded-pill": r.value,
      disabled: n.value
    }));
    return (h, p) => (g(), M(le(h.tag), {
      id: $(o),
      title: i.value,
      class: H(["badge b-form-tag d-inline-flex align-items-center mw-100", b.value]),
      "aria-labelledby": v.value
    }, {
      default: j(() => [
        K("span", {
          id: v.value,
          class: "b-form-tag-content flex-grow-1 text-truncate"
        }, [
          O(h.$slots, "default", {}, () => [
            ne(Y(i.value), 1)
          ])
        ], 8, Qu),
        !$(n) && !$(s) ? (g(), M(Ot, {
          key: 0,
          "aria-keyshortcuts": "Delete",
          "aria-label": h.removeLabel,
          class: "b-form-tag-remove",
          white: h.variant !== null && !["warning", "info", "light"].includes(h.variant),
          "aria-describedby": v.value,
          "aria-controls": h.id,
          onClick: p[0] || (p[0] = (B) => t("remove", i.value))
        }, null, 8, ["aria-label", "white", "aria-describedby", "aria-controls"])) : J("", !0)
      ]),
      _: 3
    }, 8, ["id", "title", "class", "aria-labelledby"]));
  }
}), ed = ["id"], td = ["id", "for", "aria-live"], ad = ["id", "aria-live"], ld = ["id"], od = ["aria-controls"], nd = {
  role: "group",
  class: "d-flex"
}, sd = ["id", "disabled", "value", "type", "placeholder", "form", "required", "aria-required"], rd = ["disabled"], id = {
  "aria-live": "polite",
  "aria-atomic": "true"
}, ud = {
  key: 0,
  class: "d-block invalid-feedback"
}, dd = {
  key: 1,
  class: "form-text text-muted"
}, cd = {
  key: 2,
  class: "form-text text-muted"
}, fd = ["name", "value"], vd = /* @__PURE__ */ N({
  __name: "BFormTags",
  props: {
    addButtonText: { default: "Add" },
    addButtonVariant: { default: "outline-secondary" },
    addOnChange: { type: [String, Boolean], default: !1 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    duplicateTagText: { default: "Duplicate tag(s)" },
    inputAttrs: { default: void 0 },
    inputClass: { default: void 0 },
    inputId: { default: void 0 },
    inputType: { default: "text" },
    invalidTagText: { default: "Invalid tag(s)" },
    form: { default: void 0 },
    limit: { default: void 0 },
    limitTagsText: { default: "Tag limit reached" },
    modelValue: { default: () => [] },
    name: { default: void 0 },
    noAddOnEnter: { type: [String, Boolean], default: !1 },
    noOuterFocus: { type: [String, Boolean], default: !1 },
    noTagRemove: { type: [String, Boolean], default: !1 },
    placeholder: { default: "Add tag..." },
    removeOnDelete: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    separator: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    size: { default: "md" },
    tagClass: { default: void 0 },
    tagPills: { type: [String, Boolean], default: !1 },
    tagRemoveLabel: { default: void 0 },
    tagRemovedLabel: { default: "Tag removed" },
    tagValidator: { type: Function, default: () => !0 },
    tagVariant: { default: "secondary" }
  },
  emits: ["update:modelValue", "input", "tag-state", "focus", "focusin", "focusout", "blur"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "modelValue", l), n = _e(), s = d(() => a.addOnChange), r = d(() => a.autofocus), i = d(() => a.disabled), v = d(() => a.noAddOnEnter), b = d(() => a.noOuterFocus), h = d(() => a.noTagRemove), p = d(() => a.removeOnDelete), B = d(() => a.required), S = d(() => a.state), m = d(() => a.tagPills), A = Vt(S), y = R(null), { focused: k } = Ee(y, {
      initialValue: r.value
    }), w = u(() => a.inputId || `${n.value}input__`), _ = R(o.value), C = R(""), T = R(o.value.length > 0), c = R(""), V = R([]), F = R([]), f = R([]), I = u(() => [
      A.value,
      {
        [`form-control-${a.size}`]: a.size !== "md",
        disabled: i.value,
        focus: k.value
      }
    ]), E = u(() => _.value.includes(C.value)), z = u(
      () => C.value === "" ? !1 : !a.tagValidator(C.value)
    ), Z = u(() => _.value.length === a.limit), te = u(() => !z.value && !E.value), G = u(() => ({
      addButtonText: a.addButtonText,
      addButtonVariant: a.addButtonVariant,
      addTag: re,
      disableAddButton: te.value,
      disabled: i.value,
      duplicateTagText: a.duplicateTagText,
      duplicateTags: f.value,
      form: a.form,
      inputAttrs: {
        ...a.inputAttrs,
        disabled: i.value,
        form: a.form,
        id: w,
        value: C
      },
      inputHandlers: {
        input: ge,
        keydown: me,
        change: pe
      },
      inputId: w,
      inputType: a.inputType,
      invalidTagText: a.invalidTagText,
      invalidTags: F.value,
      isDuplicate: E.value,
      isInvalid: z.value,
      isLimitReached: Z.value,
      limitTagsText: a.limitTagsText,
      limit: a.limit,
      noTagRemove: h.value,
      placeholder: a.placeholder,
      removeTag: de,
      required: B.value,
      separator: a.separator,
      size: a.size,
      state: S.value,
      tagClass: a.tagClass,
      tagPills: m.value,
      tagRemoveLabel: a.tagRemoveLabel,
      tagVariant: a.tagVariant,
      tags: _.value
    }));
    oe(o, (L) => {
      _.value = L;
    });
    const W = (L) => {
      if (i.value) {
        L.target.blur();
        return;
      }
      l("focusin", L);
    }, X = (L) => {
      i.value || b.value || (k.value = !0, l("focus", L));
    }, ve = (L) => {
      k.value = !1, l("blur", L);
    }, ge = (L) => {
      var D, ae;
      const x = typeof L == "string" ? L : L.target.value;
      if (T.value = !1, (D = a.separator) != null && D.includes(x.charAt(0)) && x.length > 0) {
        y.value && (y.value.value = "");
        return;
      }
      if (C.value = x, (ae = a.separator) != null && ae.includes(x.charAt(x.length - 1))) {
        re(x.slice(0, x.length - 1));
        return;
      }
      V.value = a.tagValidator(x) && !E.value ? [x] : [], F.value = a.tagValidator(x) ? [] : [x], f.value = E.value ? [x] : [], l("tag-state", V.value, F.value, f.value);
    }, pe = (L) => {
      s.value && (ge(L), E.value || re(C.value));
    }, me = (L) => {
      if (L.key === "Enter" && !v.value) {
        re(C.value);
        return;
      }
      (L.key === "Backspace" || L.key === "Delete") && p.value && C.value === "" && T.value && _.value.length > 0 ? de(_.value[_.value.length - 1]) : T.value = !0;
    }, q = u(() => {
      if (a.separator)
        return typeof a.separator == "string" ? a.separator : a.separator.join("");
    }), Q = u(() => {
      if (q.value)
        return new RegExp(`[${rs(q.value)}]+`);
    }), re = (L) => {
      L = (L ?? C.value).trim();
      const x = Q.value ? L.split(Q.value).map((ue) => ue.trim()) : [L], D = [];
      for (const ue of x)
        if (!(ue === "" || E.value || !a.tagValidator(ue))) {
          if (a.limit && Z.value)
            break;
          D.push(ue);
        }
      const ae = [...o.value, ...D];
      C.value = "", T.value = !0, o.value = ae, l("input", ae), k.value = !0;
    }, de = (L) => {
      const x = _.value.indexOf((L == null ? void 0 : L.toString()) ?? "");
      c.value = _.value.splice(x, 1).toString(), o.value = _.value;
    };
    return t({
      focus: () => {
        k.value = !0;
      },
      blur: () => {
        k.value = !1;
      }
    }), (L, x) => (g(), P("div", {
      id: $(n),
      class: H(["b-form-tags form-control h-auto", I.value]),
      role: "group",
      tabindex: "-1",
      onFocusin: W,
      onFocusout: x[1] || (x[1] = (D) => l("focusout", D))
    }, [
      K("output", {
        id: `${$(n)}selected_tags__`,
        class: "visually-hidden",
        for: w.value,
        "aria-live": $(k) ? "polite" : "off",
        "aria-atomic": "true",
        "aria-relevant": "additions text"
      }, Y(_.value.join(", ")), 9, td),
      K("div", {
        id: `${$(n)}removed_tags__`,
        role: "status",
        "aria-live": $(k) ? "assertive" : "off",
        "aria-atomic": "true",
        class: "visually-hidden"
      }, " (" + Y(L.tagRemovedLabel) + ") " + Y(c.value), 9, ad),
      O(L.$slots, "default", Be(Ve(G.value)), () => [
        K("ul", {
          id: `${$(n)}tag_list__`,
          class: "b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center"
        }, [
          (g(!0), P(ce, null, he(_.value, (D, ae) => O(L.$slots, "tag", Be(ee({ key: ae }, { tag: D, tagClass: L.tagClass, tagVariant: L.tagVariant, tagPills: $(m), removeTag: de })), () => [
            (g(), M(An, {
              key: D,
              class: H(L.tagClass),
              tag: "li",
              variant: L.tagVariant,
              pill: L.tagPills,
              onRemove: de
            }, {
              default: j(() => [
                ne(Y(D), 1)
              ]),
              _: 2
            }, 1032, ["class", "variant", "pill"]))
          ])), 128)),
          K("li", {
            role: "none",
            "aria-live": "off",
            class: "b-from-tags-field flex-grow-1",
            "aria-controls": `${$(n)}tag_list__`
          }, [
            K("div", nd, [
              K("input", ee({
                id: w.value,
                ref_key: "input",
                ref: y,
                disabled: $(i),
                value: C.value,
                type: L.inputType,
                placeholder: L.placeholder,
                class: "b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0",
                style: { outline: "currentcolor none 0px", "min-width": "5rem" }
              }, L.inputAttrs, {
                form: L.form,
                required: $(B) || void 0,
                "aria-required": $(B) || void 0,
                onInput: ge,
                onChange: pe,
                onKeydown: me,
                onFocus: X,
                onBlur: ve
              }), null, 16, sd),
              te.value ? (g(), P("button", {
                key: 0,
                type: "button",
                class: H(["btn b-form-tags-button py-0", [
                  L.inputClass,
                  {
                    [`btn-${L.addButtonVariant}`]: L.addButtonVariant !== null,
                    "disabled invisible": C.value.length === 0
                  }
                ]]),
                style: { "font-size": "90%" },
                disabled: $(i) || C.value.length === 0 || Z.value,
                onClick: x[0] || (x[0] = (D) => re(C.value))
              }, [
                O(L.$slots, "add-button-text", {}, () => [
                  ne(Y(L.addButtonText), 1)
                ])
              ], 10, rd)) : J("", !0)
            ])
          ], 8, od)
        ], 8, ld),
        K("div", id, [
          z.value ? (g(), P("div", ud, Y(L.invalidTagText) + ": " + Y(C.value), 1)) : J("", !0),
          E.value ? (g(), P("small", dd, Y(L.duplicateTagText) + ": " + Y(C.value), 1)) : J("", !0),
          _.value.length === L.limit ? (g(), P("small", cd, "Tag limit reached")) : J("", !0)
        ])
      ]),
      L.name ? (g(!0), P(ce, { key: 0 }, he(_.value, (D, ae) => (g(), P("input", {
        key: ae,
        type: "hidden",
        name: L.name,
        value: D
      }, null, 8, fd))), 128)) : J("", !0)
    ], 42, ed));
  }
}), pd = ["id", "name", "form", "disabled", "placeholder", "required", "autocomplete", "readonly", "aria-required", "aria-invalid", "rows", "wrap"], md = /* @__PURE__ */ N({
  __name: "BFormTextarea",
  props: {
    noResize: { type: [String, Boolean], default: !1 },
    rows: { default: 2 },
    wrap: { default: "soft" },
    ariaInvalid: { type: [String, Boolean], default: void 0 },
    autocomplete: { default: void 0 },
    autofocus: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    form: { default: void 0 },
    formatter: { type: Function, default: void 0 },
    id: { default: void 0 },
    lazy: { type: [String, Boolean], default: !1 },
    lazyFormatter: { type: [String, Boolean], default: !1 },
    list: { default: void 0 },
    modelValue: { default: "" },
    name: { default: void 0 },
    number: { type: [String, Boolean], default: !1 },
    placeholder: { default: void 0 },
    plaintext: { type: [String, Boolean], default: !1 },
    readonly: { type: [String, Boolean], default: !1 },
    required: { type: [String, Boolean], default: !1 },
    size: { default: void 0 },
    state: { type: [String, Boolean, null], default: null },
    trim: { type: [String, Boolean], default: !1 }
  },
  emits: ["update:modelValue", "change", "blur", "input"],
  setup(e, { expose: t, emit: l }) {
    const a = e, { input: o, computedId: n, computedAriaInvalid: s, onInput: r, onChange: i, onBlur: v, focus: b, blur: h } = tn(a, l), p = d(() => a.disabled), B = d(() => a.required), S = d(() => a.readonly), m = d(() => a.plaintext), A = d(() => a.noResize), y = d(() => a.state), k = Vt(y), w = u(() => [
      k.value,
      {
        "form-control": !a.plaintext,
        "form-control-plaintext": a.plaintext,
        [`form-control-${a.size}`]: !!a.size
      }
    ]), _ = u(() => ({
      resize: A.value ? "none" : void 0
    }));
    return t({
      focus: b,
      blur: h
    }), (C, T) => (g(), P("textarea", {
      id: $(n),
      ref_key: "input",
      ref: o,
      class: H(w.value),
      name: C.name || void 0,
      form: C.form || void 0,
      disabled: $(p),
      placeholder: C.placeholder,
      required: $(B) || void 0,
      autocomplete: C.autocomplete || void 0,
      readonly: $(S) || $(m),
      "aria-required": C.required || void 0,
      "aria-invalid": $(s),
      rows: C.rows,
      style: ze(_.value),
      wrap: C.wrap || void 0,
      onInput: T[0] || (T[0] = (c) => $(r)(c)),
      onChange: T[1] || (T[1] = (c) => $(i)(c)),
      onBlur: T[2] || (T[2] = (c) => $(v)(c))
    }, null, 46, pd));
  }
}), gd = {
  key: 0,
  class: "input-group-text"
}, yd = ["innerHTML"], bd = { key: 1 }, hd = {
  key: 0,
  class: "input-group-text"
}, Bd = ["innerHTML"], Sd = { key: 1 }, wd = /* @__PURE__ */ N({
  __name: "BInputGroup",
  props: {
    append: { default: void 0 },
    appendHtml: { default: void 0 },
    id: { default: void 0 },
    prepend: { default: void 0 },
    prependHtml: { default: void 0 },
    size: { default: "md" },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = u(() => ({
      [`input-group-${t.size}`]: t.size !== "md"
    })), a = u(() => !!t.append || !!t.appendHtml), o = u(() => !!t.prepend || !!t.prependHtml);
    return (n, s) => (g(), M(le(n.tag), {
      id: n.id,
      class: H(["input-group", l.value]),
      role: "group"
    }, {
      default: j(() => [
        O(n.$slots, "prepend", {}, () => [
          o.value ? (g(), P("span", gd, [
            n.prependHtml ? (g(), P("span", {
              key: 0,
              innerHTML: n.prependHtml
            }, null, 8, yd)) : (g(), P("span", bd, Y(n.prepend), 1))
          ])) : J("", !0)
        ]),
        O(n.$slots, "default"),
        O(n.$slots, "append", {}, () => [
          a.value ? (g(), P("span", hd, [
            n.appendHtml ? (g(), P("span", {
              key: 0,
              innerHTML: n.appendHtml
            }, null, 8, Bd)) : (g(), P("span", Sd, Y(n.append), 1))
          ])) : J("", !0)
        ])
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), On = /* @__PURE__ */ N({
  __name: "BInputGroupText",
  props: {
    tag: { default: "div" },
    text: { default: void 0 }
  },
  setup(e) {
    return (t, l) => (g(), M(le(t.tag), { class: "input-group-text" }, {
      default: j(() => [
        O(t.$slots, "default", {}, () => [
          ne(Y(t.text), 1)
        ])
      ]),
      _: 3
    }));
  }
}), nl = /* @__PURE__ */ N({
  __name: "BInputGroupAddon",
  props: {
    isText: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.isText);
    return (a, o) => $(l) ? (g(), M(On, { key: 0 }, {
      default: j(() => [
        O(a.$slots, "default")
      ]),
      _: 3
    })) : O(a.$slots, "default", { key: 1 });
  }
}), _d = /* @__PURE__ */ N({
  __name: "BInputGroupAppend",
  props: {
    isText: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    return (t, l) => (g(), M(nl, { "is-text": t.isText }, {
      default: j(() => [
        O(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), $d = /* @__PURE__ */ N({
  __name: "BInputGroupPrepend",
  props: {
    isText: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    return (t, l) => (g(), M(nl, { "is-text": t.isText }, {
      default: j(() => [
        O(t.$slots, "default")
      ]),
      _: 3
    }, 8, ["is-text"]));
  }
}), Cd = /* @__PURE__ */ N({
  __name: "BListGroup",
  props: {
    flush: { type: [String, Boolean], default: !1 },
    horizontal: { type: [Boolean, String], default: !1 },
    numbered: { type: [String, Boolean], default: !1 },
    tag: { default: "div" }
  },
  setup(e) {
    const t = e, l = d(() => t.flush), a = d(() => t.numbered), o = u(() => {
      const s = l.value ? !1 : t.horizontal;
      return {
        "list-group-flush": l.value,
        "list-group-horizontal": s === !0,
        [`list-group-horizontal-${s}`]: typeof s == "string",
        "list-group-numbered": a.value
      };
    }), n = u(() => a.value === !0 ? "ol" : t.tag);
    return De(wo, {
      numbered: a
    }), (s, r) => (g(), M(le(n.value), {
      class: H(["list-group", o.value])
    }, {
      default: j(() => [
        O(s.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), kd = /* @__PURE__ */ N({
  __name: "BListGroupItem",
  props: {
    action: { type: [String, Boolean], default: !1 },
    active: { type: [String, Boolean], default: !1 },
    button: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    tag: { default: "div" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = za(), a = Oe(wo, null), o = d(() => t.action), n = d(() => t.active), s = d(() => t.button), r = d(() => t.disabled), i = u(() => !s.value && (!!t.href || !!t.to)), v = u(
      () => a != null && a.numbered.value ? "li" : s.value ? "button" : i.value ? Xe : t.tag
    ), b = u(
      () => o.value || i.value || s.value || ["a", "router-link", "button", "b-link"].includes(t.tag)
    ), h = u(() => ({
      [`list-group-item-${t.variant}`]: t.variant !== null,
      "list-group-item-action": b.value,
      active: n.value,
      disabled: r.value
    })), p = u(() => {
      const B = {};
      return s.value && ((!l || !l.type) && (B.type = "button"), r.value && (B.disabled = !0)), B;
    });
    return (B, S) => (g(), M(le(v.value), ee({
      class: ["list-group-item", h.value],
      "aria-current": $(n) ? !0 : void 0,
      "aria-disabled": $(r) ? !0 : void 0,
      target: i.value ? B.target : void 0,
      href: $(s) ? void 0 : B.href,
      to: $(s) ? void 0 : B.to
    }, p.value), {
      default: j(() => [
        O(B.$slots, "default")
      ]),
      _: 3
    }, 16, ["class", "aria-current", "aria-disabled", "target", "href", "to"]));
  }
}), Td = ["id", "aria-labelledby", "aria-describedby"], Vd = ["id"], Ad = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BModal",
  props: {
    bodyBgVariant: { default: null },
    bodyClass: { default: void 0 },
    bodyTextVariant: { default: null },
    busy: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    buttonSize: { default: "md" },
    cancelDisabled: { type: [String, Boolean], default: !1 },
    cancelTitle: { default: "Cancel" },
    cancelVariant: { default: "secondary" },
    centered: { type: [String, Boolean], default: !1 },
    contentClass: { default: void 0 },
    dialogClass: { default: void 0 },
    footerBgVariant: { default: null },
    footerBorderVariant: { default: null },
    footerClass: { default: void 0 },
    footerTextVariant: { default: null },
    fullscreen: { type: [Boolean, String], default: !1 },
    headerBgVariant: { default: null },
    headerBorderVariant: { default: null },
    headerClass: { default: void 0 },
    headerCloseLabel: { default: "Close" },
    headerCloseWhite: { type: [String, Boolean], default: !1 },
    headerTextVariant: { default: null },
    hideBackdrop: { type: [String, Boolean], default: !1 },
    hideFooter: { type: [String, Boolean], default: !1 },
    hideHeader: { type: [String, Boolean], default: !1 },
    hideHeaderClose: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    modalClass: { default: void 0 },
    modelValue: { type: [String, Boolean], default: !1 },
    noCloseOnBackdrop: { type: [String, Boolean], default: !1 },
    noCloseOnEsc: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    autoFocus: { type: [String, Boolean], default: !0 },
    okDisabled: { type: [String, Boolean], default: !1 },
    okOnly: { type: [String, Boolean], default: !1 },
    okTitle: { default: "Ok" },
    okVariant: { default: "primary" },
    scrollable: { type: [String, Boolean], default: !1 },
    show: { type: [String, Boolean], default: !1 },
    size: { default: "md" },
    title: { default: void 0 },
    titleClass: { default: void 0 },
    titleSrOnly: { type: [String, Boolean], default: !1 },
    titleTag: { default: "h5" },
    autoFocusButton: { default: void 0 },
    teleportDisabled: { type: [String, Boolean], default: !1 },
    teleportTo: { default: "body" },
    bodyScrolling: { type: [String, Boolean], default: !1 }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "ok", "cancel", "close"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Fe(), n = _e(() => a.id, "modal"), s = Se(a, "modelValue", l), r = d(() => a.busy), i = d(() => a.lazy), v = d(() => a.cancelDisabled), b = d(() => a.centered), h = d(() => a.hideBackdrop), p = d(() => a.hideFooter), B = d(() => a.hideHeader), S = d(() => a.hideHeaderClose), m = d(s), A = d(() => a.noCloseOnBackdrop), y = d(() => a.noCloseOnEsc), k = d(() => a.noFade), w = d(() => a.autoFocus), _ = d(() => a.okDisabled), C = d(() => a.okOnly), T = d(() => a.scrollable), c = d(() => a.titleSrOnly), V = d(() => a.teleportDisabled), F = d(() => a.bodyScrolling), f = R(null), I = R(null), E = R(null), z = R(null), Z = R(m.value), te = R(!1);
    an(m, F);
    const { focused: G } = Ee(f, {
      initialValue: m.value && a.autoFocusButton === void 0
    }), { focused: W } = Ee(I, {
      initialValue: m.value && a.autoFocusButton === "ok"
    }), { focused: X } = Ee(E, {
      initialValue: m.value && a.autoFocusButton === "cancel"
    }), { focused: ve } = Ee(z, {
      initialValue: m.value && a.autoFocusButton === "close"
    }), ge = u(() => [
      a.modalClass,
      {
        fade: !k.value,
        show: Z.value
      }
    ]), pe = u(
      () => i.value === !1 || i.value === !0 && te.value === !0 || i.value === !0 && m.value === !0
    ), me = u(() => !Ae(o["header-close"])), q = u(() => [
      a.dialogClass,
      {
        "modal-fullscreen": a.fullscreen === !0,
        [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == "string",
        [`modal-${a.size}`]: a.size !== "md",
        "modal-dialog-centered": b.value,
        "modal-dialog-scrollable": T.value
      }
    ]), Q = u(() => [
      a.bodyClass,
      {
        [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant !== null,
        [`text-${a.bodyTextVariant}`]: a.bodyTextVariant !== null
      }
    ]), re = u(() => [
      a.headerClass,
      {
        [`bg-${a.headerBgVariant}`]: a.headerBgVariant !== null,
        [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== null,
        [`text-${a.headerTextVariant}`]: a.headerTextVariant !== null
      }
    ]), de = u(() => [
      a.footerClass,
      {
        [`bg-${a.footerBgVariant}`]: a.footerBgVariant !== null,
        [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== null,
        [`text-${a.footerTextVariant}`]: a.footerTextVariant !== null
      }
    ]), L = u(() => [
      a.titleClass,
      {
        "visually-hidden": c.value
      }
    ]), x = u(() => v.value || r.value), D = u(() => _.value || r.value), ae = (fe, $e = {}) => new Rt(fe, {
      cancelable: !1,
      target: f.value || null,
      relatedTarget: null,
      trigger: null,
      ...$e,
      componentId: n.value
    }), ue = (fe = "") => {
      const $e = ae("hide", { cancelable: fe !== "", trigger: fe });
      if (fe === "ok" && l(fe, $e), fe === "cancel" && l(fe, $e), fe === "close" && l(fe, $e), l("hide", $e), $e.defaultPrevented || fe === "backdrop" && A.value || fe === "esc" && y.value) {
        l("hide-prevented");
        return;
      }
      s.value = !1;
    }, U = () => {
      const fe = ae("show", { cancelable: !0 });
      if (l("show", fe), fe.defaultPrevented) {
        s.value = !1, l("show-prevented");
        return;
      }
      s.value = !0;
    }, se = () => {
      w.value !== !1 && (a.autoFocusButton === "ok" ? W.value = !0 : a.autoFocusButton === "close" ? ve.value = !0 : a.autoFocusButton === "cancel" ? X.value = !0 : G.value = !0);
    }, Ie = () => U(), et = () => {
      Z.value = !0, se(), l("shown", ae("shown")), i.value === !0 && (te.value = !0);
    }, tt = () => {
      Z.value = !1;
    }, ut = () => {
      l("hidden", ae("hidden")), i.value === !0 && (te.value = !1);
    };
    return Xr(Z), we(f, "bv-toggle", () => {
      m.value ? ue() : U();
    }), t({
      hide: ue,
      show: U
    }), (fe, $e) => (g(), M(Na, {
      to: fe.teleportTo,
      disabled: $(V)
    }, [
      be(At, {
        "no-fade": !0,
        "trans-props": { enterToClass: "show" },
        onBeforeEnter: Ie,
        onAfterEnter: et,
        onLeave: tt,
        onAfterLeave: ut
      }, {
        default: j(() => [
          rt(K("div", ee({
            id: $(n),
            ref_key: "element",
            ref: f,
            class: ["modal", ge.value],
            role: "dialog",
            "aria-labelledby": `${$(n)}-label`,
            "aria-describedby": `${$(n)}-body`,
            tabindex: "-1"
          }, fe.$attrs, {
            onKeyup: $e[5] || ($e[5] = It((Ft) => ue("esc"), ["esc"]))
          }), [
            K("div", {
              class: H(["modal-dialog", q.value])
            }, [
              pe.value ? (g(), P("div", {
                key: 0,
                class: H(["modal-content", fe.contentClass])
              }, [
                $(B) ? J("", !0) : (g(), P("div", {
                  key: 0,
                  class: H(["modal-header", re.value])
                }, [
                  O(fe.$slots, "header", {}, () => [
                    (g(), M(le(fe.titleTag), {
                      id: `${$(n)}-label`,
                      class: H(["modal-title", L.value])
                    }, {
                      default: j(() => [
                        O(fe.$slots, "title", {}, () => [
                          ne(Y(fe.title), 1)
                        ], !0)
                      ]),
                      _: 3
                    }, 8, ["id", "class"])),
                    $(S) ? J("", !0) : (g(), P(ce, { key: 0 }, [
                      me.value ? (g(), P("button", {
                        key: 0,
                        type: "button",
                        onClick: $e[0] || ($e[0] = (Ft) => ue("close"))
                      }, [
                        O(fe.$slots, "header-close", {}, void 0, !0)
                      ])) : (g(), M(Ot, {
                        key: 1,
                        ref_key: "closeButton",
                        ref: z,
                        "aria-label": fe.headerCloseLabel,
                        white: fe.headerCloseWhite,
                        onClick: $e[1] || ($e[1] = (Ft) => ue("close"))
                      }, null, 8, ["aria-label", "white"]))
                    ], 64))
                  ], !0)
                ], 2)),
                K("div", {
                  id: `${$(n)}-body`,
                  class: H(["modal-body", Q.value])
                }, [
                  O(fe.$slots, "default", {}, void 0, !0)
                ], 10, Vd),
                $(p) ? J("", !0) : (g(), P("div", {
                  key: 1,
                  class: H(["modal-footer", de.value])
                }, [
                  O(fe.$slots, "footer", {}, () => [
                    O(fe.$slots, "cancel", {}, () => [
                      $(C) ? J("", !0) : (g(), M(kt, {
                        key: 0,
                        ref_key: "cancelButton",
                        ref: E,
                        disabled: x.value,
                        size: fe.buttonSize,
                        variant: fe.cancelVariant,
                        onClick: $e[2] || ($e[2] = (Ft) => ue("cancel"))
                      }, {
                        default: j(() => [
                          ne(Y(fe.cancelTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"]))
                    ], !0),
                    O(fe.$slots, "ok", {}, () => [
                      be(kt, {
                        ref_key: "okButton",
                        ref: I,
                        disabled: D.value,
                        size: fe.buttonSize,
                        variant: fe.okVariant,
                        onClick: $e[3] || ($e[3] = (Ft) => ue("ok"))
                      }, {
                        default: j(() => [
                          ne(Y(fe.okTitle), 1)
                        ]),
                        _: 1
                      }, 8, ["disabled", "size", "variant"])
                    ], !0)
                  ], !0)
                ], 2))
              ], 2)) : J("", !0)
            ], 2),
            $(h) ? J("", !0) : O(fe.$slots, "backdrop", { key: 0 }, () => [
              K("div", {
                class: "modal-backdrop fade show",
                onClick: $e[4] || ($e[4] = (Ft) => ue("backdrop"))
              })
            ], !0)
          ], 16, Td), [
            [ua, $(m)]
          ])
        ]),
        _: 3
      })
    ], 8, ["to", "disabled"]));
  }
});
const Od = /* @__PURE__ */ ll(Ad, [["__scopeId", "data-v-b5795927"]]), Fd = /* @__PURE__ */ N({
  __name: "BNav",
  props: {
    align: { default: void 0 },
    cardHeader: { type: [String, Boolean], default: !1 },
    fill: { type: [String, Boolean], default: !1 },
    justified: { type: [String, Boolean], default: !1 },
    pills: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tabs: { type: [String, Boolean], default: !1 },
    tag: { default: "ul" },
    vertical: { type: [String, Boolean], default: !1 },
    underline: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.cardHeader), a = d(() => t.fill), o = d(() => t.justified), n = d(() => t.pills), s = d(() => t.small), r = d(() => t.tabs), i = d(() => t.vertical), v = Dt(() => t.align), b = d(() => t.underline), h = u(() => ({
      "nav-tabs": r.value,
      "nav-pills": n.value && !r.value,
      "card-header-tabs": !i.value && l.value && r.value,
      "card-header-pills": !i.value && l.value && n.value && !r.value,
      "flex-column": i.value,
      "nav-fill": !i.value && a.value,
      "nav-justified": !i.value && o.value,
      [v.value]: !i.value && t.align !== void 0,
      small: s.value,
      "nav-underline": b.value
    }));
    return (p, B) => (g(), M(le(p.tag), {
      class: H(["nav", h.value])
    }, {
      default: j(() => [
        O(p.$slots, "default")
      ]),
      _: 3
    }, 8, ["class"]));
  }
}), Pd = /* @__PURE__ */ N({
  __name: "BNavForm",
  props: {
    role: { default: void 0 },
    id: { default: void 0 },
    floating: { type: [String, Boolean], default: !1 },
    novalidate: { type: [String, Boolean], default: !1 },
    validated: { type: [String, Boolean], default: !1 }
  },
  emits: ["submit"],
  setup(e, { emit: t }) {
    const l = e, a = u(() => ({
      floating: l.floating,
      role: l.role,
      id: l.id,
      novalidate: l.novalidate,
      validated: l.validated
    })), o = (n) => t("submit", n);
    return (n, s) => (g(), M(Bn, ee(a.value, {
      class: "d-flex",
      onSubmit: ot(o, ["prevent"])
    }), {
      default: j(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 16, ["onSubmit"]));
  }
}), Ed = { class: "nav-item" }, Id = /* @__PURE__ */ N({
  __name: "BNavItem",
  props: {
    linkClasses: { default: void 0 },
    linkAttrs: { default: void 0 },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.disabled), o = u(
      () => Mt(l, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "icon",
        "opacity",
        "opacityHover",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "underlineVariant",
        "variant"
      ])
    );
    return (n, s) => (g(), P("li", Ed, [
      be(Xe, ee({
        class: ["nav-link", n.linkClasses]
      }, { ...o.value, ...n.linkAttrs }, {
        "active-class": n.activeClass ?? "active",
        tabindex: $(a) ? -1 : void 0,
        "aria-disabled": $(a) ? !0 : void 0,
        onClick: s[0] || (s[0] = ot((r) => t("click", r), ["stop"]))
      }), {
        default: j(() => [
          O(n.$slots, "default")
        ]),
        _: 3
      }, 16, ["class", "active-class", "tabindex", "aria-disabled"])
    ]));
  }
}), xd = { class: "nav-item dropdown" }, Ld = /* @__PURE__ */ N({
  __name: "BNavItemDropdown",
  props: {
    id: { default: void 0 },
    text: { default: void 0 },
    toggleClass: { default: void 0 },
    size: { default: "md" },
    offset: { default: void 0 },
    autoClose: { type: [Boolean, String], default: void 0 },
    dark: { type: [String, Boolean], default: void 0 },
    splitVariant: { default: void 0 },
    noCaret: { type: [String, Boolean], default: void 0 },
    variant: { default: "link" },
    modelValue: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: void 0 },
    strategy: { default: void 0 },
    floatingMiddleware: { default: void 0 },
    noFlip: { type: [String, Boolean], default: void 0 },
    noShift: { type: [String, Boolean], default: void 0 },
    dropup: { type: [String, Boolean], default: void 0 },
    dropend: { type: [String, Boolean], default: void 0 },
    dropstart: { type: [String, Boolean], default: void 0 },
    center: { type: [String, Boolean], default: void 0 },
    end: { type: [String, Boolean], default: void 0 },
    menuClass: { default: void 0 }
  },
  emits: ["update:modelValue"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "modelValue", l, { passive: !0 }), n = d(o), s = u({
      get: () => n.value,
      set: (h) => {
        o.value = h;
      }
    }), r = u(() => As(a, ["modelValue"]));
    return t({
      close: () => {
        o.value = !1;
      },
      open: () => {
        o.value = !0;
      },
      toggle: () => {
        o.value = !n.value;
      }
    }), (h, p) => (g(), P("li", xd, [
      be(hn, ee({
        modelValue: s.value,
        "onUpdate:modelValue": p[0] || (p[0] = (B) => s.value = B)
      }, r.value, { "is-nav": "" }), {
        "button-content": j(() => [
          O(h.$slots, "button-content")
        ]),
        "toggle-text": j(() => [
          O(h.$slots, "toggle-text")
        ]),
        default: j(() => [
          O(h.$slots, "default")
        ]),
        _: 3
      }, 16, ["modelValue"])
    ]));
  }
}), Nd = { class: "navbar-text" }, zd = /* @__PURE__ */ N({
  __name: "BNavText",
  props: {
    text: { default: void 0 }
  },
  setup(e) {
    return (t, l) => (g(), P("li", Nd, [
      O(t.$slots, "default", {}, () => [
        ne(Y(t.text), 1)
      ])
    ]));
  }
}), Hd = /* @__PURE__ */ N({
  __name: "BNavbar",
  props: {
    fixed: { default: void 0 },
    print: { type: [String, Boolean], default: !1 },
    sticky: { default: void 0 },
    tag: { default: "nav" },
    toggleable: { type: [Boolean, String], default: !1 },
    dark: { type: [String, Boolean], default: !1 },
    variant: { default: null },
    container: { type: [String, Boolean], default: "fluid" }
  },
  setup(e) {
    const t = e, l = d(() => t.print), a = d(() => t.dark), o = u(
      () => t.tag === "nav" ? void 0 : "navigation"
    ), n = u(
      () => typeof t.toggleable == "string" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? "navbar-expand" : void 0
    ), s = u(
      () => t.container === !0 ? "container" : "container-fluid"
    ), r = u(() => ({
      "d-print": l.value,
      [`sticky-${t.sticky}`]: t.sticky !== void 0,
      "navbar-dark": a.value,
      [`bg-${t.variant}`]: t.variant !== null,
      [`fixed-${t.fixed}`]: t.fixed !== void 0,
      [`${n.value}`]: n.value !== void 0
    }));
    return De(Wa, {
      tag: ye(ke(t, "tag"))
    }), (i, v) => (g(), M(le(i.tag), {
      class: H(["navbar", r.value]),
      role: o.value
    }, {
      default: j(() => [
        i.container !== !1 ? (g(), P("div", {
          key: 0,
          class: H(s.value)
        }, [
          O(i.$slots, "default")
        ], 2)) : O(i.$slots, "default", { key: 1 })
      ]),
      _: 3
    }, 8, ["class", "role"]));
  }
}), Rd = /* @__PURE__ */ N({
  __name: "BNavbarBrand",
  props: {
    tag: { default: "div" },
    active: { type: [String, Boolean], default: void 0 },
    activeClass: { default: "router-link-active" },
    append: { type: [String, Boolean], default: !1 },
    disabled: { type: [String, Boolean], default: !1 },
    href: { default: void 0 },
    rel: { default: void 0 },
    replace: { type: [String, Boolean], default: !1 },
    routerComponentName: { default: "router-link" },
    target: { default: "_self" },
    to: { default: void 0 },
    variant: { default: void 0 },
    opacity: { default: void 0 },
    opacityHover: { default: void 0 },
    underlineVariant: { default: null },
    underlineOffset: { default: void 0 },
    underlineOffsetHover: { default: void 0 },
    underlineOpacity: { default: void 0 },
    underlineOpacityHover: { default: void 0 },
    icon: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = u(() => wt(t)), a = u(() => l.value ? Xe : t.tag), o = u(
      () => l.value ? Mt(t, [
        "active",
        "activeClass",
        "append",
        "disabled",
        "href",
        "rel",
        "replace",
        "routerComponentName",
        "target",
        "to",
        "variant",
        "opacity",
        "opacityHover",
        "underlineVariant",
        "underlineOffset",
        "underlineOffsetHover",
        "underlineOpacity",
        "underlineOpacityHover",
        "icon"
      ]) : {}
    );
    return (n, s) => (g(), M(le(a.value), ee({ class: "navbar-brand" }, o.value), {
      default: j(() => [
        O(n.$slots, "default")
      ]),
      _: 3
    }, 16));
  }
}), Md = /* @__PURE__ */ N({
  __name: "BNavbarNav",
  props: {
    align: { default: void 0 },
    fill: { type: [String, Boolean], default: !1 },
    justified: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tag: { default: "ul" }
  },
  setup(e) {
    const t = e, l = d(() => t.fill), a = d(() => t.justified), o = d(() => t.small), n = Dt(() => t.align), s = u(() => ({
      "nav-fill": l.value,
      "nav-justified": a.value,
      [n.value]: t.align !== void 0,
      small: o.value
    }));
    return (r, i) => (g(), P("ul", {
      class: H(["navbar-nav", s.value])
    }, [
      O(r.$slots, "default")
    ], 2));
  }
}), Zl = (e, t) => e.setAttribute("data-bs-theme", t), Dd = {
  mounted(e, t) {
    Zl(e, t.value);
  },
  updated(e, t) {
    Zl(e, t.value);
  }
}, sl = (e, t) => {
  const { modifiers: l, arg: a, value: o } = e, n = Object.keys(l || {}), s = typeof o == "string" ? o.split(Kt) : o;
  if (ks(t.tagName, "a")) {
    const r = qa(t, "href") || "";
    ts.test(r) && n.push(r.replace(es, ""));
  }
  return Array.prototype.concat.apply([], [a, s]).forEach((r) => typeof r == "string" && n.push(r)), n.filter((r, i, v) => r && v.indexOf(r) === i);
}, jd = (e, t) => {
  sl(e, t).forEach((a) => {
    const o = document.getElementById(a);
    o !== null && o.dispatchEvent(new Event("bv-toggle"));
  }), setTimeout(() => Fn(e, t), 50);
}, Fn = (e, t) => {
  const l = sl(e, t);
  let a = !1;
  l.forEach((o) => {
    const n = document.getElementById(o);
    n != null && n.classList.contains("show") && (a = !0), n != null && n.classList.contains("closing") && (a = !1);
  }), t.setAttribute("aria-expanded", a ? "true" : "false");
}, Ia = {
  mounted(e, t) {
    e.__toggle = () => jd(t, e), e.addEventListener("click", e.__toggle), Fn(t, e), e.setAttribute("aria-controls", sl(t, e).join(" "));
  },
  unmounted(e) {
    e.removeEventListener("click", e.__toggle), e.removeAttribute("aria-controls"), e.removeAttribute("aria-expanded");
  }
}, qd = {
  mounted(e, t) {
    if (!zt(t.value))
      return;
    const a = na(t.value, e);
    !a.content && !a.title || (e.$__state = R({
      ...sa(t, e),
      ...a
    }), ln(e, t));
  },
  updated(e, t) {
    if (!zt(t.value))
      return;
    const a = na(t.value, e);
    !a.content && !a.title || e.$__state && (e.$__state.value = {
      ...sa(t, e),
      ...a
    });
  },
  beforeUnmount(e) {
    on(e);
  }
}, Gd = {
  mounted(e, t) {
    const l = zt(t.value);
    if (!l)
      return;
    const a = na(t.value, e);
    !a.content && !a.title || (e.$__state = R({
      ...sa(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: l
    }), ln(e, t));
  },
  updated(e, t) {
    const l = zt(t.value);
    if (!l)
      return;
    const a = na(t.value, e);
    !a.content && !a.title || e.$__state && (e.$__state.value = {
      ...sa(t, e),
      title: a.title ?? a.content ?? "",
      tooltip: l
    });
  },
  beforeUnmount(e) {
    on(e);
  }
}, Ql = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  vBColorMode: Dd,
  vBModal: Ia,
  vBPopover: qd,
  vBToggle: Ia,
  vBTooltip: Gd
}, Symbol.toStringTag, { value: "Module" })), Wd = /* @__PURE__ */ K("span", { class: "navbar-toggler-icon" }, null, -1), Ud = /* @__PURE__ */ N({
  __name: "BNavbarToggle",
  props: {
    disabled: { type: [String, Boolean], default: !1 },
    label: { default: "Toggle navigation" },
    target: { default: void 0 }
  },
  emits: ["click"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.disabled), o = u(() => ({
      disabled: a.value,
      "aria-label": l.label
    })), n = u(() => ({
      disabled: a.value
    })), s = (r) => {
      a.value || t("click", r);
    };
    return (r, i) => rt((g(), P("button", ee({
      class: ["navbar-toggler", n.value],
      type: "button"
    }, o.value, { onClick: s }), [
      O(r.$slots, "default", {}, () => [
        Wd
      ])
    ], 16)), [
      [$(Ia), $(a) ? void 0 : r.target]
    ]);
  }
}), Pn = /* @__PURE__ */ N({
  __name: "BOverlay",
  props: {
    bgColor: { default: void 0 },
    blur: { default: "2px" },
    fixed: { type: [String, Boolean], default: !1 },
    noCenter: { type: [String, Boolean], default: !1 },
    noFade: { type: [String, Boolean], default: !1 },
    noWrap: { type: [String, Boolean], default: !1 },
    opacity: { default: 0.85 },
    overlayTag: { default: "div" },
    rounded: { type: [Boolean, String], default: !1 },
    show: { type: [String, Boolean], default: !1 },
    spinnerSmall: { type: [String, Boolean], default: !1 },
    spinnerType: { default: "border" },
    spinnerVariant: { default: void 0 },
    noSpinner: { type: [String, Boolean], default: !1 },
    variant: { default: "light" },
    wrapTag: { default: "div" },
    zIndex: { default: 10 }
  },
  emits: ["click", "hidden", "shown"],
  setup(e, { emit: t }) {
    const l = e, a = { top: 0, left: 0, bottom: 0, right: 0 }, o = d(() => l.fixed), n = d(() => l.noSpinner), s = d(() => l.noCenter), r = d(() => l.noWrap), i = d(() => l.show), v = d(() => l.spinnerSmall), b = u(
      () => l.rounded === !0 || l.rounded === "" ? "rounded" : l.rounded === !1 ? "" : `rounded-${l.rounded}`
    ), h = u(
      () => l.variant !== null && !l.bgColor ? `bg-${l.variant}` : ""
    ), p = u(() => i.value ? !0 : null), B = u(() => ({
      type: l.spinnerType,
      variant: l.spinnerVariant,
      small: v.value
    })), S = u(() => ({
      ...a,
      zIndex: l.zIndex || 10
    })), m = u(() => [
      "b-overlay",
      {
        "position-absolute": !r.value || !o.value,
        "position-fixed": r.value && o.value
      }
    ]), A = u(() => [h.value, b.value]), y = u(() => ({
      ...a,
      opacity: l.opacity,
      backgroundColor: l.bgColor || void 0,
      backdropFilter: l.blur ? `blur(${l.blur})` : void 0
    })), k = u(
      () => s.value ? a : {
        top: "50%",
        left: "50%",
        transform: "translateX(-50%) translateY(-50%)"
      }
    );
    return (w, _) => (g(), M(le(w.wrapTag), {
      class: "b-overlay-wrap position-relative",
      "aria-busy": p.value
    }, {
      default: j(() => [
        O(w.$slots, "default"),
        be(At, {
          "no-fade": w.noFade,
          "trans-props": { enterToClass: "show" },
          name: "fade",
          onOnAfterEnter: _[1] || (_[1] = (C) => t("shown")),
          onOnAfterLeave: _[2] || (_[2] = (C) => t("hidden"))
        }, {
          default: j(() => [
            $(i) ? (g(), M(le(w.overlayTag), {
              key: 0,
              class: H(m.value),
              style: ze(S.value),
              onClick: _[0] || (_[0] = (C) => t("click", C))
            }, {
              default: j(() => [
                K("div", {
                  class: H(["position-absolute", A.value]),
                  style: ze(y.value)
                }, null, 6),
                K("div", {
                  class: "position-absolute",
                  style: ze(k.value)
                }, [
                  O(w.$slots, "overlay", Be(Ve(B.value)), () => [
                    $(n) ? J("", !0) : (g(), M(pa, Be(ee({ key: 0 }, B.value)), null, 16))
                  ])
                ], 4)
              ]),
              _: 3
            }, 8, ["class", "style"])) : J("", !0)
          ]),
          _: 3
        }, 8, ["no-fade"])
      ]),
      _: 3
    }, 8, ["aria-busy"]));
  }
}), Xd = ["id", "aria-labelledby"], Kd = ["id"], Yd = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BOffcanvas",
  props: {
    dismissLabel: { default: "Close" },
    modelValue: { type: [String, Boolean], default: !1 },
    bodyScrolling: { type: [String, Boolean], default: !1 },
    backdrop: { type: [String, Boolean], default: !0 },
    noCloseOnBackdrop: { type: [String, Boolean], default: !1 },
    noCloseOnEsc: { type: [String, Boolean], default: !1 },
    placement: { default: "start" },
    title: { default: void 0 },
    noHeaderClose: { type: [String, Boolean], default: !1 },
    noHeader: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    noFocus: { type: [String, Boolean], default: !1 },
    backdropVariant: { default: "dark" },
    headerClass: { default: void 0 },
    bodyClass: { default: void 0 },
    footerClass: { default: void 0 },
    teleportDisabled: { type: [String, Boolean], default: !1 },
    teleportTo: { default: "body" }
  },
  emits: ["update:modelValue", "show", "shown", "hide", "hidden", "hide-prevented", "show-prevented", "esc", "close"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Fe(), n = Se(a, "modelValue", l, { passive: !0 }), s = d(n), r = d(() => a.bodyScrolling), i = d(() => a.backdrop), v = d(() => a.noHeaderClose), b = d(() => a.noHeader), h = d(() => a.noFocus), p = d(() => a.noCloseOnBackdrop), B = d(() => a.noCloseOnEsc), S = d(() => a.lazy), m = d(() => a.teleportDisabled), A = _e(() => a.id, "offcanvas");
    an(s, r);
    const y = R(null), { focused: k } = Ee(y, {
      initialValue: s.value && h.value === !1
    }), w = R(s.value), _ = R(!1), C = u(
      () => i.value === !0 && s.value === !0
    ), T = u(
      () => S.value === !1 || S.value === !0 && _.value === !0 || S.value === !0 && s.value === !0
    ), c = u(() => !Ae(o.footer)), V = u(() => [
      // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,
      "offcanvas",
      // Remove when above check is fixed
      `offcanvas-${a.placement}`,
      {
        show: s.value && w.value === !0
      }
    ]), F = (W, X = {}) => new Rt(W, {
      cancelable: !1,
      target: y.value || null,
      relatedTarget: null,
      trigger: null,
      ...X,
      componentId: A.value
    }), f = (W = "") => {
      const X = F("hide", { cancelable: W !== "", trigger: W });
      if (W === "close" && l(W, X), W === "esc" && l(W, X), l("hide", X), X.defaultPrevented || W === "backdrop" && p.value || W === "esc" && B.value) {
        l("hide-prevented");
        return;
      }
      n.value = !1;
    }, I = () => {
      const W = F("show", { cancelable: !0 });
      if (l("show", W), W.defaultPrevented) {
        n.value = !1, l("show-prevented");
        return;
      }
      n.value = !0;
    }, E = () => {
      Ce(() => {
        h.value === !1 && (k.value = !0);
      });
    }, z = () => I(), Z = () => {
      w.value = !0, E(), l("shown", F("shown")), S.value === !0 && (_.value = !0);
    }, te = () => {
      w.value = !1;
    }, G = () => {
      l("hidden", F("hidden")), S.value === !0 && (_.value = !1);
    };
    return we(y, "bv-toggle", () => {
      s.value ? f() : I();
    }), t({
      hide: f,
      show: I
    }), (W, X) => (g(), M(Na, {
      to: W.teleportTo,
      disabled: $(m)
    }, [
      be(At, {
        "no-fade": !0,
        "trans-props": {
          enterToClass: "showing",
          enterFromClass: "",
          leaveToClass: "hiding show",
          leaveFromClass: "show"
        },
        onBeforeEnter: z,
        onAfterEnter: Z,
        onLeave: te,
        onAfterLeave: G
      }, {
        default: j(() => [
          rt(K("div", ee({
            id: $(A),
            ref_key: "element",
            ref: y,
            "aria-modal": "true",
            role: "dialog",
            class: V.value,
            tabindex: "-1",
            "aria-labelledby": `${$(A)}-offcanvas-label`,
            "data-bs-backdrop": "false"
          }, W.$attrs, {
            onKeyup: X[1] || (X[1] = It((ve) => f("esc"), ["esc"]))
          }), [
            T.value ? (g(), P(ce, { key: 0 }, [
              $(b) ? J("", !0) : (g(), P("div", {
                key: 0,
                class: H(["offcanvas-header", W.headerClass])
              }, [
                O(W.$slots, "header", Be(Ve({ visible: $(s), placement: W.placement, hide: f })), () => [
                  K("h5", {
                    id: `${$(A)}-offcanvas-label`,
                    class: "offcanvas-title"
                  }, [
                    O(W.$slots, "title", {}, () => [
                      ne(Y(W.title), 1)
                    ])
                  ], 8, Kd),
                  $(v) ? J("", !0) : (g(), M(Ot, {
                    key: 0,
                    class: "text-reset",
                    "aria-label": W.dismissLabel,
                    onClick: X[0] || (X[0] = (ve) => f("close"))
                  }, null, 8, ["aria-label"]))
                ])
              ], 2)),
              K("div", {
                class: H(["offcanvas-body", W.bodyClass])
              }, [
                O(W.$slots, "default")
              ], 2),
              c.value ? (g(), P("div", {
                key: 1,
                class: H(W.footerClass)
              }, [
                O(W.$slots, "footer", Be(Ve({ visible: $(s), placement: W.placement, hide: f })))
              ], 2)) : J("", !0)
            ], 64)) : J("", !0)
          ], 16, Xd), [
            [ua, $(n)]
          ])
        ]),
        _: 3
      }),
      be(Pn, {
        variant: W.backdropVariant,
        show: C.value,
        fixed: !0,
        "no-wrap": "",
        "no-spinner": !0,
        onClick: X[2] || (X[2] = (ve) => f("backdrop"))
      }, null, 8, ["variant", "show"])
    ], 8, ["to", "disabled"]));
  }
}), Jd = 5, En = 20, In = 0, je = 3, Zd = "ellipsis-text", Qd = "first-text", ec = "last-text", tc = "next-text", ac = "page", lc = "prev-text", eo = (e) => Math.max(lt(e) || En, 1), to = (e) => Math.max(lt(e) || In, 0), oc = (e, t) => {
  const l = lt(e) || 1;
  return l > t ? t : l < 1 ? 1 : l;
}, nc = N({
  name: "BPagination",
  props: {
    align: { type: String, default: "start" },
    ariaControls: { type: String, default: void 0 },
    ariaLabel: { type: String, default: "Pagination" },
    disabled: { type: [Boolean, String], default: !1 },
    ellipsisClass: { type: [Array, String], default: () => [] },
    ellipsisText: { type: String, default: "â¦" },
    firstClass: { type: [Array, String], default: () => [] },
    firstNumber: { type: [Boolean, String], default: !1 },
    firstText: { type: String, default: "Â«" },
    hideEllipsis: { type: [Boolean, String], default: !1 },
    hideGotoEndButtons: { type: [Boolean, String], default: !1 },
    labelFirstPage: { type: String, default: "Go to first page" },
    labelLastPage: { type: String, default: "Go to last page" },
    labelNextPage: { type: String, default: "Go to next page" },
    labelPage: { type: String, default: "Go to page" },
    labelPrevPage: { type: String, default: "Go to previous page" },
    lastClass: { type: [Array, String], default: () => [] },
    lastNumber: { type: [Boolean, String], default: !1 },
    lastText: { type: String, default: "Â»" },
    limit: { type: Number, default: Jd },
    modelValue: { type: Number, default: 1 },
    // V-model prop
    nextClass: { type: [Array, String], default: () => [] },
    nextText: { type: String, default: "âº" },
    pageClass: { type: [Array, String], default: () => [] },
    perPage: { type: Number, default: En },
    pills: { type: [Boolean, String], default: !1 },
    prevClass: { type: [Array, String], default: () => [] },
    prevText: { type: String, default: "â¹" },
    size: { type: String, default: "md" },
    totalRows: { type: Number, default: In }
  },
  emits: ["update:modelValue", "page-click"],
  setup(e, { emit: t, slots: l }) {
    const a = Se(e, "modelValue", t), o = d(() => e.disabled), n = d(() => e.firstNumber), s = d(() => e.hideEllipsis), r = d(() => e.hideGotoEndButtons), i = d(() => e.lastNumber), v = d(() => e.pills), b = u(
      () => e.align === "fill" ? "start" : e.align
    ), h = Dt(b), p = u(
      () => Math.ceil(to(e.totalRows) / eo(e.perPage))
    ), B = u(() => {
      let T;
      return p.value - a.value + 2 < e.limit && e.limit > je ? T = p.value - m.value + 1 : T = a.value - Math.floor(m.value / 2), T < 1 ? T = 1 : T > p.value - m.value && (T = p.value - m.value + 1), e.limit <= je && i.value && p.value === T + m.value - 1 && (T = Math.max(T - 1, 1)), T;
    }), S = u(() => {
      const T = p.value - a.value;
      let c = !1;
      return T + 2 < e.limit && e.limit > je ? e.limit > je && (c = !0) : e.limit > je && (c = !!(!s.value || n.value)), B.value <= 1 && (c = !1), c && n.value && B.value < 4 && (c = !1), c;
    }), m = u(() => {
      let T = e.limit;
      return p.value <= e.limit ? T = p.value : a.value < e.limit - 1 && e.limit > je ? ((!s.value || i.value) && (T = e.limit - (n.value ? 0 : 1)), T = Math.min(T, e.limit)) : p.value - a.value + 2 < e.limit && e.limit > je ? (!s.value || n.value) && (T = e.limit - (i.value ? 0 : 1)) : e.limit > je && (T = e.limit - (s.value ? 0 : 2)), T;
    }), A = u(() => {
      const T = p.value - m.value;
      let c = !1;
      a.value < e.limit - 1 && e.limit > je ? (!s.value || i.value) && (c = !0) : e.limit > je && (c = !!(!s.value || i.value)), B.value > T && (c = !1);
      const V = B.value + m.value - 1;
      return c && i.value && V > p.value - 3 && (c = !1), c;
    }), y = St({
      pageSize: eo(e.perPage),
      totalRows: to(e.totalRows),
      numberOfPages: p.value
    }), k = (T, c) => {
      if (c === a.value)
        return;
      const { target: V } = T, F = new Ge("page-click", {
        cancelable: !0,
        target: V
      });
      t("page-click", F, c), !F.defaultPrevented && (a.value = c);
    }, w = u(() => e.size ? `pagination-${e.size}` : ""), _ = u(() => v.value ? "b-pagination-pills" : "");
    oe(a, (T) => {
      const c = oc(T, p.value);
      c !== a.value && (a.value = c);
    }), oe(y, (T, c) => {
      T != null && (c.pageSize !== T.pageSize && c.totalRows === T.totalRows || c.numberOfPages !== T.numberOfPages && a.value > c.numberOfPages) && (a.value = 1);
    });
    const C = u(() => {
      const T = [];
      for (let c = 0; c < m.value; c++)
        T.push({ number: B.value + c, classes: null });
      return T;
    });
    return () => {
      const T = [], c = C.value.map((G) => G.number), V = (G) => G === a.value, F = a.value < 1, f = e.align === "fill", I = (G, W, X, ve, ge, pe) => {
        const me = o.value || V(pe) || F || G < 1 || G > p.value, q = G < 1 ? 1 : G > p.value ? p.value : G, Q = { disabled: me, page: q, index: q - 1 }, re = Ne(X, Q, l) || ve || "";
        return ie(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: me,
                "flex-fill": f,
                "d-flex": f && !me
              },
              ge
            ]
          },
          // render inner content
          ie(
            me ? "span" : "button",
            {
              class: ["page-link", { "flex-grow-1": !me && f }],
              "aria-label": W,
              "aria-controls": e.ariaControls || null,
              "aria-disabled": me ? !0 : null,
              role: "menuitem",
              type: me ? null : "button",
              tabindex: me ? null : "-1",
              onClick: (de) => {
                me || k(de, q);
              }
            },
            re
          )
        );
      }, E = (G) => ie(
        "li",
        {
          class: [
            "page-item",
            "disabled",
            "bv-d-xs-down-none",
            f ? "flex-fill" : "",
            e.ellipsisClass
          ],
          role: "separator",
          key: `ellipsis-${G ? "last" : "first"}`
        },
        [
          ie(
            "span",
            { class: ["page-link"] },
            Ne(Zd, {}, l) || e.ellipsisText || "..."
          )
        ]
      ), z = (G, W) => {
        const X = V(G.number) && !F, ve = o.value ? null : X || F && W === 0 ? "0" : "-1", ge = {
          active: X,
          disabled: o.value,
          page: G.number,
          index: G.number - 1,
          content: G.number
        }, pe = Ne(ac, ge, l) || G.number, me = ie(
          o.value ? "span" : "button",
          {
            class: ["page-link", { "flex-grow-1": !o.value && f }],
            "aria-controls": e.ariaControls || null,
            "aria-disabled": o.value ? !0 : null,
            "aria-label": e.labelPage ? `${e.labelPage} ${G.number}` : null,
            role: "menuitemradio",
            type: o.value ? null : "button",
            tabindex: ve,
            onClick: (q) => {
              o.value || k(q, G.number);
            }
          },
          pe
        );
        return ie(
          "li",
          {
            class: [
              "page-item",
              {
                disabled: o.value,
                active: X,
                "flex-fill": f,
                "d-flex": f && !o.value
              },
              e.pageClass
            ],
            role: "presentation",
            key: `page-${G.number}`
          },
          me
        );
      };
      if (!r.value && !n.value) {
        const G = I(
          1,
          e.labelFirstPage,
          Qd,
          e.firstText,
          e.firstClass,
          1
        );
        T.push(G);
      }
      const Z = I(
        a.value - 1,
        e.labelFirstPage,
        lc,
        e.prevText,
        e.prevClass,
        1
      );
      T.push(Z), n.value && c[0] !== 1 && T.push(z({ number: 1 }, 0)), S.value && T.push(E(!1)), C.value.forEach((G, W) => {
        const X = S.value && n.value && c[0] !== 1 ? 1 : 0;
        T.push(z(G, W + X));
      }), A.value && T.push(E(!0)), i.value && c[c.length - 1] !== p.value && T.push(z({ number: p.value }, -1));
      const te = I(
        a.value + 1,
        e.labelNextPage,
        tc,
        e.nextText,
        e.nextClass,
        p.value
      );
      if (T.push(te), !i.value && !r.value) {
        const G = I(
          p.value,
          e.labelLastPage,
          ec,
          e.lastText,
          e.lastClass,
          p.value
        );
        T.push(G);
      }
      return ie(
        "ul",
        {
          class: ["pagination", w.value, h.value, _.value],
          role: "menubar",
          "aria-disabled": o.value,
          "aria-label": e.ariaLabel || null
        },
        T
      );
    };
  }
}), Le = /* @__PURE__ */ N({
  inheritAttrs: !1,
  __name: "BPlaceholder",
  props: {
    tag: { default: "span" },
    wrapperTag: { default: "span" },
    width: { default: void 0 },
    cols: { default: 12 },
    variant: { default: null },
    size: { default: "md" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, l = u(
      () => t.width === void 0 ? void 0 : typeof t.width == "number" ? t.width.toString() : t.width.replace("%", "")
    ), a = u(
      () => t.cols === void 0 ? void 0 : typeof t.cols == "number" ? t.cols.toString() : t.cols
    ), o = u(() => ({
      [`col-${a.value}`]: a.value !== void 0 && l.value === void 0,
      [`bg-${t.variant}`]: t.variant !== null,
      [`placeholder-${t.size}`]: t.size !== "md"
    })), n = u(() => ({
      [`placeholder-${t.animation}`]: t.animation !== void 0
    })), s = u(() => ({
      width: l.value === void 0 ? void 0 : `${l.value}%`
    }));
    return (r, i) => (g(), M(le(r.wrapperTag), {
      class: H(n.value)
    }, {
      default: j(() => [
        (g(), M(le(r.tag), ee(r.$attrs, {
          class: ["placeholder", o.value],
          style: s.value
        }), null, 16, ["class", "style"]))
      ]),
      _: 1
    }, 8, ["class"]));
  }
}), xn = /* @__PURE__ */ N({
  __name: "BPlaceholderButton",
  props: {
    tag: { default: "div" },
    width: { default: void 0 },
    cols: { default: void 0 },
    variant: { default: "primary" },
    animation: { default: void 0 }
  },
  setup(e) {
    const t = e, l = u(() => ({
      [`btn-${t.variant}`]: t.variant !== null
    })), a = u(() => ({
      animation: t.animation,
      width: t.width,
      cols: t.cols,
      tag: t.tag
    }));
    return (o, n) => (g(), M(Le, ee({
      class: ["btn disabled", l.value]
    }, a.value), null, 16, ["class"]));
  }
}), sc = /* @__PURE__ */ N({
  __name: "BPlaceholderCard",
  props: {
    noHeader: { type: [String, Boolean], default: !1 },
    headerWidth: { default: 100 },
    headerVariant: { default: void 0 },
    headerAnimation: { default: void 0 },
    headerSize: { default: "md" },
    noFooter: { type: [String, Boolean], default: !1 },
    footerWidth: { default: 100 },
    footerVariant: { default: void 0 },
    footerAnimation: { default: void 0 },
    footerSize: { default: "md" },
    animation: { default: void 0 },
    size: { default: "md" },
    variant: { default: void 0 },
    noButton: { type: [String, Boolean], default: !1 },
    imgBottom: { type: [String, Boolean], default: !1 },
    imgSrc: { default: void 0 },
    imgBlankColor: { default: "#868e96" },
    imgHeight: { default: 100 },
    noImg: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.noButton), a = d(() => t.noHeader), o = d(() => t.noFooter), n = d(() => t.noImg), s = u(() => ({
      width: t.headerWidth,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      size: t.headerSize
    })), r = u(() => ({
      width: t.footerWidth,
      animation: t.footerAnimation,
      size: l.value ? t.footerSize : void 0,
      variant: t.footerVariant
    })), i = u(() => ({
      animation: t.animation,
      size: t.size,
      variant: t.variant
    })), v = u(() => ({
      blank: !t.imgSrc,
      blankColor: t.imgBlankColor,
      height: t.imgSrc ? void 0 : t.imgHeight,
      src: t.imgSrc,
      top: !t.imgBottom,
      bottom: t.imgBottom
    }));
    return (b, h) => (g(), M(pn, { "img-bottom": b.imgBottom }, Ha({
      default: j(() => [
        O(b.$slots, "default", {}, () => [
          be(Le, ee({ cols: "7" }, i.value), null, 16),
          be(Le, ee({ cols: "4" }, i.value), null, 16),
          be(Le, ee({ cols: "4" }, i.value), null, 16),
          be(Le, ee({ cols: "6" }, i.value), null, 16),
          be(Le, ee({ cols: "8" }, i.value), null, 16)
        ])
      ]),
      _: 2
    }, [
      $(n) ? void 0 : {
        name: "img",
        fn: j(() => [
          O(b.$slots, "img", {}, () => [
            be(ra, Be(Ve(v.value)), null, 16)
          ])
        ]),
        key: "0"
      },
      $(a) ? void 0 : {
        name: "header",
        fn: j(() => [
          O(b.$slots, "header", {}, () => [
            be(Le, Be(Ve(s.value)), null, 16)
          ])
        ]),
        key: "1"
      },
      $(o) ? void 0 : {
        name: "footer",
        fn: j(() => [
          O(b.$slots, "footer", {}, () => [
            $(l) ? (g(), M(Le, Be(ee({ key: 1 }, r.value)), null, 16)) : (g(), M(xn, Be(ee({ key: 0 }, r.value)), null, 16))
          ])
        ]),
        key: "2"
      }
    ]), 1032, ["img-bottom"]));
  }
}), rl = /* @__PURE__ */ N({
  __name: "BTableSimple",
  props: {
    bordered: { type: [String, Boolean], default: !1 },
    borderless: { type: [String, Boolean], default: !1 },
    borderVariant: { default: null },
    captionTop: { type: [String, Boolean], default: !1 },
    dark: { type: [String, Boolean], default: !1 },
    hover: { type: [String, Boolean], default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tableClass: { default: void 0 },
    tableVariant: { default: null },
    stickyHeader: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.captionTop), a = d(() => t.borderless), o = d(() => t.bordered), n = d(() => t.dark), s = d(() => t.hover), r = d(() => t.small), i = d(() => t.striped), v = d(() => t.stickyHeader), b = u(() => [
      "table",
      "b-table",
      {
        "table-bordered": o.value,
        "table-borderless": a.value,
        [`border-${t.borderVariant}`]: t.borderVariant !== null,
        "caption-top": l.value,
        "table-dark": n.value,
        "table-hover": s.value,
        "b-table-stacked": typeof t.stacked == "boolean" && t.stacked,
        [`b-table-stacked-${t.stacked}`]: typeof t.stacked == "string",
        "table-striped": i.value,
        "table-sm": r.value,
        [`table-${t.tableVariant}`]: t.tableVariant !== null
      },
      t.tableClass
    ]), h = u(() => [
      {
        "table-responsive": t.responsive === !0,
        [`table-responsive-${t.responsive}`]: typeof t.responsive == "string",
        "b-table-sticky-header": v.value
      }
    ]);
    return (p, B) => p.responsive ? (g(), P("div", {
      key: 1,
      class: H(h.value)
    }, [
      K("table", {
        class: H(b.value)
      }, [
        O(p.$slots, "default")
      ], 2)
    ], 2)) : (g(), P("table", {
      key: 0,
      class: H(b.value)
    }, [
      O(p.$slots, "default")
    ], 2));
  }
}), rc = /* @__PURE__ */ N({
  __name: "BPlaceholderTable",
  props: {
    rows: { default: 3 },
    columns: { default: 5 },
    cellWidth: { default: 100 },
    size: { default: "md" },
    animation: { default: void 0 },
    variant: { default: void 0 },
    headerColumns: { default: void 0 },
    hideHeader: { type: [String, Boolean], default: !1 },
    headerCellWidth: { default: 100 },
    headerSize: { default: "md" },
    headerAnimation: { default: void 0 },
    headerVariant: { default: void 0 },
    footerColumns: { default: void 0 },
    showFooter: { type: [String, Boolean], default: !1 },
    footerCellWidth: { default: 100 },
    footerSize: { default: "md" },
    footerAnimation: { default: void 0 },
    footerVariant: { default: void 0 }
  },
  setup(e) {
    const t = e, l = bt(() => t.columns, { nanToZero: !0, method: "parseInt" }), a = bt(() => t.rows, { nanToZero: !0, method: "parseInt" }), o = u(() => t.headerColumns ?? NaN), n = u(() => t.footerColumns ?? NaN), s = bt(o, {
      nanToZero: !0,
      method: "parseInt"
    }), r = bt(n, {
      nanToZero: !0,
      method: "parseInt"
    }), i = u(() => l.value || 5), v = u(() => a.value || 3), b = u(
      () => t.headerColumns === void 0 ? i.value : s.value
    ), h = u(
      () => t.footerColumns === void 0 ? i.value : r.value
    ), p = u(() => ({
      size: t.size,
      variant: t.variant,
      animation: t.animation,
      width: t.cellWidth
    })), B = u(() => ({
      size: t.headerSize,
      variant: t.headerVariant,
      animation: t.headerAnimation,
      width: t.headerCellWidth
    })), S = u(() => ({
      size: t.footerSize,
      variant: t.footerVariant,
      animation: t.footerAnimation,
      width: t.footerCellWidth
    })), m = d(() => t.hideHeader), A = d(() => t.showFooter);
    return (y, k) => (g(), M(rl, null, {
      default: j(() => [
        $(m) ? J("", !0) : O(y.$slots, "thead", { key: 0 }, () => [
          K("thead", null, [
            K("tr", null, [
              (g(!0), P(ce, null, he(b.value, (w, _) => (g(), P("th", { key: _ }, [
                be(Le, Be(Ve(B.value)), null, 16)
              ]))), 128))
            ])
          ])
        ]),
        O(y.$slots, "default", {}, () => [
          K("tbody", null, [
            (g(!0), P(ce, null, he(v.value, (w, _) => (g(), P("tr", { key: _ }, [
              (g(!0), P(ce, null, he(i.value, (C, T) => (g(), P("td", { key: T }, [
                be(Le, Be(Ve(p.value)), null, 16)
              ]))), 128))
            ]))), 128))
          ])
        ]),
        $(A) ? O(y.$slots, "tfoot", { key: 1 }, () => [
          K("tfoot", null, [
            K("tr", null, [
              (g(!0), P(ce, null, he(h.value, (w, _) => (g(), P("th", { key: _ }, [
                be(Le, Be(Ve(S.value)), null, 16)
              ]))), 128))
            ])
          ])
        ]) : J("", !0)
      ]),
      _: 3
    }));
  }
}), ic = /* @__PURE__ */ N({
  __name: "BPlaceholderWrapper",
  props: {
    loading: { type: [String, Boolean], default: !1 }
  },
  setup(e) {
    const t = e, l = d(() => t.loading);
    return (a, o) => $(l) ? O(a.$slots, "loading", { key: 0 }) : O(a.$slots, "default", { key: 1 });
  }
}), uc = ["aria-valuenow", "aria-valuemax"], Ln = /* @__PURE__ */ N({
  __name: "BProgressBar",
  props: {
    animated: { type: [String, Boolean], default: !1 },
    label: { default: void 0 },
    labelHtml: { default: void 0 },
    max: { default: void 0 },
    precision: { default: 0 },
    showProgress: { type: [String, Boolean], default: !1 },
    showValue: { type: [String, Boolean], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    value: { default: 0 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = Oe(So, null), a = d(() => t.animated), o = d(() => t.showProgress), n = d(() => t.showValue), s = d(() => t.striped), r = u(() => ({
      "progress-bar-animated": a.value || (l == null ? void 0 : l.animated.value),
      "progress-bar-striped": s.value || (l == null ? void 0 : l.striped.value) || a.value || (l == null ? void 0 : l.animated.value),
      [`bg-${t.variant}`]: t.variant !== null
    })), i = u(
      () => typeof t.precision == "number" ? t.precision : Number.parseFloat(t.precision)
    ), v = u(
      () => typeof t.value == "number" ? t.value : Number.parseFloat(t.value)
    ), b = u(
      () => typeof t.max == "number" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)
    ), h = u(
      () => t.labelHtml !== void 0 ? t.labelHtml : n.value || l != null && l.showValue.value ? v.value.toFixed(i.value) : o.value || l != null && l.showProgress.value ? (v.value * 100 / (b.value || 100)).toFixed(i.value) : t.label !== void 0 ? t.label : ""
    ), p = u(
      () => l != null && l.max.value ? `${v.value * 100 / (typeof l.max.value == "number" ? l.max.value : Number.parseInt(l.max.value))}%` : t.max ? `${v.value * 100 / (typeof t.max == "number" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == "string" ? t.value : `${t.value}%`
    );
    return (B, S) => (g(), P("div", {
      class: H(["progress-bar", r.value]),
      role: "progressbar",
      "aria-valuenow": B.value,
      "aria-valuemin": "0",
      "aria-valuemax": B.max,
      style: ze({ width: p.value })
    }, [
      O(B.$slots, "default", {}, () => [
        ne(Y(h.value), 1)
      ])
    ], 14, uc));
  }
}), dc = /* @__PURE__ */ N({
  __name: "BProgress",
  props: {
    variant: { default: void 0 },
    max: { default: 100 },
    height: { default: void 0 },
    animated: { type: [String, Boolean], default: !1 },
    precision: { default: 0 },
    showProgress: { type: [String, Boolean], default: !1 },
    showValue: { type: [String, Boolean], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    value: { default: 0 }
  },
  setup(e) {
    const t = e, l = d(() => t.animated), a = d(() => t.showProgress), o = d(() => t.showValue), n = d(() => t.striped), s = u(() => ({
      animated: t.animated,
      max: t.max,
      precision: t.precision,
      showProgress: t.showProgress,
      showValue: t.showValue,
      striped: t.striped,
      value: t.value,
      variant: t.variant
    }));
    return De(So, {
      animated: l,
      max: ye(ke(t, "max")),
      showProgress: a,
      showValue: o,
      striped: n
    }), (r, i) => (g(), P("div", {
      class: "progress",
      style: ze({ height: r.height })
    }, [
      O(r.$slots, "default", {}, () => [
        be(Ln, Be(Ve(s.value)), null, 16)
      ])
    ], 4));
  }
}), ao = da("cols", [""], { type: [String, Number], default: null }), cc = N({
  name: "BRow",
  slots: Object,
  props: {
    tag: { type: String, default: "div" },
    gutterX: { type: String, default: null },
    gutterY: { type: String, default: null },
    noGutters: { type: [Boolean, String], default: !1 },
    alignV: { type: String, default: null },
    alignH: { type: String, default: null },
    alignContent: { type: String, default: null },
    ...ao
  },
  setup(e) {
    const t = d(() => e.noGutters), l = Dt(() => e.alignH), a = u(() => bo(e, ao, "cols", "row-cols"));
    return {
      computedClasses: u(() => [
        a.value,
        {
          [`gx-${e.gutterX}`]: e.gutterX !== null,
          [`gy-${e.gutterY}`]: e.gutterY !== null,
          "g-0": t.value,
          [`align-items-${e.alignV}`]: e.alignV !== null,
          [l.value]: e.alignH !== null,
          [`align-content-${e.alignContent}`]: e.alignContent !== null
        }
      ])
    };
  }
});
function fc(e, t, l, a, o, n) {
  return g(), M(le(e.tag), {
    class: H(["row", e.computedClasses])
  }, {
    default: j(() => [
      O(e.$slots, "default")
    ]),
    _: 3
  }, 8, ["class"]);
}
const vc = /* @__PURE__ */ ll(cc, [["render", fc]]), pc = ["TD", "TH", "TR"], mc = [
  "a",
  "a *",
  // Include content inside links
  "button",
  "button *",
  // Include content inside buttons
  "input:not(.disabled):not([disabled])",
  "select:not(.disabled):not([disabled])",
  "textarea:not(.disabled):not([disabled])",
  '[role="link"]',
  '[role="link"] *',
  '[role="button"]',
  '[role="button"] *',
  "[tabindex]:not(.disabled):not([disabled])"
].join(","), Xt = (e) => {
  if (!e || !e.target)
    return !1;
  const t = e.target;
  if ("disabled" in t && t.disabled || pc.indexOf(t.tagName) !== -1)
    return !1;
  if (fl(".dropdown-menu", t))
    return !0;
  const l = t.tagName === "LABEL" ? t : fl("label", t);
  if (l) {
    const a = qa(l, "for"), o = a ? _s(a) : go("input, select, textarea", l);
    if (o && !o.disabled)
      return !0;
  }
  return yo(t, mc);
}, gc = ["title", "abbr", "onClick"], yc = { class: "d-inline-flex flex-nowrap align-items-center gap-1" }, bc = { key: 1 }, hc = ["onClick", "onDblclick", "onMouseenter", "onMouseleave"], Bc = {
  key: 0,
  class: "b-table-stacked-label"
}, Sc = ["colspan"], wc = {
  key: 0,
  class: "b-table-empty-slot"
}, _c = ["colspan"], $c = { key: 0 }, Cc = ["title", "abbr", "onClick"], kc = { key: 1 }, Tc = { key: 2 }, Vc = { key: 3 }, Nn = /* @__PURE__ */ N({
  __name: "BTableLite",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionTop: { type: [String, Boolean], default: !1 },
    borderless: { type: [String, Boolean], default: !1 },
    bordered: { type: [String, Boolean], default: !1 },
    borderVariant: { default: void 0 },
    dark: { type: [String, Boolean], default: !1 },
    fields: { default: () => [] },
    footClone: { type: [String, Boolean], default: !1 },
    hover: { type: [String, Boolean], default: !1 },
    items: { default: () => [] },
    responsive: { type: [Boolean, String], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    labelStacked: { type: Boolean, default: !1 },
    variant: { default: void 0 },
    stickyHeader: { type: [String, Boolean], default: !1 },
    showEmpty: { type: [String, Boolean], default: !1 },
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" },
    tableClasses: { default: void 0 },
    fieldColumnClasses: { type: Function, default: void 0 },
    tbodyTrClass: { type: Function, default: void 0 },
    virtualFields: { default: 0 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered"],
  setup(e, { emit: t }) {
    const l = e, a = d(() => l.footClone), o = d(() => l.labelStacked), n = d(() => l.showEmpty), s = u(() => ({
      [`align-${l.align}`]: l.align !== void 0,
      ...l.tableClasses
    })), r = u(() => ({
      bordered: l.bordered,
      borderless: l.borderless,
      borderVariant: l.borderVariant,
      captionTop: l.captionTop,
      dark: l.dark,
      hover: l.hover,
      responsive: l.responsive,
      striped: l.striped,
      stacked: l.stacked,
      small: l.small,
      tableClass: s.value,
      tableVariant: l.variant,
      stickyHeader: l.stickyHeader
    })), i = u(() => h(l.fields, l.items)), v = u(() => i.value.length + l.virtualFields), b = (c) => typeof c == "string" ? ul(c) : c.label !== void 0 ? c.label : typeof c.key == "string" ? ul(c.key) : c.key, h = (c, V) => {
      const F = [];
      return !(c != null && c.length) && (V != null && V.length) ? (Object.keys(V[0]).forEach((f) => F.push({ key: f, label: il(f) })), F) : (Array.isArray(c) && c.forEach((f) => {
        typeof f == "string" ? F.push({ key: f, label: il(f) }) : ba(f) && f.key && typeof f.key == "string" && F.push({ ...f });
      }), F);
    }, p = (c, V, F) => {
      const f = c[V];
      return F && typeof F == "function" ? F(f, V, c) : f;
    }, B = (c, V) => p(c, V.key, V.formatter), S = (c, V, F = !1) => {
      const f = typeof c == "string" ? c : c.key;
      t("head-clicked", f, c, V, F);
    }, m = (c, V, F) => {
      t("row-clicked", c, V, F);
    }, A = (c, V, F) => t("row-dbl-clicked", c, V, F), y = (c, V, F) => t("row-hovered", c, V, F), k = (c, V, F) => t("row-unhovered", c, V, F), w = (c) => {
      c._showDetails = !c._showDetails;
    }, _ = (c) => [
      c.class,
      c.thClass,
      {
        [`table-${c.variant}`]: c.variant !== null,
        "b-table-sticky-column": c.stickyColumn
      },
      ...l.fieldColumnClasses ? l.fieldColumnClasses(c) : []
    ], C = (c, V) => [
      c.class,
      c.tdClass,
      V != null && V._cellVariants && (V != null && V._cellVariants[c.key]) ? `table-${V == null ? void 0 : V._cellVariants[c.key]}` : void 0,
      {
        [`table-${c.variant}`]: c.variant !== null,
        "b-table-sticky-column": c.stickyColumn
      }
    ], T = (c, V = "row") => {
      const F = [
        c._rowVariant ? `table-${c._rowVariant}` : null,
        c._rowVariant ? `table-${c._rowVariant}` : null
      ];
      if (l.tbodyTrClass) {
        const f = l.tbodyTrClass(c, V);
        f && F.push(...typeof f == "string" ? [f] : f);
      }
      return F;
    };
    return (c, V) => (g(), M(rl, Be(Ve(r.value)), {
      default: j(() => {
        var F;
        return [
          K("thead", null, [
            c.$slots["thead-top"] ? O(c.$slots, "thead-top", { key: 0 }) : J("", !0),
            K("tr", null, [
              O(c.$slots, "thead-tr-prefix"),
              (g(!0), P(ce, null, he(i.value, (f) => (g(), P("th", ee({
                key: f.key,
                scope: "col",
                class: _(f),
                title: f.headerTitle,
                abbr: f.headerAbbr,
                style: f.thStyle
              }, f.thAttr, {
                onClick: (I) => S(f, I)
              }), [
                K("div", yc, [
                  O(c.$slots, "field-prefix", { field: f }),
                  K("div", null, [
                    c.$slots["head(" + f.key + ")"] || c.$slots["head()"] ? O(c.$slots, c.$slots["head(" + f.key + ")"] ? "head(" + f.key + ")" : "head()", {
                      key: 0,
                      label: f.label,
                      column: f.key,
                      field: f,
                      isFoot: !1
                    }) : (g(), P(ce, { key: 1 }, [
                      ne(Y(b(f)), 1)
                    ], 64))
                  ])
                ])
              ], 16, gc))), 128))
            ]),
            c.$slots["thead-sub"] ? (g(), P("tr", bc, [
              (g(!0), P(ce, null, he(i.value, (f) => (g(), P("td", {
                key: f.key,
                scope: "col",
                class: H([f.class, f.thClass, f.variant ? `table-${f.variant}` : ""])
              }, [
                c.$slots["thead-sub"] ? O(c.$slots, "thead-sub", ee({
                  key: 0,
                  items: i.value
                }, f)) : (g(), P(ce, { key: 1 }, [
                  ne(Y(f.label), 1)
                ], 64))
              ], 2))), 128))
            ])) : J("", !0)
          ]),
          K("tbody", null, [
            (g(!0), P(ce, null, he(c.items, (f, I) => (g(), P(ce, { key: I }, [
              K("tr", {
                class: H(T(f, "row")),
                onClick: (E) => !$(Xt)(E) && m(f, I, E),
                onDblclick: (E) => !$(Xt)(E) && A(f, I, E),
                onMouseenter: (E) => !$(Xt)(E) && y(f, I, E),
                onMouseleave: (E) => !$(Xt)(E) && k(f, I, E)
              }, [
                O(c.$slots, "tbody-tr-prefix", { item: f }),
                (g(!0), P(ce, null, he(i.value, (E) => (g(), P("td", ee({
                  key: E.key
                }, E.tdAttr, {
                  class: C(E, f)
                }), [
                  c.stacked && $(o) ? (g(), P("label", Bc, Y(b(E)), 1)) : J("", !0),
                  c.$slots["cell(" + E.key + ")"] || c.$slots["cell()"] ? O(c.$slots, c.$slots["cell(" + E.key + ")"] ? "cell(" + E.key + ")" : "cell()", {
                    key: 1,
                    value: f[E.key],
                    index: I,
                    item: f,
                    field: E,
                    items: c.items,
                    toggleDetails: () => w(f),
                    detailsShowing: f._showDetails
                  }) : (g(), P(ce, { key: 2 }, [
                    ne(Y(B(f, E)), 1)
                  ], 64))
                ], 16))), 128))
              ], 42, hc),
              f._showDetails === !0 && c.$slots["row-details"] ? (g(), P("tr", {
                key: 0,
                class: H(T(f, "row-details"))
              }, [
                K("td", { colspan: v.value }, [
                  O(c.$slots, "row-details", {
                    item: f,
                    toggleDetails: () => w(f)
                  })
                ], 8, Sc)
              ], 2)) : J("", !0)
            ], 64))), 128)),
            O(c.$slots, "tbody-prefix", { fieldsTotal: v.value }),
            $(n) && c.items.length === 0 ? (g(), P("tr", wc, [
              K("td", { colspan: v.value }, [
                O(c.$slots, "empty", { items: c.items }, () => [
                  ne(Y(c.emptyText), 1)
                ])
              ], 8, _c)
            ])) : J("", !0)
          ]),
          $(a) ? (g(), P("tfoot", $c, [
            K("tr", null, [
              (g(!0), P(ce, null, he(i.value, (f) => (g(), P("th", ee({
                key: f.key
              }, f.thAttr, {
                scope: "col",
                class: [f.class, f.thClass, f.variant ? `table-${f.variant}` : ""],
                title: f.headerTitle,
                abbr: f.headerAbbr,
                style: f.thStyle,
                onClick: (I) => S(f, I, !0)
              }), Y(f.label), 17, Cc))), 128))
            ])
          ])) : c.$slots["custom-foot"] ? (g(), P("tfoot", kc, [
            O(c.$slots, "custom-foot", {
              fields: i.value,
              items: c.items,
              columns: (F = i.value) == null ? void 0 : F.length
            })
          ])) : J("", !0),
          c.$slots["table-caption"] ? (g(), P("caption", Tc, [
            O(c.$slots, "table-caption")
          ])) : c.caption ? (g(), P("caption", Vc, Y(c.caption), 1)) : J("", !0)
        ];
      }),
      _: 3
    }, 16));
  }
}), Ac = ["colspan"], Oc = { class: "d-flex align-items-center justify-content-center gap-2" }, Fc = /* @__PURE__ */ K("strong", null, "Loading...", -1), Pc = /* @__PURE__ */ N({
  __name: "BTable",
  props: {
    align: { default: void 0 },
    caption: { default: void 0 },
    captionTop: { type: [String, Boolean], default: !1 },
    borderless: { type: [String, Boolean], default: !1 },
    bordered: { type: [String, Boolean], default: !1 },
    borderVariant: { default: void 0 },
    dark: { type: [String, Boolean], default: !1 },
    fields: { default: () => [] },
    footClone: { type: [String, Boolean], default: !1 },
    hover: { type: [String, Boolean], default: !1 },
    items: { default: () => [] },
    provider: { type: Function, default: void 0 },
    sortCompare: { type: Function, default: void 0 },
    noProvider: { default: void 0 },
    noProviderPaging: { type: [String, Boolean], default: !1 },
    noProviderSorting: { type: [String, Boolean], default: !1 },
    noProviderFiltering: { type: [String, Boolean], default: !1 },
    responsive: { type: [Boolean, String], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    striped: { type: [String, Boolean], default: !1 },
    stacked: { type: [Boolean, String], default: !1 },
    labelStacked: { type: Boolean, default: !1 },
    variant: { default: void 0 },
    sortBy: { default: void 0 },
    sortDesc: { type: [String, Boolean], default: !1 },
    sortInternal: { type: [String, Boolean], default: !0 },
    selectable: { type: [String, Boolean], default: !1 },
    stickySelect: { type: [String, Boolean], default: !1 },
    selectHead: { type: [Boolean, String], default: !0 },
    selectMode: { default: "single" },
    selectionVariant: { default: "primary" },
    stickyHeader: { type: [String, Boolean], default: !1 },
    busy: { type: [String, Boolean], default: !1 },
    showEmpty: { type: [String, Boolean], default: !1 },
    perPage: { default: void 0 },
    currentPage: { default: 1 },
    filter: { default: void 0 },
    filterable: { default: void 0 },
    emptyText: { default: "There are no records to show" },
    emptyFilteredText: { default: "There are no records matching your request" },
    fieldColumnClasses: { type: Function, default: void 0 },
    tbodyTrClass: { type: Function, default: void 0 }
  },
  emits: ["head-clicked", "row-clicked", "row-dbl-clicked", "row-hovered", "row-unhovered", "row-selected", "row-unselected", "selection", "update:busy", "update:sortBy", "update:sortDesc", "sorted", "filtered"],
  setup(e, { expose: t, emit: l }) {
    const a = e, o = Se(a, "sortBy", l, { passive: !0 }), n = Se(a, "busy", l, { passive: !0 }), s = Se(a, "sortDesc", l, { passive: !0 }), r = Fe(), i = R(null), v = d(s), b = d(() => a.sortInternal), h = d(n), p = d(() => a.noProviderPaging), B = d(() => a.noProviderSorting), S = d(() => a.noProviderFiltering), m = d(() => a.selectable), A = d(() => a.stickySelect), y = u(() => a.filter !== void 0 && a.filter !== ""), k = R(/* @__PURE__ */ new Set([])), w = u(() => k.value.size > 0), _ = u(() => a.fields.filter((D) => typeof D == "string" ? !1 : D.sortable).length > 0 || a.sortBy !== void 0), C = u(() => a.provider !== void 0), T = u(() => ({
      "b-table-sortable": _.value,
      "b-table-sort-desc": _.value && v.value === !0,
      "b-table-sort-asc": _.value && v.value === !1,
      "b-table-busy": h.value,
      "b-table-selectable": m.value,
      [`b-table-select-${a.selectMode}`]: m.value,
      "b-table-selecting user-select-none": m.value && w.value
    })), c = u(() => _.value && b.value === !0), V = u(
      () => m.value && (!!a.selectHead || r.selectHead !== void 0)
    ), {
      computedItems: F,
      computedDisplayItems: f,
      updateInternalItems: I,
      filteredHandler: E,
      notifyFilteredItems: z
    } = Zr(
      a,
      {
        sortInternalBoolean: b,
        isFilterableTable: y,
        noProviderPagingBoolean: p,
        isSortable: _,
        requireItemsMapping: c,
        sortDescBoolean: v
      },
      C,
      o
    );
    E.value = async (x) => {
      if (C.value) {
        await W();
        return;
      }
      l("filtered", x);
    };
    const Z = (x, D, ae) => {
      me(x, D, ae.shiftKey, ae.ctrlKey, ae.metaKey), l("row-clicked", x, D, ae);
    }, te = (x, D, ae, ue = !1) => {
      l("head-clicked", x, D, ae, ue), G(D);
    }, G = (x) => {
      if (!_.value)
        return;
      const D = typeof x == "string" ? x : x.key, ae = typeof x == "string" ? !1 : x.sortable;
      if (_.value === !0 && ae === !0) {
        const ue = !v.value;
        o.value = D, s.value = ue, l("sorted", D, ue);
      }
    }, W = async () => {
      if (!C.value || !a.provider || h.value)
        return;
      n.value = !0;
      const x = new Proxy(
        {
          currentPage: a.currentPage,
          filter: a.filter,
          sortBy: a.sortBy,
          sortDesc: a.sortDesc,
          perPage: a.perPage
        },
        {
          get: (ae, ue) => ue in ae ? ae[ue] : void 0,
          set: () => (console.error("BTable provider context is a read-only object."), !0)
        }
      ), D = a.provider(x, I);
      if (D !== void 0) {
        if (D instanceof Promise)
          try {
            const ae = await D;
            return Array.isArray(ae) ? await I(ae) : void 0;
          } finally {
            h.value && (n.value = !1);
          }
        try {
          return await I(D);
        } finally {
          h.value && (n.value = !1);
        }
      }
    }, X = (x) => [
      {
        "b-table-sortable-column": _.value && x.sortable
      }
    ], ve = (x, D) => {
      const ae = [
        m.value && x && k.value.has(x) ? `selected table-${a.selectionVariant}` : null
      ];
      if (a.tbodyTrClass) {
        const ue = a.tbodyTrClass(x, D);
        ue && ae.push(...typeof ue == "string" ? [ue] : ue);
      }
      return ae;
    }, ge = () => {
      const x = [{ "b-table-static-busy": a.items.length === 0 }];
      if (a.tbodyTrClass) {
        const D = a.tbodyTrClass(null, "table-busy");
        D && x.push(...typeof D == "string" ? [D] : D);
      }
      return x;
    }, pe = () => {
      m.value && l("selection", Array.from(k.value));
    }, me = (x, D, ae = !1, ue = !1, U = !1) => {
      if (m.value) {
        if (ae && a.selectMode === "range" && k.value.size > 0) {
          const se = Array.from(k.value).pop(), Ie = a.items.findIndex((ut) => ut === se), et = Math.min(Ie, D), tt = Math.max(Ie, D);
          a.items.slice(et, tt + 1).forEach((ut) => {
            k.value.has(ut) || (k.value.add(ut), l("row-selected", ut));
          });
        } else
          ue || U ? k.value.has(x) ? (k.value.delete(x), l("row-unselected", x)) : a.selectMode === "range" || a.selectMode === "multi" ? (k.value.add(x), l("row-selected", x)) : (k.value.forEach((se) => l("row-unselected", se)), k.value.clear(), k.value.add(x), l("row-selected", x)) : (k.value.forEach((se) => l("row-unselected", se)), k.value.clear(), k.value.add(x), l("row-selected", x));
        pe();
      }
    }, q = () => {
      if (!m.value)
        return;
      const x = k.value.size > 0 ? Array.from(k.value) : [];
      k.value = /* @__PURE__ */ new Set([...a.items]), k.value.forEach((D) => {
        x.includes(D) || l("row-selected", D);
      }), pe();
    }, Q = () => {
      m.value && (k.value.forEach((x) => {
        l("row-unselected", x);
      }), k.value = /* @__PURE__ */ new Set([]), pe());
    }, re = (x) => {
      if (!m.value)
        return;
      const D = a.items[x];
      !D || k.value.has(D) || (k.value.add(D), l("row-selected", D), pe());
    }, de = (x) => {
      if (!m.value)
        return;
      const D = a.items[x];
      !D || !k.value.has(D) || (k.value.delete(D), l("row-unselected", D), pe());
    }, L = async (x, D, ae) => {
      if (D === ae)
        return;
      const ue = (tt) => a.noProvider && a.noProvider.includes(tt), U = !["currentPage", "perPage"].includes(x), se = ["currentPage", "perPage"].includes(x) && (ue("paging") || p.value === !0), Ie = ["filter"].includes(x) && (ue("filtering") || S.value === !0), et = ["sortBy", "sortDesc"].includes(x) && (ue("sorting") || B.value === !0);
      se || Ie || et || (await W(), U && z());
    };
    return oe(
      () => a.filter,
      (x, D) => {
        x === D || C.value || x || l("filtered", F.value);
      }
    ), oe(
      () => a.filter,
      (x, D) => L("filter", x, D)
    ), oe(
      () => a.currentPage,
      (x, D) => L("currentPage", x, D)
    ), oe(
      () => a.perPage,
      (x, D) => L("perPage", x, D)
    ), oe(
      () => a.sortBy,
      (x, D) => L("sortBy", x, D)
    ), oe(
      () => a.sortDesc,
      (x, D) => L("sortDesc", x, D)
    ), He(W), t({
      selectAllRows: q,
      clearSelected: Q,
      selectRow: re,
      unselectRow: de,
      refresh: W
    }), (x, D) => (g(), M(Nn, ee({
      ref_key: "liteTable",
      ref: i
    }, a, {
      busy: $(n),
      "onUpdate:busy": D[0] || (D[0] = (ae) => La(n) ? n.value = ae : null),
      items: $(f),
      "table-classes": T.value,
      "tbody-tr-class": ve,
      "field-column-classes": X,
      "virtual-fields": $(m) ? 1 : 0
    }, io(x.$attrs), {
      onHeadClicked: te,
      onRowClicked: Z
    }), Ha({
      "field-prefix": j((ae) => [
        O(x.$slots, "sort-icon", {
          field: ae.field,
          sortBy: $(o),
          selected: ae.field.key === $(o),
          isDesc: $(v),
          direction: $(v) ? "desc" : "asc"
        }, () => [
          _.value && ae.field.sortable ? (g(), P("span", {
            key: 0,
            class: H(["b-table-sort-icon", {
              sorted: ae.field.key === $(o),
              [`sorted-${$(v) ? "desc" : "asc"}`]: ae.field.key === $(o)
            }])
          }, null, 2)) : J("", !0)
        ])
      ]),
      "thead-tr-prefix": j(() => [
        V.value ? (g(), P("th", {
          key: 0,
          class: H(["b-table-selection-column", {
            "b-table-sticky-column": $(A)
          }])
        }, [
          O(x.$slots, "select-head", {}, () => [
            ne(Y(typeof x.selectHead == "boolean" ? "Selected" : x.selectHead), 1)
          ])
        ], 2)) : J("", !0)
      ]),
      "tbody-tr-prefix": j((ae) => [
        V.value ? (g(), P("td", {
          key: 0,
          class: H(["b-table-selection-column", {
            "b-table-sticky-column": $(A)
          }])
        }, [
          O(x.$slots, "select-cell", {}, () => [
            K("span", {
              class: H(["b-table-selection-icon", k.value.has(ae.item) ? `text-${a.selectionVariant} selected` : ""])
            }, "ð¹", 2)
          ])
        ], 2)) : J("", !0)
      ]),
      "tbody-prefix": j((ae) => [
        $(h) ? (g(), P("tr", {
          key: 0,
          class: H(["b-table-busy-slot", ge()])
        }, [
          K("td", {
            colspan: ae.fieldsTotal
          }, [
            O(x.$slots, "table-busy", {}, () => [
              K("div", Oc, [
                be(pa, { class: "align-middle" }),
                Fc
              ])
            ])
          ], 8, Ac)
        ], 2)) : J("", !0)
      ]),
      _: 2
    }, [
      he(x.$slots, (ae, ue) => ({
        name: ue,
        fn: j((U) => [
          O(x.$slots, ue, Be(Ve(U)))
        ])
      }))
    ]), 1040, ["busy", "items", "table-classes", "virtual-fields"]));
  }
}), Ec = /* @__PURE__ */ N({
  __name: "BTbody",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = u(() => ({
      [`thead-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (g(), P("tbody", {
      class: H(l.value)
    }, [
      O(a.$slots, "default")
    ], 2));
  }
}), Ic = ["scope", "colspan", "rowspan", "data-label"], xc = { key: 0 }, Lc = /* @__PURE__ */ N({
  __name: "BTd",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [String, Boolean], default: !1 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = d(() => t.stickyColumn), a = u(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": l.value,
      "table-b-table-default": l.value && t.variant === null
    })), o = u(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, s) => (g(), P("td", {
      scope: o.value,
      class: H(a.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading ? (g(), P("div", xc, [
        O(n.$slots, "default")
      ])) : O(n.$slots, "default", { key: 1 })
    ], 10, Ic));
  }
}), Nc = /* @__PURE__ */ N({
  __name: "BTfoot",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = u(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (g(), P("tfoot", {
      class: H(l.value)
    }, [
      O(a.$slots, "default")
    ], 2));
  }
}), zc = ["scope", "colspan", "rowspan", "data-label"], Hc = { key: 0 }, Rc = /* @__PURE__ */ N({
  __name: "BTh",
  props: {
    colspan: { default: void 0 },
    rowspan: { default: void 0 },
    stackedHeading: { default: void 0 },
    stickyColumn: { type: [String, Boolean], default: !1 },
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = d(() => t.stickyColumn), a = u(() => ({
      [`table-${t.variant}`]: t.variant !== null,
      "b-table-sticky-column": l.value,
      "table-b-table-default": l.value && t.variant === null
    })), o = u(() => t.colspan ? "colspan" : t.rowspan ? "rowspan" : "col");
    return (n, s) => (g(), P("th", {
      scope: o.value,
      class: H(a.value),
      colspan: n.colspan,
      rowspan: n.rowspan,
      "data-label": n.stackedHeading
    }, [
      n.stackedHeading !== void 0 ? (g(), P("div", Hc, [
        O(n.$slots, "default")
      ])) : O(n.$slots, "default", { key: 1 })
    ], 10, zc));
  }
}), Mc = /* @__PURE__ */ N({
  __name: "BThead",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = u(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (g(), P("thead", {
      class: H(l.value)
    }, [
      O(a.$slots, "default")
    ], 2));
  }
}), Dc = /* @__PURE__ */ N({
  __name: "BTr",
  props: {
    variant: { default: null }
  },
  setup(e) {
    const t = e, l = u(() => ({
      [`table-${t.variant}`]: t.variant !== null
    }));
    return (a, o) => (g(), P("tr", {
      class: H(l.value)
    }, [
      O(a.$slots, "default")
    ], 2));
  }
}), jc = /* @__PURE__ */ N({
  __name: "BTab",
  props: {
    id: { default: void 0 },
    title: { default: void 0 },
    active: { type: [String, Boolean], default: !1 },
    buttonId: { default: void 0 },
    disabled: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: void 0 },
    lazyOnce: { type: [String, Boolean], default: void 0 },
    noBody: { type: [Boolean, String], default: !1 },
    tag: { default: "div" },
    titleItemClass: { default: void 0 },
    titleLinkAttributes: { default: void 0 },
    titleLinkClass: { default: void 0 }
  },
  setup(e) {
    const t = e, l = Oe(Bo, null), a = d(() => t.active), o = d(() => t.disabled), n = d(
      u(() => t.lazyOnce !== void 0 ? t.lazyOnce : t.lazy)
    ), s = R(!1), r = u(() => !!(l != null && l.lazy.value || n.value)), i = u(() => t.lazyOnce !== void 0), v = u(() => a.value && !o.value), b = u(() => {
      const B = r.value && i.value && s.value;
      return v.value || !r.value || B;
    }), h = R(a.value);
    oe(a, (B) => {
      setTimeout(() => {
        h.value = B;
      }, 0);
    });
    const p = u(() => ({
      active: a.value,
      show: h.value,
      "card-body": (l == null ? void 0 : l.card.value) && t.noBody === !1
    }));
    return oe(b, (B) => {
      B && !s.value && (s.value = !0);
    }), (B, S) => (g(), M(le(B.tag), {
      id: B.id,
      class: H(["tab-pane", p.value]),
      role: "tabpanel",
      "aria-labelledby": "profile-tab"
    }, {
      default: j(() => [
        b.value ? O(B.$slots, "default", { key: 0 }) : J("", !0)
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), qc = ["id", "data-bs-target", "aria-controls", "aria-selected", "onClick"], Gc = /* @__PURE__ */ N({
  __name: "BTabs",
  props: {
    activeNavItemClass: { default: void 0 },
    activeTabClass: { default: void 0 },
    align: { default: void 0 },
    contentClass: { default: void 0 },
    card: { type: [String, Boolean], default: !1 },
    end: { type: [String, Boolean], default: !1 },
    fill: { type: [String, Boolean], default: !1 },
    id: { default: void 0 },
    justified: { type: [String, Boolean], default: !1 },
    lazy: { type: [String, Boolean], default: !1 },
    navClass: { default: void 0 },
    navWrapperClass: { default: void 0 },
    noFade: { type: [String, Boolean], default: !1 },
    noNavStyle: { type: [String, Boolean], default: !1 },
    pills: { type: [String, Boolean], default: !1 },
    small: { type: [String, Boolean], default: !1 },
    tag: { default: "div" },
    vertical: { type: [String, Boolean], default: !1 },
    modelValue: { default: -1 }
  },
  emits: ["update:modelValue", "activate-tab", "click"],
  setup(e, { emit: t }) {
    const l = e, a = Se(l, "modelValue", t), o = Fe(), n = d(() => l.card), s = d(() => l.end), r = d(() => l.fill), i = d(() => l.justified), v = d(() => l.lazy), b = d(() => l.noFade), h = d(() => l.noNavStyle), p = d(() => l.pills), B = d(() => l.small), S = d(() => l.vertical), m = R(a.value), A = R(""), y = u({
      get: () => m.value,
      set: (f) => {
        m.value = f, w.value.length > 0 && f >= 0 && f < w.value.length ? A.value = w.value[f].buttonId : A.value = "", a.value = f;
      }
    }), k = R([]);
    oe(
      () => {
        var f;
        return (f = o.default) == null ? void 0 : f.call(o);
      },
      () => {
        k.value = o.default === void 0 ? [] : Ba(o.default, "BTab").map((f, I) => {
          f.props || (f.props = {});
          const E = f.props["button-id"] || at("tab"), z = f.props.id || at(), Z = f.props["title-item-class"], te = f.props["title-link-attributes"];
          return {
            buttonId: E,
            contentId: z,
            disabled: f.props.disabled === "" || f.props.disabled === !0,
            target: `#${z}`,
            title: f.props.title,
            titleItemClass: Z,
            titleLinkAttributes: te,
            onClick: f.props.onClick,
            tab: f,
            tabComponent: () => Ba(o.default, "BTab")[I]
          };
        });
      },
      { immediate: !0 }
    );
    const w = u(
      () => k.value.map((f, I) => {
        const { tab: E } = f;
        E.props || (E.props = {});
        const z = y.value > -1 ? I === y.value : E.props.active === "";
        return {
          ...f,
          active: z,
          navItemClasses: [
            {
              active: z,
              disabled: E.props.disabled === "" || E.props.disabled === !0
            },
            z && l.activeNavItemClass ? l.activeNavItemClass : null,
            E.props["title-link-class"]
          ],
          tabClasses: [
            {
              fade: !b.value
            },
            z && l.activeTabClass ? l.activeTabClass : null
          ]
        };
      })
    ), _ = u(() => !(w != null && w.value && w.value.length > 0)), C = u(() => ({
      "d-flex": S.value,
      "align-items-start": S.value
    })), T = Dt(() => l.align), c = u(() => ({
      "nav-pills": p.value,
      "flex-column me-3": S.value,
      [T.value]: l.align !== void 0,
      "nav-fill": r.value,
      "card-header-tabs": n.value,
      "nav-justified": i.value,
      "nav-tabs": !h.value && !p.value,
      small: B.value
    })), V = (f) => {
      let I = !1;
      if (f !== void 0 && f > -1 && f < w.value.length && !w.value[f].disabled && (y.value < 0 || w.value[f].buttonId !== A.value)) {
        const E = new Ge("activate-tab", { cancelable: !0 });
        t("activate-tab", f, y.value, E), E.defaultPrevented || (y.value = f, I = !0);
      }
      return !I && a.value !== y.value && (a.value = y.value), I;
    }, F = (f, I) => {
      var E;
      V(I), I >= 0 && !w.value[I].disabled && ((E = w.value[I]) != null && E.onClick) && typeof w.value[I].onClick == "function" && w.value[I].onClick(f);
    };
    return V(m.value), oe(a, (f, I) => {
      if (f === I)
        return;
      if (f = Math.max(f, -1), I = Math.max(I, -1), w.value.length <= 0) {
        y.value = -1;
        return;
      }
      const E = f > I;
      let z = f;
      const Z = w.value.length - 1;
      for (; z >= 0 && z <= Z && w.value[z].disabled; )
        z += E ? 1 : -1;
      if (z < 0) {
        V(0);
        return;
      }
      if (z >= w.value.length) {
        V(w.value.length - 1);
        return;
      }
      V(z);
    }), oe(w, () => {
      let f = w.value.map((I) => I.active && !I.disabled).lastIndexOf(!0);
      f < 0 && (y.value >= w.value.length ? f = w.value.map((I) => !I.disabled).lastIndexOf(!0) : w.value[y.value] && !w.value[y.value].disabled && (f = y.value)), f < 0 && (f = w.value.map((I) => !I.disabled).indexOf(!0)), w.value.forEach((I, E) => {
        I.active = E === f;
      }), V(f);
    }), He(() => {
      if (y.value < 0 && w.value.length > 0 && !w.value.some((f) => f.active)) {
        const f = w.value.map((I) => !I.disabled).indexOf(!0);
        V(f >= 0 ? f : -1);
      }
    }), De(Bo, {
      lazy: v,
      card: n
    }), (f, I) => (g(), M(le(f.tag), {
      id: f.id,
      class: H(["tabs", C.value])
    }, {
      default: j(() => [
        $(s) ? (g(), P("div", {
          key: 0,
          class: H(["tab-content", f.contentClass])
        }, [
          (g(!0), P(ce, null, he(w.value, ({ tabComponent: E, contentId: z, tabClasses: Z, active: te }, G) => (g(), M(le(E()), {
            id: z,
            key: G,
            class: H(Z),
            active: te
          }, null, 8, ["id", "class", "active"]))), 128)),
          _.value ? (g(), P("div", {
            key: "bv-empty-tab",
            class: H(["tab-pane active", { "card-body": $(n) }])
          }, [
            O(f.$slots, "empty")
          ], 2)) : J("", !0)
        ], 2)) : J("", !0),
        K("div", {
          class: H([f.navWrapperClass, { "card-header": $(n), "ms-auto": f.vertical && $(s) }])
        }, [
          K("ul", {
            class: H(["nav", [c.value, f.navClass]]),
            role: "tablist"
          }, [
            O(f.$slots, "tabs-start"),
            (g(!0), P(ce, null, he(w.value, ({ tab: E, buttonId: z, contentId: Z, navItemClasses: te, active: G, target: W }, X) => {
              var ve, ge, pe;
              return g(), P("li", {
                key: X,
                class: H(["nav-item", (ve = E == null ? void 0 : E.props) == null ? void 0 : ve["title-item-class"]]),
                role: "presentation"
              }, [
                K("button", ee({
                  id: z,
                  class: ["nav-link", te],
                  "data-bs-toggle": "tab",
                  "data-bs-target": W,
                  role: "tab",
                  "aria-controls": Z,
                  "aria-selected": G
                }, (ge = E == null ? void 0 : E.props) == null ? void 0 : ge["title-link-attributes"], {
                  onClick: ot((me) => F(me, X), ["stop", "prevent"])
                }), [
                  E.children && E.children.title ? (g(), M(le(E.children.title), { key: 0 })) : (g(), P(ce, { key: 1 }, [
                    ne(Y((pe = E == null ? void 0 : E.props) == null ? void 0 : pe.title), 1)
                  ], 64))
                ], 16, qc)
              ], 2);
            }), 128)),
            O(f.$slots, "tabs-end")
          ], 2)
        ], 2),
        $(s) ? J("", !0) : (g(), P("div", {
          key: 1,
          class: H(["tab-content", f.contentClass])
        }, [
          (g(!0), P(ce, null, he(w.value, ({ tabComponent: E, contentId: z, tabClasses: Z, active: te }, G) => (g(), M(le(E()), {
            id: z,
            key: G,
            class: H(Z),
            active: te
          }, null, 8, ["id", "class", "active"]))), 128)),
          _.value ? (g(), P("div", {
            key: "bv-empty-tab",
            class: H(["tab-pane active", { "card-body": $(n) }])
          }, [
            O(f.$slots, "empty")
          ], 2)) : J("", !0)
        ], 2))
      ]),
      _: 3
    }, 8, ["id", "class"]));
  }
}), Wc = /* @__PURE__ */ N({
  __name: "BTooltip",
  setup(e, { expose: t }) {
    var a, o, n;
    const l = R(null);
    return t({
      hide: (a = l.value) == null ? void 0 : a.hideFn,
      show: (o = l.value) == null ? void 0 : o.show,
      toggle: (n = l.value) == null ? void 0 : n.toggle
    }), (s, r) => (g(), M(tl, {
      ref_key: "popover",
      ref: l,
      tooltip: ""
    }, Ha({ _: 2 }, [
      he(s.$slots, (i, v) => ({
        name: v,
        fn: j((b) => [
          O(s.$slots, v, Be(Ve(b)))
        ])
      }))
    ]), 1536));
  }
}), lo = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BAccordion: ni,
  BAccordionItem: ui,
  BAlert: pi,
  BAvatar: bi,
  BAvatarGroup: hi,
  BBadge: Bi,
  BBreadcrumb: _i,
  BBreadcrumbItem: sn,
  BButton: kt,
  BButtonGroup: $i,
  BButtonToolbar: ki,
  BCard: pn,
  BCardBody: fn,
  BCardFooter: vn,
  BCardGroup: Ai,
  BCardHeader: un,
  BCardImg: ra,
  BCardSubtitle: cn,
  BCardText: Oi,
  BCardTitle: dn,
  BCarousel: zi,
  BCarouselSlide: ji,
  BCloseButton: Ot,
  BCol: Pt,
  BCollapse: nn,
  BContainer: Yi,
  BDropdown: hn,
  BDropdownDivider: eu,
  BDropdownForm: lu,
  BDropdownGroup: su,
  BDropdownHeader: iu,
  BDropdownItem: uu,
  BDropdownItemButton: cu,
  BDropdownText: pu,
  BForm: Bn,
  BFormCheckbox: Sn,
  BFormCheckboxGroup: $u,
  BFormFile: Tu,
  BFormFloatingLabel: bu,
  BFormGroup: xu,
  BFormInput: Nu,
  BFormInvalidFeedback: Aa,
  BFormRadio: _n,
  BFormRadioGroup: ju,
  BFormRow: Jt,
  BFormSelect: Uu,
  BFormSelectOption: ol,
  BFormSelectOptionGroup: $n,
  BFormSpinButton: Zu,
  BFormTag: An,
  BFormTags: vd,
  BFormText: Oa,
  BFormTextarea: md,
  BFormValidFeedback: Fa,
  BImg: al,
  BInputGroup: wd,
  BInputGroupAddon: nl,
  BInputGroupAppend: _d,
  BInputGroupPrepend: $d,
  BInputGroupText: On,
  BLink: Xe,
  BListGroup: Cd,
  BListGroupItem: kd,
  BModal: Od,
  BNav: Fd,
  BNavForm: Pd,
  BNavItem: Id,
  BNavItemDropdown: Ld,
  BNavText: zd,
  BNavbar: Hd,
  BNavbarBrand: Rd,
  BNavbarNav: Md,
  BNavbarToggle: Ud,
  BOffcanvas: Yd,
  BOverlay: Pn,
  BPagination: nc,
  BPlaceholder: Le,
  BPlaceholderButton: xn,
  BPlaceholderCard: sc,
  BPlaceholderTable: rc,
  BPlaceholderWrapper: ic,
  BPopover: tl,
  BProgress: dc,
  BProgressBar: Ln,
  BRow: vc,
  BSpinner: pa,
  BTab: jc,
  BTable: Pc,
  BTableLite: Nn,
  BTableSimple: rl,
  BTabs: Gc,
  BTbody: Ec,
  BTd: Lc,
  BTfoot: Nc,
  BTh: Rc,
  BThead: Mc,
  BToast: bn,
  BToastContainer: Va,
  BToastPlugin: yn,
  BToaster: Va,
  BTooltip: Wc,
  BTr: Dc,
  BTransition: At
}, Symbol.toStringTag, { value: "Module" }));
const Kc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  useBreadcrumb: Ko,
  useColorMode: Gr
}, Symbol.toStringTag, { value: "Module" })), Yc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BvCarouselEvent: uo,
  BvEvent: Ge,
  BvTriggerableEvent: Rt
}, Symbol.toStringTag, { value: "Module" })), Jc = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" })), Zc = {
  install(e, t = { components: !0, directives: !0 }) {
    const l = typeof t.components == "boolean" || typeof t.components > "u" ? { all: !0 } : t.components, a = Object.keys(lo);
    Ll(l, a).forEach((s) => {
      const r = lo[s];
      e.component(s, r);
    });
    const o = typeof (t == null ? void 0 : t.directives) == "boolean" || typeof t.directives > "u" ? { all: !0 } : t == null ? void 0 : t.directives, n = Object.keys(Ql);
    Ll(o, n).forEach((s) => {
      const r = s.toLowerCase().startsWith("v") ? s.slice(1) : s, i = Ql[s];
      e.directive(r, i);
    }), t != null && t.BToast && e.use(yn, t);
  }
};
export {
  ni as BAccordion,
  ui as BAccordionItem,
  pi as BAlert,
  bi as BAvatar,
  hi as BAvatarGroup,
  Bi as BBadge,
  _i as BBreadcrumb,
  sn as BBreadcrumbItem,
  kt as BButton,
  $i as BButtonGroup,
  ki as BButtonToolbar,
  pn as BCard,
  fn as BCardBody,
  vn as BCardFooter,
  Ai as BCardGroup,
  un as BCardHeader,
  ra as BCardImg,
  cn as BCardSubtitle,
  Oi as BCardText,
  dn as BCardTitle,
  zi as BCarousel,
  ji as BCarouselSlide,
  Ot as BCloseButton,
  Pt as BCol,
  nn as BCollapse,
  Yi as BContainer,
  hn as BDropdown,
  eu as BDropdownDivider,
  lu as BDropdownForm,
  su as BDropdownGroup,
  iu as BDropdownHeader,
  uu as BDropdownItem,
  cu as BDropdownItemButton,
  pu as BDropdownText,
  Bn as BForm,
  Sn as BFormCheckbox,
  $u as BFormCheckboxGroup,
  Tu as BFormFile,
  bu as BFormFloatingLabel,
  xu as BFormGroup,
  Nu as BFormInput,
  Aa as BFormInvalidFeedback,
  _n as BFormRadio,
  ju as BFormRadioGroup,
  Jt as BFormRow,
  Uu as BFormSelect,
  ol as BFormSelectOption,
  $n as BFormSelectOptionGroup,
  Zu as BFormSpinButton,
  An as BFormTag,
  vd as BFormTags,
  Oa as BFormText,
  md as BFormTextarea,
  Fa as BFormValidFeedback,
  al as BImg,
  wd as BInputGroup,
  nl as BInputGroupAddon,
  _d as BInputGroupAppend,
  $d as BInputGroupPrepend,
  On as BInputGroupText,
  Xe as BLink,
  Cd as BListGroup,
  kd as BListGroupItem,
  Od as BModal,
  Fd as BNav,
  Pd as BNavForm,
  Id as BNavItem,
  Ld as BNavItemDropdown,
  zd as BNavText,
  Hd as BNavbar,
  Rd as BNavbarBrand,
  Md as BNavbarNav,
  Ud as BNavbarToggle,
  Yd as BOffcanvas,
  Pn as BOverlay,
  nc as BPagination,
  Le as BPlaceholder,
  xn as BPlaceholderButton,
  sc as BPlaceholderCard,
  rc as BPlaceholderTable,
  ic as BPlaceholderWrapper,
  tl as BPopover,
  dc as BProgress,
  Ln as BProgressBar,
  vc as BRow,
  pa as BSpinner,
  jc as BTab,
  Pc as BTable,
  Nn as BTableLite,
  rl as BTableSimple,
  Gc as BTabs,
  Ec as BTbody,
  Lc as BTd,
  Nc as BTfoot,
  Rc as BTh,
  Mc as BThead,
  bn as BToast,
  Va as BToastContainer,
  yn as BToastPlugin,
  Va as BToaster,
  Wc as BTooltip,
  Dc as BTr,
  At as BTransition,
  Zc as BootstrapVueNext,
  uo as BvCarouselEvent,
  Ge as BvEvent,
  Rt as BvTriggerableEvent,
  lo as Components,
  Kc as Composables,
  Ql as Directives,
  Jc as Types,
  Yc as Utils,
  Zc as default,
  Ko as useBreadcrumb,
  Gr as useColorMode,
  gn as useToast,
  Dd as vBColorMode,
  Ia as vBModal,
  qd as vBPopover,
  Ia as vBToggle,
  Gd as vBTooltip
};
//# sourceMappingURL=bootstrap-vue-next.mjs.map
